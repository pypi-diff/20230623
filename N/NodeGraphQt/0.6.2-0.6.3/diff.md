# Comparing `tmp/NodeGraphQt-0.6.2.tar.gz` & `tmp/NodeGraphQt-0.6.3.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "NodeGraphQt-0.6.2.tar", last modified: Tue Jun 20 21:52:04 2023, max compression
+gzip compressed data, was "NodeGraphQt-0.6.3.tar", last modified: Fri Jun 23 05:15:11 2023, max compression
```

## Comparing `NodeGraphQt-0.6.2.tar` & `NodeGraphQt-0.6.3.tar`

### file list

```diff
@@ -1,85 +1,85 @@
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.099334 NodeGraphQt-0.6.2/
--rw-rw-rw-   0        0        0     1102 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/LICENSE.md
--rw-rw-rw-   0        0        0       49 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/MANIFEST.in
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.036828 NodeGraphQt-0.6.2/NodeGraphQt/
--rw-rw-rw-   0        0        0     2469 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.052456 NodeGraphQt-0.6.2/NodeGraphQt/base/
--rw-rw-rw-   0        0        0        0 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/base/__init__.py
--rw-rw-rw-   0        0        0    12642 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/base/commands.py
--rw-rw-rw-   0        0        0     2816 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/base/factory.py
--rw-rw-rw-   0        0        0   103281 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/base/graph.py
--rw-rw-rw-   0        0        0     8273 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/base/menu.py
--rw-rw-rw-   0        0        0    20908 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/base/model.py
--rw-rw-rw-   0        0        0    15016 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/base/node.py
--rw-rw-rw-   0        0        0    16292 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/base/port.py
--rw-rw-rw-   0        0        0     7417 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/constants.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.052456 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/
--rw-rw-rw-   0        0        0        0 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/__init__.py
--rw-rw-rw-   0        0        0    11914 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/nodes_palette.py
--rw-rw-rw-   0        0        0     4749 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/nodes_tree.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.068082 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/
--rw-rw-rw-   0        0        0        0 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/__init__.py
--rw-rw-rw-   0        0        0     3550 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/custom_widget_color_picker.py
--rw-rw-rw-   0        0        0     2455 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/custom_widget_file_paths.py
--rw-rw-rw-   0        0        0     4995 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/custom_widget_slider.py
--rw-rw-rw-   0        0        0     6304 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/custom_widget_value_edit.py
--rw-rw-rw-   0        0        0     2948 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/custom_widget_vectors.py
--rw-rw-rw-   0        0        0     2489 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/node_property_factory.py
--rw-rw-rw-   0        0        0    20765 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/node_property_widgets.py
--rw-rw-rw-   0        0        0      761 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/prop_widgets_abstract.py
--rw-rw-rw-   0        0        0     7267 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/prop_widgets_base.py
--rw-rw-rw-   0        0        0      406 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/errors.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.068082 NodeGraphQt-0.6.2/NodeGraphQt/nodes/
--rw-rw-rw-   0        0        0        0 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/nodes/__init__.py
--rw-rw-rw-   0        0        0     4465 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/nodes/backdrop_node.py
--rw-rw-rw-   0        0        0    27550 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/nodes/base_node.py
--rw-rw-rw-   0        0        0     1253 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/nodes/base_node_circle.py
--rw-rw-rw-   0        0        0     5817 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/nodes/group_node.py
--rw-rw-rw-   0        0        0     4409 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/nodes/port_node.py
--rw-rw-rw-   0        0        0      239 2023-06-20 10:44:12.000000 NodeGraphQt-0.6.2/NodeGraphQt/pkg_info.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.083708 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/
--rw-rw-rw-   0        0        0        0 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/__init__.py
--rw-rw-rw-   0        0        0     7060 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_abstract.py
--rw-rw-rw-   0        0        0    11022 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_backdrop.py
--rw-rw-rw-   0        0        0    37021 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_base.py
--rw-rw-rw-   0        0        0    21204 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_circle.py
--rw-rw-rw-   0        0        0    12346 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_group.py
--rw-rw-rw-   0        0        0     4273 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_overlay_disabled.py
--rw-rw-rw-   0        0        0     8159 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_port_in.py
--rw-rw-rw-   0        0        0     8158 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_port_out.py
--rw-rw-rw-   0        0        0     3749 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_text_item.py
--rw-rw-rw-   0        0        0    23782 2023-06-20 10:47:39.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/pipe.py
--rw-rw-rw-   0        0        0    10582 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/port.py
--rw-rw-rw-   0        0        0     2885 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/slicer.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.099334 NodeGraphQt-0.6.2/NodeGraphQt/widgets/
--rw-rw-rw-   0        0        0        0 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/__init__.py
--rw-rw-rw-   0        0        0     3709 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/actions.py
--rw-rw-rw-   0        0        0     1873 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/dialogs.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.099334 NodeGraphQt-0.6.2/NodeGraphQt/widgets/icons/
--rw-rw-rw-   0        0        0    17542 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/icons/node_base.png
--rw-rw-rw-   0        0        0     4550 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/node_graph.py
--rw-rw-rw-   0        0        0    14045 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/node_widgets.py
--rw-rw-rw-   0        0        0     5681 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/scene.py
--rw-rw-rw-   0        0        0    11436 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/tab_search.py
--rw-rw-rw-   0        0        0    56172 2023-06-20 10:42:34.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/viewer.py
--rw-rw-rw-   0        0        0     6914 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/NodeGraphQt/widgets/viewer_nav.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.036828 NodeGraphQt-0.6.2/NodeGraphQt.egg-info/
--rw-rw-rw-   0        0        0     2746 2023-06-20 21:52:04.000000 NodeGraphQt-0.6.2/NodeGraphQt.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     2543 2023-06-20 21:52:04.000000 NodeGraphQt-0.6.2/NodeGraphQt.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-06-20 21:52:04.000000 NodeGraphQt-0.6.2/NodeGraphQt.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       38 2023-06-20 21:52:04.000000 NodeGraphQt-0.6.2/NodeGraphQt.egg-info/requires.txt
--rw-rw-rw-   0        0        0       21 2023-06-20 21:52:04.000000 NodeGraphQt-0.6.2/NodeGraphQt.egg-info/top_level.txt
--rw-rw-rw-   0        0        0     2746 2023-06-20 21:52:04.099334 NodeGraphQt-0.6.2/PKG-INFO
--rw-rw-rw-   0        0        0     2042 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/README.md
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.036828 NodeGraphQt-0.6.2/examples/
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.099334 NodeGraphQt-0.6.2/examples/hotkeys/
--rw-rw-rw-   0        0        0        0 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/examples/hotkeys/__init__.py
--rw-rw-rw-   0        0        0     6199 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/examples/hotkeys/hotkey_functions.py
-drwxrwxrwx   0        0        0        0 2023-06-20 21:52:04.099334 NodeGraphQt-0.6.2/examples/nodes/
--rw-rw-rw-   0        0        0        0 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/examples/nodes/__init__.py
--rw-rw-rw-   0        0        0     2320 2023-06-20 10:42:34.000000 NodeGraphQt-0.6.2/examples/nodes/basic_nodes.py
--rw-rw-rw-   0        0        0     3671 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/examples/nodes/custom_ports_node.py
--rw-rw-rw-   0        0        0      507 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/examples/nodes/group_node.py
--rw-rw-rw-   0        0        0     1822 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/examples/nodes/widget_nodes.py
--rw-rw-rw-   0        0        0     1070 2023-06-20 21:52:04.099334 NodeGraphQt-0.6.2/setup.cfg
--rw-rw-rw-   0        0        0      123 2023-06-11 21:02:19.000000 NodeGraphQt-0.6.2/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.893833 NodeGraphQt-0.6.3/
+-rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/LICENSE.md
+-rw-r--r--   0 runner    (1001) docker     (123)       48 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/MANIFEST.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.885833 NodeGraphQt-0.6.3/NodeGraphQt/
+-rw-r--r--   0 runner    (1001) docker     (123)     2380 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.885833 NodeGraphQt-0.6.3/NodeGraphQt/base/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/base/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12220 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/base/commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2714 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/base/factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)   100336 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/base/graph.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7977 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/base/menu.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20287 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/base/model.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14488 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/base/node.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15811 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/base/port.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7165 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/constants.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.885833 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11570 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/nodes_palette.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4606 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/nodes_tree.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.889833 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3448 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/custom_widget_color_picker.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2379 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/custom_widget_file_paths.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4863 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/custom_widget_slider.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6097 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/custom_widget_value_edit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2846 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/custom_widget_vectors.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2429 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/node_property_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20136 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/node_property_widgets.py
+-rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/prop_widgets_abstract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7015 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/prop_widgets_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)      380 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/errors.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.889833 NodeGraphQt-0.6.3/NodeGraphQt/nodes/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/nodes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4332 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/nodes/backdrop_node.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26737 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/nodes/base_node.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1207 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/nodes/base_node_circle.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5641 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/nodes/group_node.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4274 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/nodes/port_node.py
+-rw-r--r--   0 runner    (1001) docker     (123)      229 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/pkg_info.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.889833 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6808 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_abstract.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10718 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_backdrop.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35984 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20669 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_circle.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12029 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4165 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_overlay_disabled.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7925 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_port_in.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7924 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_port_out.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3632 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_text_item.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23109 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/pipe.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10257 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/port.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2798 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/slicer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.889833 NodeGraphQt-0.6.3/NodeGraphQt/widgets/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3602 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/actions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1811 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/dialogs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.889833 NodeGraphQt-0.6.3/NodeGraphQt/widgets/icons/
+-rw-r--r--   0 runner    (1001) docker     (123)    17542 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/icons/node_base.png
+-rw-r--r--   0 runner    (1001) docker     (123)     4425 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/node_graph.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13598 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/node_widgets.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5510 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/scene.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11128 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/tab_search.py
+-rw-r--r--   0 runner    (1001) docker     (123)    54574 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/viewer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6716 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/NodeGraphQt/widgets/viewer_nav.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.885833 NodeGraphQt-0.6.3/NodeGraphQt.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     2679 2023-06-23 05:15:11.000000 NodeGraphQt-0.6.3/NodeGraphQt.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2543 2023-06-23 05:15:11.000000 NodeGraphQt-0.6.3/NodeGraphQt.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-23 05:15:11.000000 NodeGraphQt-0.6.3/NodeGraphQt.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-23 05:15:11.000000 NodeGraphQt-0.6.3/NodeGraphQt.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       21 2023-06-23 05:15:11.000000 NodeGraphQt-0.6.3/NodeGraphQt.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2679 2023-06-23 05:15:11.893833 NodeGraphQt-0.6.3/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1993 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.881833 NodeGraphQt-0.6.3/examples/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.889833 NodeGraphQt-0.6.3/examples/hotkeys/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/examples/hotkeys/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5925 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/examples/hotkeys/hotkey_functions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:11.893833 NodeGraphQt-0.6.3/examples/nodes/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/examples/nodes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2234 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/examples/nodes/basic_nodes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3550 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/examples/nodes/custom_ports_node.py
+-rw-r--r--   0 runner    (1001) docker     (123)      486 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/examples/nodes/group_node.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1752 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/examples/nodes/widget_nodes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1031 2023-06-23 05:15:11.893833 NodeGraphQt-0.6.3/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)      117 2023-06-23 05:15:04.000000 NodeGraphQt-0.6.3/setup.py
```

### Comparing `NodeGraphQt-0.6.2/LICENSE.md` & `NodeGraphQt-0.6.3/LICENSE.md`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-MIT License
-===========
-
-Copyright (c) 2017 Johnny Chan
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+MIT License
+===========
+
+Copyright (c) 2017 Johnny Chan
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/__init__.py` & `NodeGraphQt-0.6.3/NodeGraphQt/__init__.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,89 +1,89 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-"""
-**NodeGraphQt** is a node graph framework that can be implemented and re purposed
-into applications that supports **PySide2**.
-
-project: https://github.com/jchanvfx/NodeGraphQt
-documentation: https://jchanvfx.github.io/NodeGraphQt/api/html/index.html
-
-example code:
-
-.. code-block:: python
-    :linenos:
-
-    from NodeGraphQt import QtWidgets, NodeGraph, BaseNode
-
-
-    class MyNode(BaseNode):
-
-        __identifier__ = 'io.github.jchanvfx'
-        NODE_NAME = 'My Node'
-
-        def __init__(self):
-            super(MyNode, self).__init__()
-            self.add_input('foo', color=(180, 80, 0))
-            self.add_output('bar')
-
-    if __name__ == '__main__':
-        app = QtWidgets.QApplication([])
-        graph = NodeGraph()
-
-        graph.register_node(BaseNode)
-        graph.register_node(BackdropNode)
-
-        backdrop = graph.create_node('nodeGraphQt.nodes.Backdrop', name='Backdrop')
-        node_a = graph.create_node('io.github.jchanvfx.MyNode', name='Node A')
-        node_b = graph.create_node('io.github.jchanvfx.MyNode', name='Node B', color='#5b162f')
-
-        node_a.set_input(0, node_b.output(0))
-
-        viewer = graph.viewer()
-        viewer.show()
-
-        app.exec_()
-"""
-from .pkg_info import __version__ as VERSION
-from .pkg_info import __license__ as LICENSE
-
-# node graph
-from .base.graph import NodeGraph, SubGraph
-from .base.menu import NodesMenu, NodeGraphMenu, NodeGraphCommand
-
-# nodes & ports
-from .base.port import Port
-from .base.node import NodeObject
-from .nodes.base_node import BaseNode
-from .nodes.base_node_circle import BaseNodeCircle
-from .nodes.backdrop_node import BackdropNode
-from .nodes.group_node import GroupNode
-
-# widgets
-from .widgets.node_widgets import NodeBaseWidget
-from .custom_widgets.nodes_tree import NodesTreeWidget
-from .custom_widgets.nodes_palette import NodesPaletteWidget
-from .custom_widgets.properties_bin.node_property_widgets import PropertiesBinWidget
-
-
-__version__ = VERSION
-__all__ = [
-    'BackdropNode',
-    'BaseNode',
-    'BaseNodeCircle',
-    'GroupNode',
-    'LICENSE',
-    'NodeBaseWidget',
-    'NodeGraph',
-    'NodeGraphCommand',
-    'NodeGraphMenu',
-    'NodeObject',
-    'NodesPaletteWidget',
-    'NodesTreeWidget',
-    'NodesMenu',
-    'Port',
-    'PropertiesBinWidget',
-    'SubGraph',
-    'VERSION',
-    'constants',
-    'custom_widgets'
-]
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+"""
+**NodeGraphQt** is a node graph framework that can be implemented and re purposed
+into applications that supports **PySide2**.
+
+project: https://github.com/jchanvfx/NodeGraphQt
+documentation: https://jchanvfx.github.io/NodeGraphQt/api/html/index.html
+
+example code:
+
+.. code-block:: python
+    :linenos:
+
+    from NodeGraphQt import QtWidgets, NodeGraph, BaseNode
+
+
+    class MyNode(BaseNode):
+
+        __identifier__ = 'io.github.jchanvfx'
+        NODE_NAME = 'My Node'
+
+        def __init__(self):
+            super(MyNode, self).__init__()
+            self.add_input('foo', color=(180, 80, 0))
+            self.add_output('bar')
+
+    if __name__ == '__main__':
+        app = QtWidgets.QApplication([])
+        graph = NodeGraph()
+
+        graph.register_node(BaseNode)
+        graph.register_node(BackdropNode)
+
+        backdrop = graph.create_node('nodeGraphQt.nodes.Backdrop', name='Backdrop')
+        node_a = graph.create_node('io.github.jchanvfx.MyNode', name='Node A')
+        node_b = graph.create_node('io.github.jchanvfx.MyNode', name='Node B', color='#5b162f')
+
+        node_a.set_input(0, node_b.output(0))
+
+        viewer = graph.viewer()
+        viewer.show()
+
+        app.exec_()
+"""
+from .pkg_info import __version__ as VERSION
+from .pkg_info import __license__ as LICENSE
+
+# node graph
+from .base.graph import NodeGraph, SubGraph
+from .base.menu import NodesMenu, NodeGraphMenu, NodeGraphCommand
+
+# nodes & ports
+from .base.port import Port
+from .base.node import NodeObject
+from .nodes.base_node import BaseNode
+from .nodes.base_node_circle import BaseNodeCircle
+from .nodes.backdrop_node import BackdropNode
+from .nodes.group_node import GroupNode
+
+# widgets
+from .widgets.node_widgets import NodeBaseWidget
+from .custom_widgets.nodes_tree import NodesTreeWidget
+from .custom_widgets.nodes_palette import NodesPaletteWidget
+from .custom_widgets.properties_bin.node_property_widgets import PropertiesBinWidget
+
+
+__version__ = VERSION
+__all__ = [
+    'BackdropNode',
+    'BaseNode',
+    'BaseNodeCircle',
+    'GroupNode',
+    'LICENSE',
+    'NodeBaseWidget',
+    'NodeGraph',
+    'NodeGraphCommand',
+    'NodeGraphMenu',
+    'NodeObject',
+    'NodesPaletteWidget',
+    'NodesTreeWidget',
+    'NodesMenu',
+    'Port',
+    'PropertiesBinWidget',
+    'SubGraph',
+    'VERSION',
+    'constants',
+    'custom_widgets'
+]
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/base/commands.py` & `NodeGraphQt-0.6.3/NodeGraphQt/base/commands.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,422 +1,422 @@
-#!/usr/bin/python
-from Qt import QtWidgets
-
-from NodeGraphQt.constants import PortTypeEnum
-
-
-class PropertyChangedCmd(QtWidgets.QUndoCommand):
-    """
-    Node property changed command.
-
-    Args:
-        node (NodeGraphQt.NodeObject): node.
-        name (str): node property name.
-        value (object): node property value.
-    """
-
-    def __init__(self, node, name, value):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.setText('property "{}:{}"'.format(node.name(), name))
-        self.node = node
-        self.name = name
-        self.old_val = node.get_property(name)
-        self.new_val = value
-
-    def set_node_property(self, name, value):
-        """
-        updates the node view and model.
-        """
-        # set model data.
-        model = self.node.model
-        model.set_property(name, value)
-
-        # set view data.
-        view = self.node.view
-
-        # view widgets.
-        if hasattr(view, 'widgets') and name in view.widgets.keys():
-            # check if previous value is identical to current value,
-            # prevent signals from causing a infinite loop.
-            if view.widgets[name].get_value() != value:
-                view.widgets[name].set_value(value)
-
-        # view properties.
-        if name in view.properties.keys():
-            # remap "pos" to "xy_pos" node view has pre-existing pos method.
-            if name == 'pos':
-                name = 'xy_pos'
-            setattr(view, name, value)
-
-        # emit property changed signal.
-        graph = self.node.graph
-        graph.property_changed.emit(self.node, self.name, value)
-
-    def undo(self):
-        if self.old_val != self.new_val:
-            self.set_node_property(self.name, self.old_val)
-
-    def redo(self):
-        if self.old_val != self.new_val:
-            self.set_node_property(self.name, self.new_val)
-
-
-class NodeVisibleCmd(QtWidgets.QUndoCommand):
-    """
-    Node visibility changed command.
-
-    Args:
-        node (NodeGraphQt.NodeObject): node.
-        visible (bool): node visible value.
-    """
-
-    def __init__(self, node, visible):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.node = node
-        self.visible = visible
-        self.selected = self.node.selected()
-
-    def set_node_visible(self, visible):
-        model = self.node.model
-        model.set_property('visible', visible)
-
-        node_view = self.node.view
-        node_view.visible = visible
-
-        # redraw the connected pipes in the scene.
-        ports = node_view.inputs + node_view.outputs
-        for port in ports:
-            for pipe in port.connected_pipes:
-                pipe.update()
-
-        # restore the node selected state.
-        if self.selected != node_view.isSelected():
-            node_view.setSelected(model.selected)
-
-        # emit property changed signal.
-        graph = self.node.graph
-        graph.property_changed.emit(self.node, 'visible', visible)
-
-    def undo(self):
-        self.set_node_visible(not self.visible)
-
-    def redo(self):
-        self.set_node_visible(self.visible)
-
-
-class NodeMovedCmd(QtWidgets.QUndoCommand):
-    """
-    Node moved command.
-
-    Args:
-        node (NodeGraphQt.NodeObject): node.
-        pos (tuple(float, float)): new node position.
-        prev_pos (tuple(float, float)): previous node position.
-    """
-
-    def __init__(self, node, pos, prev_pos):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.node = node
-        self.pos = pos
-        self.prev_pos = prev_pos
-
-    def undo(self):
-        self.node.view.xy_pos = self.prev_pos
-        self.node.model.pos = self.prev_pos
-
-    def redo(self):
-        if self.pos == self.prev_pos:
-            return
-        self.node.view.xy_pos = self.pos
-        self.node.model.pos = self.pos
-
-
-class NodeAddedCmd(QtWidgets.QUndoCommand):
-    """
-    Node added command.
-
-    Args:
-        graph (NodeGraphQt.NodeGraph): node graph.
-        node (NodeGraphQt.NodeObject): node.
-        pos (tuple(float, float)): initial node position (optional).
-    """
-
-    def __init__(self, graph, node, pos=None):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.setText('added node')
-        self.viewer = graph.viewer()
-        self.model = graph.model
-        self.node = node
-        self.pos = pos
-
-    def undo(self):
-        self.pos = self.pos or self.node.pos()
-        self.model.nodes.pop(self.node.id)
-        self.node.view.delete()
-
-    def redo(self):
-        self.model.nodes[self.node.id] = self.node
-        self.viewer.add_node(self.node.view, self.pos)
-
-        # node width & height is calculated when its added to the scene
-        # so we have to update the node model here.
-        self.node.model.width = self.node.view.width
-        self.node.model.height = self.node.view.height
-
-
-class NodeRemovedCmd(QtWidgets.QUndoCommand):
-    """
-    Node deleted command.
-
-    Args:
-        graph (NodeGraphQt.NodeGraph): node graph.
-        node (NodeGraphQt.BaseNode or NodeGraphQt.NodeObject): node.
-    """
-
-    def __init__(self, graph, node):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.setText('deleted node')
-        self.scene = graph.scene()
-        self.model = graph.model
-        self.node = node
-
-    def undo(self):
-        self.model.nodes[self.node.id] = self.node
-        self.scene.addItem(self.node.view)
-
-    def redo(self):
-        self.model.nodes.pop(self.node.id)
-        self.node.view.delete()
-
-
-class NodeInputConnectedCmd(QtWidgets.QUndoCommand):
-    """
-    "BaseNode.on_input_connected()" command.
-
-    Args:
-        src_port (NodeGraphQt.Port): source port.
-        trg_port (NodeGraphQt.Port): target port.
-    """
-
-    def __init__(self, src_port, trg_port):
-        QtWidgets.QUndoCommand.__init__(self)
-        if src_port.type_() == PortTypeEnum.IN.value:
-            self.source = src_port
-            self.target = trg_port
-        else:
-            self.source = trg_port
-            self.target = src_port
-
-    def undo(self):
-        node = self.source.node()
-        node.on_input_disconnected(self.source, self.target)
-
-    def redo(self):
-        node = self.source.node()
-        node.on_input_connected(self.source, self.target)
-
-
-class NodeInputDisconnectedCmd(QtWidgets.QUndoCommand):
-    """
-    Node "on_input_disconnected()" command.
-
-    Args:
-        src_port (NodeGraphQt.Port): source port.
-        trg_port (NodeGraphQt.Port): target port.
-    """
-
-    def __init__(self, src_port, trg_port):
-        QtWidgets.QUndoCommand.__init__(self)
-        if src_port.type_() == PortTypeEnum.IN.value:
-            self.source = src_port
-            self.target = trg_port
-        else:
-            self.source = trg_port
-            self.target = src_port
-
-    def undo(self):
-        node = self.source.node()
-        node.on_input_connected(self.source, self.target)
-
-    def redo(self):
-        node = self.source.node()
-        node.on_input_disconnected(self.source, self.target)
-
-
-class PortConnectedCmd(QtWidgets.QUndoCommand):
-    """
-    Port connected command.
-
-    Args:
-        src_port (NodeGraphQt.Port): source port.
-        trg_port (NodeGraphQt.Port): target port.
-    """
-
-    def __init__(self, src_port, trg_port):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.source = src_port
-        self.target = trg_port
-
-    def undo(self):
-        src_model = self.source.model
-        trg_model = self.target.model
-        src_id = self.source.node().id
-        trg_id = self.target.node().id
-
-        port_names = src_model.connected_ports.get(trg_id)
-        if port_names is []:
-            del src_model.connected_ports[trg_id]
-        if port_names and self.target.name() in port_names:
-            port_names.remove(self.target.name())
-
-        port_names = trg_model.connected_ports.get(src_id)
-        if port_names is []:
-            del trg_model.connected_ports[src_id]
-        if port_names and self.source.name() in port_names:
-            port_names.remove(self.source.name())
-
-        self.source.view.disconnect_from(self.target.view)
-
-    def redo(self):
-        src_model = self.source.model
-        trg_model = self.target.model
-        src_id = self.source.node().id
-        trg_id = self.target.node().id
-
-        src_model.connected_ports[trg_id].append(self.target.name())
-        trg_model.connected_ports[src_id].append(self.source.name())
-
-        self.source.view.connect_to(self.target.view)
-
-
-class PortDisconnectedCmd(QtWidgets.QUndoCommand):
-    """
-    Port disconnected command.
-
-    Args:
-        src_port (NodeGraphQt.Port): source port.
-        trg_port (NodeGraphQt.Port): target port.
-    """
-
-    def __init__(self, src_port, trg_port):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.source = src_port
-        self.target = trg_port
-
-    def undo(self):
-        src_model = self.source.model
-        trg_model = self.target.model
-        src_id = self.source.node().id
-        trg_id = self.target.node().id
-
-        src_model.connected_ports[trg_id].append(self.target.name())
-        trg_model.connected_ports[src_id].append(self.source.name())
-
-        self.source.view.connect_to(self.target.view)
-
-    def redo(self):
-        src_model = self.source.model
-        trg_model = self.target.model
-        src_id = self.source.node().id
-        trg_id = self.target.node().id
-
-        port_names = src_model.connected_ports.get(trg_id)
-        if port_names is []:
-            del src_model.connected_ports[trg_id]
-        if port_names and self.target.name() in port_names:
-            port_names.remove(self.target.name())
-
-        port_names = trg_model.connected_ports.get(src_id)
-        if port_names is []:
-            del trg_model.connected_ports[src_id]
-        if port_names and self.source.name() in port_names:
-            port_names.remove(self.source.name())
-
-        self.source.view.disconnect_from(self.target.view)
-
-
-class PortLockedCmd(QtWidgets.QUndoCommand):
-    """
-    Port locked command.
-
-    Args:
-        port (NodeGraphQt.Port): node port.
-    """
-
-    def __init__(self, port):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.setText('lock port "{}"'.format(port.name()))
-        self.port = port
-
-    def undo(self):
-        self.port.model.locked = False
-        self.port.view.locked = False
-
-    def redo(self):
-        self.port.model.locked = True
-        self.port.view.locked = True
-
-
-class PortUnlockedCmd(QtWidgets.QUndoCommand):
-    """
-    Port unlocked command.
-
-    Args:
-        port (NodeGraphQt.Port): node port.
-    """
-
-    def __init__(self, port):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.setText('unlock port "{}"'.format(port.name()))
-        self.port = port
-
-    def undo(self):
-        self.port.model.locked = True
-        self.port.view.locked = True
-
-    def redo(self):
-        self.port.model.locked = False
-        self.port.view.locked = False
-
-
-class PortVisibleCmd(QtWidgets.QUndoCommand):
-    """
-    Port visibility command.
-
-    Args:
-        port (NodeGraphQt.Port): node port.
-    """
-
-    def __init__(self, port, visible):
-        QtWidgets.QUndoCommand.__init__(self)
-        self.port = port
-        self.visible = visible
-        if visible:
-            self.setText('show port {}'.format(self.port.name()))
-        else:
-            self.setText('hide port {}'.format(self.port.name()))
-
-    def set_visible(self, visible):
-        self.port.model.visible = visible
-        self.port.view.setVisible(visible)
-        node_view = self.port.node().view
-        text_item = None
-        if self.port.type_() == PortTypeEnum.IN.value:
-            text_item = node_view.get_input_text_item(self.port.view)
-        elif self.port.type_() == PortTypeEnum.OUT.value:
-            text_item = node_view.get_output_text_item(self.port.view)
-        if text_item:
-            text_item.setVisible(visible)
-
-        node_view.draw_node()
-
-        # redraw the connected pipes in the scene.
-        ports = node_view.inputs + node_view.outputs
-        for port in node_view.inputs + node_view.outputs:
-            for pipe in port.connected_pipes:
-                pipe.update()
-
-    def undo(self):
-        self.set_visible(not self.visible)
-        
-    def redo(self):
-        self.set_visible(self.visible)
+#!/usr/bin/python
+from Qt import QtWidgets
+
+from NodeGraphQt.constants import PortTypeEnum
+
+
+class PropertyChangedCmd(QtWidgets.QUndoCommand):
+    """
+    Node property changed command.
+
+    Args:
+        node (NodeGraphQt.NodeObject): node.
+        name (str): node property name.
+        value (object): node property value.
+    """
+
+    def __init__(self, node, name, value):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.setText('property "{}:{}"'.format(node.name(), name))
+        self.node = node
+        self.name = name
+        self.old_val = node.get_property(name)
+        self.new_val = value
+
+    def set_node_property(self, name, value):
+        """
+        updates the node view and model.
+        """
+        # set model data.
+        model = self.node.model
+        model.set_property(name, value)
+
+        # set view data.
+        view = self.node.view
+
+        # view widgets.
+        if hasattr(view, 'widgets') and name in view.widgets.keys():
+            # check if previous value is identical to current value,
+            # prevent signals from causing a infinite loop.
+            if view.widgets[name].get_value() != value:
+                view.widgets[name].set_value(value)
+
+        # view properties.
+        if name in view.properties.keys():
+            # remap "pos" to "xy_pos" node view has pre-existing pos method.
+            if name == 'pos':
+                name = 'xy_pos'
+            setattr(view, name, value)
+
+        # emit property changed signal.
+        graph = self.node.graph
+        graph.property_changed.emit(self.node, self.name, value)
+
+    def undo(self):
+        if self.old_val != self.new_val:
+            self.set_node_property(self.name, self.old_val)
+
+    def redo(self):
+        if self.old_val != self.new_val:
+            self.set_node_property(self.name, self.new_val)
+
+
+class NodeVisibleCmd(QtWidgets.QUndoCommand):
+    """
+    Node visibility changed command.
+
+    Args:
+        node (NodeGraphQt.NodeObject): node.
+        visible (bool): node visible value.
+    """
+
+    def __init__(self, node, visible):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.node = node
+        self.visible = visible
+        self.selected = self.node.selected()
+
+    def set_node_visible(self, visible):
+        model = self.node.model
+        model.set_property('visible', visible)
+
+        node_view = self.node.view
+        node_view.visible = visible
+
+        # redraw the connected pipes in the scene.
+        ports = node_view.inputs + node_view.outputs
+        for port in ports:
+            for pipe in port.connected_pipes:
+                pipe.update()
+
+        # restore the node selected state.
+        if self.selected != node_view.isSelected():
+            node_view.setSelected(model.selected)
+
+        # emit property changed signal.
+        graph = self.node.graph
+        graph.property_changed.emit(self.node, 'visible', visible)
+
+    def undo(self):
+        self.set_node_visible(not self.visible)
+
+    def redo(self):
+        self.set_node_visible(self.visible)
+
+
+class NodeMovedCmd(QtWidgets.QUndoCommand):
+    """
+    Node moved command.
+
+    Args:
+        node (NodeGraphQt.NodeObject): node.
+        pos (tuple(float, float)): new node position.
+        prev_pos (tuple(float, float)): previous node position.
+    """
+
+    def __init__(self, node, pos, prev_pos):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.node = node
+        self.pos = pos
+        self.prev_pos = prev_pos
+
+    def undo(self):
+        self.node.view.xy_pos = self.prev_pos
+        self.node.model.pos = self.prev_pos
+
+    def redo(self):
+        if self.pos == self.prev_pos:
+            return
+        self.node.view.xy_pos = self.pos
+        self.node.model.pos = self.pos
+
+
+class NodeAddedCmd(QtWidgets.QUndoCommand):
+    """
+    Node added command.
+
+    Args:
+        graph (NodeGraphQt.NodeGraph): node graph.
+        node (NodeGraphQt.NodeObject): node.
+        pos (tuple(float, float)): initial node position (optional).
+    """
+
+    def __init__(self, graph, node, pos=None):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.setText('added node')
+        self.viewer = graph.viewer()
+        self.model = graph.model
+        self.node = node
+        self.pos = pos
+
+    def undo(self):
+        self.pos = self.pos or self.node.pos()
+        self.model.nodes.pop(self.node.id)
+        self.node.view.delete()
+
+    def redo(self):
+        self.model.nodes[self.node.id] = self.node
+        self.viewer.add_node(self.node.view, self.pos)
+
+        # node width & height is calculated when its added to the scene
+        # so we have to update the node model here.
+        self.node.model.width = self.node.view.width
+        self.node.model.height = self.node.view.height
+
+
+class NodeRemovedCmd(QtWidgets.QUndoCommand):
+    """
+    Node deleted command.
+
+    Args:
+        graph (NodeGraphQt.NodeGraph): node graph.
+        node (NodeGraphQt.BaseNode or NodeGraphQt.NodeObject): node.
+    """
+
+    def __init__(self, graph, node):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.setText('deleted node')
+        self.scene = graph.scene()
+        self.model = graph.model
+        self.node = node
+
+    def undo(self):
+        self.model.nodes[self.node.id] = self.node
+        self.scene.addItem(self.node.view)
+
+    def redo(self):
+        self.model.nodes.pop(self.node.id)
+        self.node.view.delete()
+
+
+class NodeInputConnectedCmd(QtWidgets.QUndoCommand):
+    """
+    "BaseNode.on_input_connected()" command.
+
+    Args:
+        src_port (NodeGraphQt.Port): source port.
+        trg_port (NodeGraphQt.Port): target port.
+    """
+
+    def __init__(self, src_port, trg_port):
+        QtWidgets.QUndoCommand.__init__(self)
+        if src_port.type_() == PortTypeEnum.IN.value:
+            self.source = src_port
+            self.target = trg_port
+        else:
+            self.source = trg_port
+            self.target = src_port
+
+    def undo(self):
+        node = self.source.node()
+        node.on_input_disconnected(self.source, self.target)
+
+    def redo(self):
+        node = self.source.node()
+        node.on_input_connected(self.source, self.target)
+
+
+class NodeInputDisconnectedCmd(QtWidgets.QUndoCommand):
+    """
+    Node "on_input_disconnected()" command.
+
+    Args:
+        src_port (NodeGraphQt.Port): source port.
+        trg_port (NodeGraphQt.Port): target port.
+    """
+
+    def __init__(self, src_port, trg_port):
+        QtWidgets.QUndoCommand.__init__(self)
+        if src_port.type_() == PortTypeEnum.IN.value:
+            self.source = src_port
+            self.target = trg_port
+        else:
+            self.source = trg_port
+            self.target = src_port
+
+    def undo(self):
+        node = self.source.node()
+        node.on_input_connected(self.source, self.target)
+
+    def redo(self):
+        node = self.source.node()
+        node.on_input_disconnected(self.source, self.target)
+
+
+class PortConnectedCmd(QtWidgets.QUndoCommand):
+    """
+    Port connected command.
+
+    Args:
+        src_port (NodeGraphQt.Port): source port.
+        trg_port (NodeGraphQt.Port): target port.
+    """
+
+    def __init__(self, src_port, trg_port):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.source = src_port
+        self.target = trg_port
+
+    def undo(self):
+        src_model = self.source.model
+        trg_model = self.target.model
+        src_id = self.source.node().id
+        trg_id = self.target.node().id
+
+        port_names = src_model.connected_ports.get(trg_id)
+        if port_names is []:
+            del src_model.connected_ports[trg_id]
+        if port_names and self.target.name() in port_names:
+            port_names.remove(self.target.name())
+
+        port_names = trg_model.connected_ports.get(src_id)
+        if port_names is []:
+            del trg_model.connected_ports[src_id]
+        if port_names and self.source.name() in port_names:
+            port_names.remove(self.source.name())
+
+        self.source.view.disconnect_from(self.target.view)
+
+    def redo(self):
+        src_model = self.source.model
+        trg_model = self.target.model
+        src_id = self.source.node().id
+        trg_id = self.target.node().id
+
+        src_model.connected_ports[trg_id].append(self.target.name())
+        trg_model.connected_ports[src_id].append(self.source.name())
+
+        self.source.view.connect_to(self.target.view)
+
+
+class PortDisconnectedCmd(QtWidgets.QUndoCommand):
+    """
+    Port disconnected command.
+
+    Args:
+        src_port (NodeGraphQt.Port): source port.
+        trg_port (NodeGraphQt.Port): target port.
+    """
+
+    def __init__(self, src_port, trg_port):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.source = src_port
+        self.target = trg_port
+
+    def undo(self):
+        src_model = self.source.model
+        trg_model = self.target.model
+        src_id = self.source.node().id
+        trg_id = self.target.node().id
+
+        src_model.connected_ports[trg_id].append(self.target.name())
+        trg_model.connected_ports[src_id].append(self.source.name())
+
+        self.source.view.connect_to(self.target.view)
+
+    def redo(self):
+        src_model = self.source.model
+        trg_model = self.target.model
+        src_id = self.source.node().id
+        trg_id = self.target.node().id
+
+        port_names = src_model.connected_ports.get(trg_id)
+        if port_names is []:
+            del src_model.connected_ports[trg_id]
+        if port_names and self.target.name() in port_names:
+            port_names.remove(self.target.name())
+
+        port_names = trg_model.connected_ports.get(src_id)
+        if port_names is []:
+            del trg_model.connected_ports[src_id]
+        if port_names and self.source.name() in port_names:
+            port_names.remove(self.source.name())
+
+        self.source.view.disconnect_from(self.target.view)
+
+
+class PortLockedCmd(QtWidgets.QUndoCommand):
+    """
+    Port locked command.
+
+    Args:
+        port (NodeGraphQt.Port): node port.
+    """
+
+    def __init__(self, port):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.setText('lock port "{}"'.format(port.name()))
+        self.port = port
+
+    def undo(self):
+        self.port.model.locked = False
+        self.port.view.locked = False
+
+    def redo(self):
+        self.port.model.locked = True
+        self.port.view.locked = True
+
+
+class PortUnlockedCmd(QtWidgets.QUndoCommand):
+    """
+    Port unlocked command.
+
+    Args:
+        port (NodeGraphQt.Port): node port.
+    """
+
+    def __init__(self, port):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.setText('unlock port "{}"'.format(port.name()))
+        self.port = port
+
+    def undo(self):
+        self.port.model.locked = True
+        self.port.view.locked = True
+
+    def redo(self):
+        self.port.model.locked = False
+        self.port.view.locked = False
+
+
+class PortVisibleCmd(QtWidgets.QUndoCommand):
+    """
+    Port visibility command.
+
+    Args:
+        port (NodeGraphQt.Port): node port.
+    """
+
+    def __init__(self, port, visible):
+        QtWidgets.QUndoCommand.__init__(self)
+        self.port = port
+        self.visible = visible
+        if visible:
+            self.setText('show port {}'.format(self.port.name()))
+        else:
+            self.setText('hide port {}'.format(self.port.name()))
+
+    def set_visible(self, visible):
+        self.port.model.visible = visible
+        self.port.view.setVisible(visible)
+        node_view = self.port.node().view
+        text_item = None
+        if self.port.type_() == PortTypeEnum.IN.value:
+            text_item = node_view.get_input_text_item(self.port.view)
+        elif self.port.type_() == PortTypeEnum.OUT.value:
+            text_item = node_view.get_output_text_item(self.port.view)
+        if text_item:
+            text_item.setVisible(visible)
+
+        node_view.draw_node()
+
+        # redraw the connected pipes in the scene.
+        ports = node_view.inputs + node_view.outputs
+        for port in node_view.inputs + node_view.outputs:
+            for pipe in port.connected_pipes:
+                pipe.update()
+
+    def undo(self):
+        self.set_visible(not self.visible)
+        
+    def redo(self):
+        self.set_visible(self.visible)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/base/graph.py` & `NodeGraphQt-0.6.3/NodeGraphQt/base/graph.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,2945 +1,2945 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-import copy
-import json
-import os
-import re
-
-from Qt import QtCore, QtWidgets
-
-from NodeGraphQt.base.commands import (NodeAddedCmd,
-                                       NodeRemovedCmd,
-                                       NodeMovedCmd,
-                                       PortConnectedCmd)
-from NodeGraphQt.base.factory import NodeFactory
-from NodeGraphQt.base.menu import NodeGraphMenu, NodesMenu
-from NodeGraphQt.base.model import NodeGraphModel
-from NodeGraphQt.base.node import NodeObject
-from NodeGraphQt.base.port import Port
-from NodeGraphQt.constants import (
-    URI_SCHEME,
-    URN_SCHEME,
-    LayoutDirectionEnum,
-    PipeLayoutEnum,
-    PortTypeEnum,
-    ViewerEnum
-)
-from NodeGraphQt.errors import NodeCreationError, NodeDeletionError
-from NodeGraphQt.nodes.backdrop_node import BackdropNode
-from NodeGraphQt.nodes.base_node import BaseNode
-from NodeGraphQt.nodes.group_node import GroupNode
-from NodeGraphQt.nodes.port_node import PortInputNode, PortOutputNode
-from NodeGraphQt.widgets.node_graph import NodeGraphWidget, SubGraphWidget
-from NodeGraphQt.widgets.viewer import NodeViewer
-from NodeGraphQt.widgets.viewer_nav import NodeNavigationWidget
-
-
-class NodeGraph(QtCore.QObject):
-    """
-    The ``NodeGraph`` class is the main controller for managing all nodes
-    and the node graph.
-
-    .. inheritance-diagram:: NodeGraphQt.NodeGraph
-        :top-classes: PySide2.QtCore.QObject
-
-    .. image:: _images/graph.png
-        :width: 60%
-    """
-
-    nodes_registered = QtCore.Signal(list)
-    """
-    Signal triggered when a node is registered into the node graph.
-
-    :parameters: list[:class:`NodeGraphQt.NodeObject`]
-    :emits: registered nodes
-    """
-
-    node_created = QtCore.Signal(NodeObject)
-    """
-    Signal triggered when a node is created in the node graph.
-
-    :parameters: :class:`NodeGraphQt.NodeObject`
-    :emits: created node
-    """
-    nodes_deleted = QtCore.Signal(list)
-    """
-    Signal triggered when nodes have been deleted from the node graph.
-
-    :parameters: list[str]
-    :emits: list of deleted node ids.
-    """
-    node_selected = QtCore.Signal(NodeObject)
-    """
-    Signal triggered when a node is clicked with the LMB.
-
-    :parameters: :class:`NodeGraphQt.NodeObject`
-    :emits: selected node
-    """
-    node_selection_changed = QtCore.Signal(list, list)
-    """
-    Signal triggered when the node selection has changed.
-
-    :parameters: list[:class:`NodeGraphQt.NodeObject`],
-                 list[:class:`NodeGraphQt.NodeObject`]
-    :emits: selected node, deselected nodes.
-    """
-    node_double_clicked = QtCore.Signal(NodeObject)
-    """
-    Signal triggered when a node is double clicked and emits the node.
-
-    :parameters: :class:`NodeGraphQt.NodeObject`
-    :emits: selected node
-    """
-    port_connected = QtCore.Signal(Port, Port)
-    """
-    Signal triggered when a node port has been connected.
-
-    :parameters: :class:`NodeGraphQt.Port`, :class:`NodeGraphQt.Port`
-    :emits: input port, output port
-    """
-    port_disconnected = QtCore.Signal(Port, Port)
-    """
-    Signal triggered when a node port has been disconnected.
-
-    :parameters: :class:`NodeGraphQt.Port`, :class:`NodeGraphQt.Port`
-    :emits: input port, output port
-    """
-    property_changed = QtCore.Signal(NodeObject, str, object)
-    """
-    Signal is triggered when a property has changed on a node.
-
-    :parameters: :class:`NodeGraphQt.BaseNode`, str, object
-    :emits: triggered node, property name, property value
-    """
-    data_dropped = QtCore.Signal(QtCore.QMimeData, QtCore.QPoint)
-    """
-    Signal is triggered when data has been dropped to the graph.
-
-    :parameters: :class:`PySide2.QtCore.QMimeData`, :class:`PySide2.QtCore.QPoint`
-    :emits: mime data, node graph position
-    """
-    session_changed = QtCore.Signal(str)
-    """
-    Signal is triggered when session has been changed.
-
-    :parameters: :str
-    :emits: new session path
-    """
-
-    def __init__(self, parent=None, **kwargs):
-        """
-        Args:
-            parent (object): object parent.
-            **kwargs (dict): Used for overriding internal objects at init time.
-        """
-        super(NodeGraph, self).__init__(parent)
-        self.setObjectName('NodeGraph')
-        self._model = (
-            kwargs.get('model') or NodeGraphModel())
-        self._node_factory = (
-            kwargs.get('node_factory') or NodeFactory())
-        self._undo_view = None
-        self._undo_stack = (
-            kwargs.get('undo_stack') or QtWidgets.QUndoStack(self)
-        )
-        self._widget = None
-        self._sub_graphs = {}
-        self._viewer = (
-            kwargs.get('viewer') or NodeViewer(undo_stack=self._undo_stack)
-        )
-
-        layout_direction = kwargs.get('layout_direction')
-        if layout_direction:
-            if layout_direction not in [e.value for e in LayoutDirectionEnum]:
-                layout_direction = LayoutDirectionEnum.HORIZONTAL.value
-            self._model.layout_direction = layout_direction
-        else:
-            layout_direction = self._model.layout_direction
-        self._viewer.set_layout_direction(layout_direction)
-
-        pipe_style = kwargs.get('pipe_style')
-        if pipe_style is not None:
-            if pipe_style not in [e.value for e in PipeLayoutEnum]:
-                pipe_style = PipeLayoutEnum.CURVED.value
-            self._model.pipe_style = pipe_style
-        else:
-            pipe_style = self._model.pipe_style
-        self._viewer.set_pipe_layout(pipe_style)
-
-        # viewer needs a reference to the model port connection constrains
-        # for the user interaction with the live pipe.
-        self._viewer.accept_connection_types = self._model.accept_connection_types
-        self._viewer.reject_connection_types = self._model.reject_connection_types
-
-        self._context_menu = {}
-
-        self._register_context_menu()
-        self._register_builtin_nodes()
-        self._wire_signals()
-
-    def __repr__(self):
-        return '<{}("root") object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def _register_context_menu(self):
-        """
-        Register the default context menus.
-        """
-        if not self._viewer:
-            return
-        menus = self._viewer.context_menus()
-        if menus.get('graph'):
-            self._context_menu['graph'] = NodeGraphMenu(self, menus['graph'])
-        if menus.get('nodes'):
-            self._context_menu['nodes'] = NodesMenu(self, menus['nodes'])
-
-    def _register_builtin_nodes(self):
-        """
-        Register the default builtin nodes to the :meth:`NodeGraph.node_factory`
-        """
-        self.register_node(BackdropNode, alias='Backdrop')
-
-    def _wire_signals(self):
-        """
-        Connect up all the signals and slots here.
-        """
-
-        # internal signals.
-        self._viewer.search_triggered.connect(self._on_search_triggered)
-        self._viewer.connection_sliced.connect(self._on_connection_sliced)
-        self._viewer.connection_changed.connect(self._on_connection_changed)
-        self._viewer.moved_nodes.connect(self._on_nodes_moved)
-        self._viewer.node_double_clicked.connect(self._on_node_double_clicked)
-        self._viewer.node_name_changed.connect(self._on_node_name_changed)
-        self._viewer.node_backdrop_updated.connect(
-            self._on_node_backdrop_updated)
-        self._viewer.insert_node.connect(self._on_insert_node)
-
-        # pass through translated signals.
-        self._viewer.node_selected.connect(self._on_node_selected)
-        self._viewer.node_selection_changed.connect(
-            self._on_node_selection_changed)
-        self._viewer.data_dropped.connect(self._on_node_data_dropped)
-
-    def _on_insert_node(self, pipe, node_id, prev_node_pos):
-        """
-        Slot function triggered when a selected node has collided with a pipe.
-
-        Args:
-            pipe (Pipe): collided pipe item.
-            node_id (str): selected node id to insert.
-            prev_node_pos (dict): previous node position. {NodeItem: [prev_x, prev_y]}
-        """
-        node = self.get_node_by_id(node_id)
-
-        # exclude if not a BaseNode
-        if not isinstance(node, BaseNode):
-            return
-
-        disconnected = [(pipe.input_port, pipe.output_port)]
-        connected = []
-
-        if node.input_ports():
-            connected.append(
-                (pipe.output_port, node.input_ports()[0].view)
-            )
-        if node.output_ports():
-            connected.append(
-                (node.output_ports()[0].view, pipe.input_port)
-            )
-
-        self._undo_stack.beginMacro('inserted node')
-        self._on_connection_changed(disconnected, connected)
-        self._on_nodes_moved(prev_node_pos)
-        self._undo_stack.endMacro()
-
-    def _on_property_bin_changed(self, node_id, prop_name, prop_value):
-        """
-        called when a property widget has changed in a properties bin.
-        (emits the node object, property name, property value)
-
-        Args:
-            node_id (str): node id.
-            prop_name (str): node property name.
-            prop_value (object): python built in types.
-        """
-        node = self.get_node_by_id(node_id)
-
-        # prevent signals from causing a infinite loop.
-        if node.get_property(prop_name) != prop_value:
-            node.set_property(prop_name, prop_value)
-
-    def _on_node_name_changed(self, node_id, name):
-        """
-        called when a node text qgraphics item in the viewer is edited.
-        (sets the name through the node object so undo commands are registered.)
-
-        Args:
-            node_id (str): node id emitted by the viewer.
-            name (str): new node name.
-        """
-        node = self.get_node_by_id(node_id)
-        node.set_name(name)
-
-        # TODO: not sure about redrawing the node here.
-        node.view.draw_node()
-
-    def _on_node_double_clicked(self, node_id):
-        """
-        called when a node in the viewer is double click.
-        (emits the node object when the node is clicked)
-
-        Args:
-            node_id (str): node id emitted by the viewer.
-        """
-        node = self.get_node_by_id(node_id)
-        self.node_double_clicked.emit(node)
-
-    def _on_node_selected(self, node_id):
-        """
-        called when a node in the viewer is selected on left click.
-        (emits the node object when the node is clicked)
-
-        Args:
-            node_id (str): node id emitted by the viewer.
-        """
-        node = self.get_node_by_id(node_id)
-        self.node_selected.emit(node)
-
-    def _on_node_selection_changed(self, sel_ids, desel_ids):
-        """
-        called when the node selection changes in the viewer.
-        (emits node objects <selected nodes>, <deselected nodes>)
-
-        Args:
-            sel_ids (list[str]): new selected node ids.
-            desel_ids (list[str]): deselected node ids.
-        """
-        sel_nodes = [self.get_node_by_id(nid) for nid in sel_ids]
-        unsel_nodes = [self.get_node_by_id(nid) for nid in desel_ids]
-        self.node_selection_changed.emit(sel_nodes, unsel_nodes)
-
-    def _on_node_data_dropped(self, data, pos):
-        """
-        called when data has been dropped on the viewer.
-
-        Example Identifiers:
-            URI = ngqt://path/to/node/session.graph
-            URN = ngqt::node:com.nodes.MyNode1;node:com.nodes.MyNode2
-
-        Args:
-            data (QtCore.QMimeData): mime data.
-            pos (QtCore.QPoint): scene position relative to the drop.
-        """
-        uri_regex = re.compile(r'{}(?:/*)([\w/]+)(\.\w+)'.format(URI_SCHEME))
-        urn_regex = re.compile(r'{}([\w\.:;]+)'.format(URN_SCHEME))
-        if data.hasFormat('text/uri-list'):
-            for url in data.urls():
-                local_file = url.toLocalFile()
-                if local_file:
-                    try:
-                        self.import_session(local_file)
-                        continue
-                    except Exception as e:
-                        pass
-
-                url_str = url.toString()
-                uri_search = uri_regex.search(url_str)
-                urn_search = urn_regex.search(url_str)
-                if uri_search:
-                    path = uri_search.group(1)
-                    ext = uri_search.group(2)
-                    self.import_session('{}{}'.format(path, ext))
-                elif urn_search:
-                    search_str = urn_search.group(1)
-                    node_ids = sorted(re.findall('node:([\w\\.]+)', search_str))
-                    x, y = pos.x(), pos.y()
-                    for node_id in node_ids:
-                        self.create_node(node_id, pos=[x, y])
-                        x += 80
-                        y += 80
-
-    def _on_nodes_moved(self, node_data):
-        """
-        called when selected nodes in the viewer has changed position.
-
-        Args:
-            node_data (dict): {<node_view>: <previous_pos>}
-        """
-        self._undo_stack.beginMacro('move nodes')
-        for node_view, prev_pos in node_data.items():
-            node = self._model.nodes[node_view.id]
-            self._undo_stack.push(NodeMovedCmd(node, node.pos(), prev_pos))
-        self._undo_stack.endMacro()
-
-    def _on_node_backdrop_updated(self, node_id, update_property, value):
-        """
-        called when a BackdropNode is updated.
-
-        Args:
-            node_id (str): backdrop node id.
-            value (str): update type.
-        """
-        backdrop = self.get_node_by_id(node_id)
-        if backdrop and isinstance(backdrop, BackdropNode):
-            backdrop.on_backdrop_updated(update_property, value)
-
-    def _on_search_triggered(self, node_type, pos):
-        """
-        called when the tab search widget is triggered in the viewer.
-
-        Args:
-            node_type (str): node identifier.
-            pos (tuple or list): x, y position for the node.
-        """
-        self.create_node(node_type, pos=pos)
-
-    def _on_connection_changed(self, disconnected, connected):
-        """
-        called when a pipe connection has been changed in the viewer.
-
-        Args:
-            disconnected (list[list[widgets.port.PortItem]):
-                pair list of port view items.
-            connected (list[list[widgets.port.PortItem]]):
-                pair list of port view items.
-        """
-        if not (disconnected or connected):
-            return
-
-        label = 'connect node(s)' if connected else 'disconnect node(s)'
-        ptypes = {PortTypeEnum.IN.value: 'inputs',
-                  PortTypeEnum.OUT.value: 'outputs'}
-
-        self._undo_stack.beginMacro(label)
-        for p1_view, p2_view in disconnected:
-            node1 = self._model.nodes[p1_view.node.id]
-            node2 = self._model.nodes[p2_view.node.id]
-            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]
-            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]
-            port1.disconnect_from(port2)
-        for p1_view, p2_view in connected:
-            node1 = self._model.nodes[p1_view.node.id]
-            node2 = self._model.nodes[p2_view.node.id]
-            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]
-            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]
-            port1.connect_to(port2)
-        self._undo_stack.endMacro()
-
-    def _on_connection_sliced(self, ports):
-        """
-        slot when connection pipes have been sliced.
-
-        Args:
-            ports (list[list[widgets.port.PortItem]]):
-                pair list of port connections (in port, out port)
-        """
-        if not ports:
-            return
-        ptypes = {PortTypeEnum.IN.value: 'inputs',
-                  PortTypeEnum.OUT.value: 'outputs'}
-        self._undo_stack.beginMacro('slice connections')
-        for p1_view, p2_view in ports:
-            node1 = self._model.nodes[p1_view.node.id]
-            node2 = self._model.nodes[p2_view.node.id]
-            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]
-            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]
-            port1.disconnect_from(port2)
-        self._undo_stack.endMacro()
-
-    @property
-    def model(self):
-        """
-        The model used for storing the node graph data.
-
-        Returns:
-            NodeGraphQt.base.model.NodeGraphModel: node graph model.
-        """
-        return self._model
-
-    @property
-    def node_factory(self):
-        """
-        Return the node factory object used by the node graph.
-
-        Returns:
-            NodeFactory: node factory.
-        """
-        return self._node_factory
-
-    @property
-    def widget(self):
-        """
-        The node graph widget for adding into a layout.
-
-        Returns:
-            NodeGraphWidget: node graph widget.
-        """
-        if self._widget is None:
-            self._widget = NodeGraphWidget()
-            self._widget.addTab(self._viewer, 'Node Graph')
-            # hide the close button on the first tab.
-            tab_bar = self._widget.tabBar()
-            for btn_flag in [tab_bar.RightSide, tab_bar.LeftSide]:
-                tab_btn = tab_bar.tabButton(0, btn_flag)
-                if tab_btn:
-                    tab_btn.deleteLater()
-                    tab_bar.setTabButton(0, btn_flag, None)
-            self._widget.tabCloseRequested.connect(
-                self._on_close_sub_graph_tab
-            )
-        return self._widget
-
-    @property
-    def undo_view(self):
-        """
-        Returns node graph undo history list widget.
-
-        Returns:
-            PySide2.QtWidgets.QUndoView: node graph undo view.
-        """
-        if self._undo_view is None:
-            self._undo_view = QtWidgets.QUndoView(self._undo_stack)
-            self._undo_view.setWindowTitle('Undo History')
-        return self._undo_view
-
-    def toggle_node_search(self):
-        """
-        toggle the node search widget visibility.
-        """
-        if self._viewer.underMouse():
-            self._viewer.tab_search_set_nodes(self._node_factory.names)
-            self._viewer.tab_search_toggle()
-
-    def show(self):
-        """
-        Show node graph widget this is just a convenience
-        function to :meth:`NodeGraph.widget.show()`.
-        """
-        self.widget.show()
-
-    def close(self):
-        """
-        Close node graph NodeViewer widget this is just a convenience
-        function to :meth:`NodeGraph.widget.close()`.
-        """
-        self.widget.close()
-
-    def viewer(self):
-        """
-        Returns the internal view interface used by the node graph.
-
-        Warnings:
-            Methods in the ``NodeViewer`` are used internally
-            by ``NodeGraphQt`` components to get the widget use
-            :attr:`NodeGraph.widget`.
-
-        See Also:
-            :attr:`NodeGraph.widget` to add the node graph widget into a
-            :class:`PySide2.QtWidgets.QLayout`.
-
-        Returns:
-            NodeGraphQt.widgets.viewer.NodeViewer: viewer interface.
-        """
-        return self._viewer
-
-    def scene(self):
-        """
-        Returns the ``QGraphicsScene`` object used in the node graph.
-
-        Returns:
-            NodeGraphQt.widgets.scene.NodeScene: node scene.
-        """
-        return self._viewer.scene()
-
-    def background_color(self):
-        """
-        Return the node graph background color.
-
-        Returns:
-            tuple: r, g ,b
-        """
-        return self.scene().background_color
-
-    def set_background_color(self, r, g, b):
-        """
-        Set node graph background color.
-
-        Args:
-            r (int): red value.
-            g (int): green value.
-            b (int): blue value.
-        """
-        self.scene().background_color = (r, g, b)
-        self._viewer.force_update()
-
-    def grid_color(self):
-        """
-        Return the node graph grid color.
-
-        Returns:
-            tuple: r, g ,b
-        """
-        return self.scene().grid_color
-
-    def set_grid_color(self, r, g, b):
-        """
-        Set node graph grid color.
-
-        Args:
-            r (int): red value.
-            g (int): green value.
-            b (int): blue value.
-        """
-        self.scene().grid_color = (r, g, b)
-        self._viewer.force_update()
-
-    def set_grid_mode(self, mode=None):
-        """
-        Set node graph background grid mode.
-
-        (default: :attr:`NodeGraphQt.constants.ViewerEnum.GRID_DISPLAY_LINES`).
-
-        See: :attr:`NodeGraphQt.constants.ViewerEnum`
-
-        .. code-block:: python
-            :linenos:
-
-            graph = NodeGraph()
-            graph.set_grid_mode(ViewerEnum.CURVED.value)
-
-        Args:
-            mode (int): background style.
-        """
-        display_types = [
-            ViewerEnum.GRID_DISPLAY_NONE.value,
-            ViewerEnum.GRID_DISPLAY_DOTS.value,
-            ViewerEnum.GRID_DISPLAY_LINES.value
-        ]
-        if mode not in display_types:
-            mode = ViewerEnum.GRID_DISPLAY_LINES.value
-        self.scene().grid_mode = mode
-        self._viewer.force_update()
-
-    def add_properties_bin(self, prop_bin):
-        """
-        Wire up a properties bin widget to the node graph.
-
-        Args:
-            prop_bin (NodeGraphQt.PropertiesBinWidget): properties widget.
-        """
-        prop_bin.property_changed.connect(self._on_property_bin_changed)
-
-    def undo_stack(self):
-        """
-        Returns the undo stack used in the node graph.
-
-        See Also:
-            :meth:`NodeGraph.begin_undo()`,
-            :meth:`NodeGraph.end_undo()`
-
-        Returns:
-            QtWidgets.QUndoStack: undo stack.
-        """
-        return self._undo_stack
-
-    def clear_undo_stack(self):
-        """
-        Clears the undo stack.
-
-        Note:
-            Convenience function to
-            :meth:`NodeGraph.undo_stack().clear()`
-
-        See Also:
-            :meth:`NodeGraph.begin_undo()`,
-            :meth:`NodeGraph.end_undo()`,
-            :meth:`NodeGraph.undo_stack()`
-        """
-        self._undo_stack.clear()
-
-    def begin_undo(self, name):
-        """
-        Start of an undo block followed by a
-        :meth:`NodeGraph.end_undo()`.
-
-        Args:
-            name (str): name for the undo block.
-        """
-        self._undo_stack.beginMacro(name)
-
-    def end_undo(self):
-        """
-        End of an undo block started by
-        :meth:`NodeGraph.begin_undo()`.
-        """
-        self._undo_stack.endMacro()
-
-    def context_menu(self):
-        """
-        Returns the context menu for the node graph.
-
-        Note:
-            This is a convenience function to
-            :meth:`NodeGraph.get_context_menu`
-            with the arg ``menu="graph"``
-
-        Returns:
-            NodeGraphQt.NodeGraphMenu: context menu object.
-        """
-        return self.get_context_menu('graph')
-
-    def context_nodes_menu(self):
-        """
-        Returns the context menu for the nodes.
-
-        Note:
-            This is a convenience function to
-            :meth:`NodeGraph.get_context_menu`
-            with the arg ``menu="nodes"``
-
-        Returns:
-            NodeGraphQt.NodesMenu: context menu object.
-        """
-        return self.get_context_menu('nodes')
-
-    def get_context_menu(self, menu):
-        """
-        Returns the context menu specified by the name.
-
-        menu types:
-
-            - ``"graph"`` context menu from the node graph.
-            - ``"nodes"`` context menu for the nodes.
-
-        Args:
-            menu (str): menu name.
-
-        Returns:
-            NodeGraphQt.NodeGraphMenu or NodeGraphQt.NodesMenu: context menu object.
-        """
-        return self._context_menu.get(menu)
-
-    def _deserialize_context_menu(self, menu, menu_data):
-        """
-        Populate context menu from a dictionary.
-
-        Args:
-            menu (NodeGraphQt.NodeGraphMenu or NodeGraphQt.NodesMenu):
-                parent context menu.
-            menu_data (list[dict] or dict): serialized menu data.
-        """
-        if not menu:
-            raise ValueError('No context menu named: "{}"'.format(menu))
-
-        import sys
-        import importlib.util
-
-        nodes_menu = self.get_context_menu('nodes')
-
-        def build_menu_command(menu, data):
-            """
-            Create menu command from serialized data.
-
-            Args:
-                menu (NodeGraphQt.NodeGraphMenu or NodeGraphQt.NodesMenu):
-                    menu object.
-                data (dict): serialized menu command data.
-            """
-            full_path = os.path.abspath(data['file'])
-            base_dir, file_name = os.path.split(full_path)
-            base_name = os.path.basename(base_dir)
-            file_name, _ = file_name.split('.')
-
-            mod_name = '{}.{}'.format(base_name, file_name)
-
-            spec = importlib.util.spec_from_file_location(mod_name, full_path)
-            mod = importlib.util.module_from_spec(spec)
-            sys.modules[mod_name] = mod
-            spec.loader.exec_module(mod)
-
-            cmd_func = getattr(mod, data['function_name'])
-            cmd_name = data.get('label') or '<command>'
-            cmd_shortcut = data.get('shortcut')
-            cmd_kwargs = {'func': cmd_func, 'shortcut': cmd_shortcut}
-
-            if menu == nodes_menu and data.get('node_type'):
-                cmd_kwargs['node_type'] = data['node_type']
-
-            menu.add_command(name=cmd_name, **cmd_kwargs)
-
-        if isinstance(menu_data, dict):
-            item_type = menu_data.get('type')
-            if item_type == 'separator':
-                menu.add_separator()
-            elif item_type == 'command':
-                build_menu_command(menu, menu_data)
-            elif item_type == 'menu':
-                sub_menu = menu.add_menu(menu_data['label'])
-                items = menu_data.get('items', [])
-                self._deserialize_context_menu(sub_menu, items)
-        elif isinstance(menu_data, list):
-            for item_data in menu_data:
-                self._deserialize_context_menu(menu, item_data)
-
-    def set_context_menu(self, menu_name, data):
-        """
-        Populate a context menu from serialized data.
-
-        example of serialized menu data:
-
-        .. highlight:: python
-        .. code-block:: python
-
-            [
-                {
-                    'type': 'menu',
-                    'label': 'test sub menu',
-                    'items': [
-                        {
-                            'type': 'command',
-                            'label': 'test command',
-                            'file': '../path/to/my/test_module.py',
-                            'function': 'run_test',
-                            'shortcut': 'Ctrl+b',
-                            'node_type': 'nodeGraphQt.nodes.MyNodeClass'
-                        },
-
-                    ]
-                },
-            ]
-
-        the ``run_test`` example function:
-
-        .. highlight:: python
-        .. code-block:: python
-
-            def run_test(graph):
-                print(graph.selected_nodes())
-
-
-        Args:
-            menu_name (str): name of the parent context menu to populate under.
-            data (dict): serialized menu data.
-        """
-        context_menu = self.get_context_menu(menu_name)
-        self._deserialize_context_menu(context_menu, data)
-
-    def set_context_menu_from_file(self, file_path, menu=None):
-        """
-        Populate a context menu from a serialized json file.
-
-        menu types:
-
-            - ``"graph"`` context menu from the node graph.
-            - ``"nodes"`` context menu for the nodes.
-
-        Args:
-            menu (str): name of the parent context menu to populate under.
-            file_path (str): serialized menu commands json file.
-        """
-        file_path = os.path.abspath(file_path)
-
-        menu = menu or 'graph'
-        if not os.path.isfile(file_path):
-            raise IOError('file doesn\'t exists: "{}"'.format(file_path))
-
-        with open(file_path) as f:
-            data = json.load(f)
-        context_menu = self.get_context_menu(menu)
-        self._deserialize_context_menu(context_menu, data)
-
-    def disable_context_menu(self, disabled=True, name='all'):
-        """
-        Disable/Enable context menus from the node graph.
-
-        menu types:
-
-            - ``"all"`` all context menus from the node graph.
-            - ``"graph"`` context menu from the node graph.
-            - ``"nodes"`` context menu for the nodes.
-
-        Args:
-            disabled (bool): true to enable context menu.
-            name (str): menu name. (default: ``"all"``)
-        """
-        if name == 'all':
-            for k, menu in self._viewer.context_menus().items():
-                menu.setDisabled(disabled)
-                menu.setVisible(not disabled)
-            return
-        menus = self._viewer.context_menus()
-        if menus.get(name):
-            menus[name].setDisabled(disabled)
-            menus[name].setVisible(not disabled)
-
-    def acyclic(self):
-        """
-        Returns true if the current node graph is acyclic.
-
-        See Also:
-            :meth:`NodeGraph.set_acyclic`
-
-        Returns:
-            bool: true if acyclic (default: ``True``).
-        """
-        return self._model.acyclic
-
-    def set_acyclic(self, mode=True):
-        """
-        Enable the node graph to be a acyclic graph. (default: ``True``)
-
-        See Also:
-            :meth:`NodeGraph.acyclic`
-
-        Args:
-            mode (bool): true to enable acyclic.
-        """
-        self._model.acyclic = mode
-        self._viewer.acyclic = self._model.acyclic
-
-    def pipe_collision(self):
-        """
-        Returns if pipe collision is enabled.
-
-        See Also:
-            To enable/disable pipe collision
-            :meth:`NodeGraph.set_pipe_collision`
-
-        Returns:
-            bool: True if pipe collision is enabled.
-        """
-        return self._model.pipe_collision
-
-    def set_pipe_collision(self, mode=True):
-        """
-        Enable/Disable pipe collision.
-
-        When enabled dragging a node over a pipe will allow the node to be
-        inserted as a new connection between the pipe.
-
-        See Also:
-            :meth:`NodeGraph.pipe_collision`
-
-        Args:
-            mode (bool): False to disable pipe collision.
-        """
-        self._model.pipe_collision = mode
-        self._viewer.pipe_collision = self._model.pipe_collision
-
-    def pipe_slicing(self):
-        """
-        Returns if pipe slicing is enabled.
-
-        See Also:
-            To enable/disable pipe slicer
-            :meth:`NodeGraph.set_pipe_slicing`
-
-        Returns:
-            bool: True if pipe slicing is enabled.
-        """
-        return self._model.pipe_slicing
-
-    def set_pipe_slicing(self, mode=True):
-        """
-        Enable/Disable pipe slicer.
-
-        When set to true holding down ``Alt + Shift + LMB Drag`` will allow node
-        pipe connections to be sliced.
-
-        .. image:: _images/slicer.png
-            :width: 400px
-
-        See Also:
-            :meth:`NodeGraph.pipe_slicing`
-
-        Args:
-            mode (bool): False to disable the slicer pipe.
-        """
-        self._model.pipe_slicing = mode
-        self._viewer.pipe_slicing = self._model.pipe_slicing
-
-    def pipe_style(self):
-        """
-        Returns the current pipe layout style.
-
-        See Also:
-            :meth:`NodeGraph.set_pipe_style`
-
-        Returns:
-            int: pipe style value. :attr:`NodeGraphQt.constants.PipeLayoutEnum`
-        """
-        return self._model.pipe_style
-
-    def set_pipe_style(self, style=PipeLayoutEnum.CURVED.value):
-        """
-        Set node graph pipes to be drawn as curved `(default)`, straight or angled.
-
-        .. code-block:: python
-            :linenos:
-
-            graph = NodeGraph()
-            graph.set_pipe_style(PipeLayoutEnum.CURVED.value)
-
-        See: :attr:`NodeGraphQt.constants.PipeLayoutEnum`
-
-        .. image:: _images/pipe_layout_types.gif
-            :width: 80%
-
-
-        Args:
-            style (int): pipe layout style.
-        """
-        pipe_max = max([PipeLayoutEnum.CURVED.value,
-                        PipeLayoutEnum.STRAIGHT.value,
-                        PipeLayoutEnum.ANGLE.value])
-        style = style if 0 <= style <= pipe_max else PipeLayoutEnum.CURVED.value
-        self._model.pipe_style = style
-        self._viewer.set_pipe_layout(style)
-
-    def layout_direction(self):
-        """
-        Return the current node graph layout direction.
-
-        `Implemented in` ``v0.3.0``
-
-        See Also:
-            :meth:`NodeGraph.set_layout_direction`
-
-        Returns:
-            int: layout direction.
-        """
-        return self._model.layout_direction
-
-    def set_layout_direction(self, direction):
-        """
-        Sets the node graph layout direction to horizontal or vertical.
-        This function will also override the layout direction on all
-        nodes in the current node graph.
-
-        `Implemented in` ``v0.3.0``
-
-        **Layout Types:**
-
-        - :attr:`NodeGraphQt.constants.LayoutDirectionEnum.HORIZONTAL`
-        - :attr:`NodeGraphQt.constants.LayoutDirectionEnum.VERTICAL`
-
-        .. image:: _images/layout_direction_switch.gif
-            :width: 300px
-
-        Warnings:
-            This function does not register to the undo stack.
-
-        See Also:
-            :meth:`NodeGraph.layout_direction`,
-            :meth:`NodeObject.set_layout_direction`
-
-        Args:
-            direction (int): layout direction.
-        """
-        direction_types = [e.value for e in LayoutDirectionEnum]
-        if direction not in direction_types:
-            direction = LayoutDirectionEnum.HORIZONTAL.value
-        self._model.layout_direction = direction
-        for node in self.all_nodes():
-            node.set_layout_direction(direction)
-        self._viewer.set_layout_direction(direction)
-
-    def fit_to_selection(self):
-        """
-        Sets the zoom level to fit selected nodes.
-        If no nodes are selected then all nodes in the graph will be framed.
-        """
-        nodes = self.selected_nodes() or self.all_nodes()
-        if not nodes:
-            return
-        self._viewer.zoom_to_nodes([n.view for n in nodes])
-
-    def reset_zoom(self):
-        """
-        Reset the zoom level
-        """
-        self._viewer.reset_zoom()
-
-    def set_zoom(self, zoom=0):
-        """
-        Set the zoom factor of the Node Graph the default is ``0.0``
-
-        Args:
-            zoom (float): zoom factor (max zoom out ``-0.9`` / max zoom in ``2.0``)
-        """
-        self._viewer.set_zoom(zoom)
-
-    def get_zoom(self):
-        """
-        Get the current zoom level of the node graph.
-
-        Returns:
-            float: the current zoom level.
-        """
-        return self._viewer.get_zoom()
-
-    def center_on(self, nodes=None):
-        """
-        Center the node graph on the given nodes or all nodes by default.
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]): a list of nodes.
-        """
-        nodes = nodes or []
-        self._viewer.center_selection([n.view for n in nodes])
-
-    def center_selection(self):
-        """
-        Centers on the current selected nodes.
-        """
-        nodes = self._viewer.selected_nodes()
-        self._viewer.center_selection(nodes)
-
-    def registered_nodes(self):
-        """
-        Return a list of all node types that have been registered.
-
-        See Also:
-            To register a node :meth:`NodeGraph.register_node`
-
-        Returns:
-            list[str]: list of node type identifiers.
-        """
-        return sorted(self._node_factory.nodes.keys())
-
-    def register_node(self, node, alias=None):
-        """
-        Register the node to the :meth:`NodeGraph.node_factory`
-
-        Args:
-            node (NodeGraphQt.NodeObject): node object.
-            alias (str): custom alias name for the node type.
-        """
-        self._node_factory.register_node(node, alias)
-        self._viewer.rebuild_tab_search()
-        self.nodes_registered.emit([node])
-
-    def register_nodes(self, nodes):
-        """
-        Register the nodes to the :meth:`NodeGraph.node_factory`
-
-        Args:
-            nodes (list): list of nodes.
-        """
-        [self._node_factory.register_node(n) for n in nodes]
-        self._viewer.rebuild_tab_search()
-        self.nodes_registered.emit(nodes)
-
-    def create_node(self, node_type, name=None, selected=True, color=None,
-                    text_color=None, pos=None, push_undo=True):
-        """
-        Create a new node in the node graph.
-
-        See Also:
-            To list all node types :meth:`NodeGraph.registered_nodes`
-
-        Args:
-            node_type (str): node instance type.
-            name (str): set name of the node.
-            selected (bool): set created node to be selected.
-            color (tuple or str): node color ``(255, 255, 255)`` or ``"#FFFFFF"``.
-            text_color (tuple or str): text color ``(255, 255, 255)`` or ``"#FFFFFF"``.
-            pos (list[int, int]): initial x, y position for the node (default: ``(0, 0)``).
-            push_undo (bool): register the command to the undo stack. (default: True)
-
-        Returns:
-            BaseNode: the created instance of the node.
-        """
-        node = self._node_factory.create_node_instance(node_type)
-        if node:
-            node._graph = self
-            node.model._graph_model = self.model
-
-            wid_types = node.model.__dict__.pop('_TEMP_property_widget_types')
-            prop_attrs = node.model.__dict__.pop('_TEMP_property_attrs')
-
-            if self.model.get_node_common_properties(node.type_) is None:
-                node_attrs = {node.type_: {
-                    n: {'widget_type': wt} for n, wt in wid_types.items()
-                }}
-                for pname, pattrs in prop_attrs.items():
-                    node_attrs[node.type_][pname].update(pattrs)
-                self.model.set_node_common_properties(node_attrs)
-
-            accept_types = node.model.__dict__.pop(
-                '_TEMP_accept_connection_types'
-            )
-            for ptype, pdata in accept_types.get(node.type_, {}).items():
-                for pname, accept_data in pdata.items():
-                    for accept_ntype, accept_ndata in accept_data.items():
-                        for accept_ptype, accept_pnames in accept_ndata.items():
-                            for accept_pname in accept_pnames:
-                                self._model.add_port_accept_connection_type(
-                                    port_name=pname,
-                                    port_type=ptype,
-                                    node_type=node.type_,
-                                    accept_pname=accept_pname,
-                                    accept_ptype=accept_ptype,
-                                    accept_ntype=accept_ntype
-                                )
-            reject_types = node.model.__dict__.pop(
-                '_TEMP_reject_connection_types'
-            )
-            for ptype, pdata in reject_types.get(node.type_, {}).items():
-                for pname, reject_data in pdata.items():
-                    for reject_ntype, reject_ndata in reject_data.items():
-                        for reject_ptype, reject_pnames in reject_ndata.items():
-                            for reject_pname in reject_pnames:
-                                self._model.add_port_reject_connection_type(
-                                    port_name=pname,
-                                    port_type=ptype,
-                                    node_type=node.type_,
-                                    reject_pname=reject_pname,
-                                    reject_ptype=reject_ptype,
-                                    reject_ntype=reject_ntype
-                                )
-
-            node.NODE_NAME = self.get_unique_name(name or node.NODE_NAME)
-            node.model.name = node.NODE_NAME
-            node.model.selected = selected
-
-            def format_color(clr):
-                if isinstance(clr, str):
-                    clr = clr.strip('#')
-                    return tuple(int(clr[i:i + 2], 16) for i in (0, 2, 4))
-                return clr
-
-            if color:
-                node.model.color = format_color(color)
-            if text_color:
-                node.model.text_color = format_color(text_color)
-            if pos:
-                node.model.pos = [float(pos[0]), float(pos[1])]
-
-            # initial node direction layout.
-            node.model.layout_direction = self.layout_direction()
-
-            node.update()
-
-            undo_cmd = NodeAddedCmd(self, node, node.model.pos)
-            if push_undo:
-                undo_label = 'create node: "{}"'.format(node.NODE_NAME)
-                self._undo_stack.beginMacro(undo_label)
-                for n in self.selected_nodes():
-                    n.set_property('selected', False, push_undo=True)
-                self._undo_stack.push(undo_cmd)
-                self._undo_stack.endMacro()
-            else:
-                for n in self.selected_nodes():
-                    n.set_property('selected', False, push_undo=False)
-                NodeAddedCmd(self, node, node.model.pos).redo()
-
-            self.node_created.emit(node)
-            return node
-        raise NodeCreationError('Can\'t find node: "{}"'.format(node_type))
-
-    def add_node(self, node, pos=None, selected=True, push_undo=True):
-        """
-        Add a node into the node graph.
-        unlike the :meth:`NodeGraph.create_node` function this will not
-        trigger the :attr:`NodeGraph.node_created` signal.
-
-        Args:
-            node (NodeGraphQt.BaseNode): node object.
-            pos (list[float]): node x,y position. (optional)
-            selected (bool): node selected state. (optional)
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        assert isinstance(node, NodeObject), 'node must be a Node instance.'
-
-        wid_types = node.model.__dict__.pop('_TEMP_property_widget_types')
-        prop_attrs = node.model.__dict__.pop('_TEMP_property_attrs')
-
-        if self.model.get_node_common_properties(node.type_) is None:
-            node_attrs = {node.type_: {
-                n: {'widget_type': wt} for n, wt in wid_types.items()
-            }}
-            for pname, pattrs in prop_attrs.items():
-                node_attrs[node.type_][pname].update(pattrs)
-            self.model.set_node_common_properties(node_attrs)
-
-        accept_types = node.model.__dict__.pop(
-            '_TEMP_accept_connection_types'
-        )
-        for ptype, pdata in accept_types.get(node.type_, {}).items():
-            for pname, accept_data in pdata.items():
-                for accept_ntype, accept_ndata in accept_data.items():
-                    for accept_ptype, accept_pnames in accept_ndata.items():
-                        for accept_pname in accept_pnames:
-                            self._model.add_port_accept_connection_type(
-                                port_name=pname,
-                                port_type=ptype,
-                                node_type=node.type_,
-                                accept_pname=accept_pname,
-                                accept_ptype=accept_ptype,
-                                accept_ntype=accept_ntype
-                            )
-        reject_types = node.model.__dict__.pop(
-            '_TEMP_reject_connection_types'
-        )
-        for ptype, pdata in reject_types.get(node.type_, {}).items():
-            for pname, reject_data in pdata.items():
-                for reject_ntype, reject_ndata in reject_data.items():
-                    for reject_ptype, reject_pnames in reject_ndata.items():
-                        for reject_pname in reject_pnames:
-                            self._model.add_port_reject_connection_type(
-                                port_name=pname,
-                                port_type=ptype,
-                                node_type=node.type_,
-                                reject_pname=reject_pname,
-                                reject_ptype=reject_ptype,
-                                reject_ntype=reject_ntype
-                            )
-
-        node._graph = self
-        node.NODE_NAME = self.get_unique_name(node.NODE_NAME)
-        node.model._graph_model = self.model
-        node.model.name = node.NODE_NAME
-
-        # initial node direction layout.
-        node.model.layout_direction = self.layout_direction()
-
-        # update method must be called before it's been added to the viewer.
-        node.update()
-
-        if push_undo:
-            self._undo_stack.beginMacro('add node: "{}"'.format(node.name()))
-            self._undo_stack.push(NodeAddedCmd(self, node, pos))
-            if selected:
-                node.set_selected(True)
-            self._undo_stack.endMacro()
-        else:
-            NodeAddedCmd(self, node, pos).redo()
-
-    def delete_node(self, node, push_undo=True):
-        """
-        Remove the node from the node graph.
-
-        Args:
-            node (NodeGraphQt.BaseNode): node object.
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        assert isinstance(node, NodeObject), \
-            'node must be a instance of a NodeObject.'
-        node_id = node.id
-        if push_undo:
-            self._undo_stack.beginMacro('delete node: "{}"'.format(node.name()))
-
-        if isinstance(node, BaseNode):
-            for p in node.input_ports():
-                if p.locked():
-                    p.set_locked(False,
-                                 connected_ports=False,
-                                 push_undo=push_undo)
-                p.clear_connections(push_undo=push_undo)
-            for p in node.output_ports():
-                if p.locked():
-                    p.set_locked(False,
-                                 connected_ports=False,
-                                 push_undo=push_undo)
-                p.clear_connections(push_undo=push_undo)
-
-        # collapse group node before removing.
-        if isinstance(node, GroupNode) and node.is_expanded:
-            node.collapse()
-
-        if push_undo:
-            self._undo_stack.push(NodeRemovedCmd(self, node))
-            self._undo_stack.endMacro()
-        else:
-            NodeRemovedCmd(self, node).redo()
-
-        self.nodes_deleted.emit([node_id])
-
-    def remove_node(self, node, push_undo=True):
-        """
-        Remove the node from the node graph.
-
-        unlike the :meth:`NodeGraph.delete_node` function this will not
-        trigger the :attr:`NodeGraph.nodes_deleted` signal.
-
-        Args:
-            node (NodeGraphQt.BaseNode): node object.
-            push_undo (bool): register the command to the undo stack. (default: True)
-
-        """
-        assert isinstance(node, NodeObject), 'node must be a Node instance.'
-
-        if push_undo:
-            self._undo_stack.beginMacro('delete node: "{}"'.format(node.name()))
-
-        # collapse group node before removing.
-        if isinstance(node, GroupNode) and node.is_expanded:
-            node.collapse()
-
-        if isinstance(node, BaseNode):
-            for p in node.input_ports():
-                if p.locked():
-                    p.set_locked(False,
-                                 connected_ports=False,
-                                 push_undo=push_undo)
-                p.clear_connections(push_undo=push_undo)
-            for p in node.output_ports():
-                if p.locked():
-                    p.set_locked(False,
-                                 connected_ports=False,
-                                 push_undo=push_undo)
-                p.clear_connections(push_undo=push_undo)
-
-        if push_undo:
-            self._undo_stack.push(NodeRemovedCmd(self, node))
-            self._undo_stack.endMacro()
-        else:
-            NodeRemovedCmd(self, node).redo()
-
-    def delete_nodes(self, nodes, push_undo=True):
-        """
-        Remove a list of specified nodes from the node graph.
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]): list of node instances.
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        if not nodes:
-            return
-        if len(nodes) == 1:
-            self.delete_node(nodes[0], push_undo=push_undo)
-            return
-        node_ids = [n.id for n in nodes]
-        if push_undo:
-            self._undo_stack.beginMacro(
-                'deleted "{}" node(s)'.format(len(nodes))
-            )
-        for node in nodes:
-
-            # collapse group node before removing.
-            if isinstance(node, GroupNode) and node.is_expanded:
-                node.collapse()
-
-            if isinstance(node, BaseNode):
-                for p in node.input_ports():
-                    if p.locked():
-                        p.set_locked(False,
-                                     connected_ports=False,
-                                     push_undo=push_undo)
-                    p.clear_connections(push_undo=push_undo)
-                for p in node.output_ports():
-                    if p.locked():
-                        p.set_locked(False,
-                                     connected_ports=False,
-                                     push_undo=push_undo)
-                    p.clear_connections(push_undo=push_undo)
-            if push_undo:
-                self._undo_stack.push(NodeRemovedCmd(self, node))
-            else:
-                NodeRemovedCmd(self, node).redo()
-        if push_undo:
-            self._undo_stack.endMacro()
-        self.nodes_deleted.emit(node_ids)
-
-    def extract_nodes(self, nodes, push_undo=True, prompt_warning=True):
-        """
-        Extract select nodes from it connections.
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]): list of node instances.
-            push_undo (bool): register the command to the undo stack. (default: True)
-            prompt_warning (bool): prompt warning dialog box.
-        """
-        if not nodes:
-            return
-
-        locked_ports = []
-        base_nodes = []
-        for node in nodes:
-            if not isinstance(node, BaseNode):
-                continue
-
-            for port in node.input_ports() + node.output_ports():
-                if port.locked():
-                    locked_ports.append('{0.node.name}: {0.name}'.format(port))
-
-            base_nodes.append(node)
-
-        if locked_ports:
-            message = (
-                'Selected nodes cannot be extracted because the following '
-                'ports are locked:\n{}'.format('\n'.join(sorted(locked_ports)))
-            )
-            if prompt_warning:
-                self._viewer.message_dialog(message, 'Can\'t Extract Nodes')
-            return
-
-        if push_undo:
-            self._undo_stack.beginMacro(
-                'extracted "{}" node(s)'.format(len(nodes))
-            )
-
-        for node in base_nodes:
-            for port in node.input_ports() + node.output_ports():
-                for connected_port in port.connected_ports():
-                    if connected_port.node() in base_nodes:
-                        continue
-                    port.disconnect_from(connected_port, push_undo=push_undo)
-
-        if push_undo:
-            self._undo_stack.endMacro()
-
-    def all_nodes(self):
-        """
-        Return all nodes in the node graph.
-
-        Returns:
-            list[NodeGraphQt.BaseNode]: list of nodes.
-        """
-        return list(self._model.nodes.values())
-
-    def selected_nodes(self):
-        """
-        Return all selected nodes that are in the node graph.
-
-        Returns:
-            list[NodeGraphQt.BaseNode]: list of nodes.
-        """
-        nodes = []
-        for item in self._viewer.selected_nodes():
-            node = self._model.nodes[item.id]
-            nodes.append(node)
-        return nodes
-
-    def select_all(self):
-        """
-        Select all nodes in the node graph.
-        """
-        self._undo_stack.beginMacro('select all')
-        [node.set_selected(True) for node in self.all_nodes()]
-        self._undo_stack.endMacro()
-
-    def clear_selection(self):
-        """
-        Clears the selection in the node graph.
-        """
-        self._undo_stack.beginMacro('clear selection')
-        [node.set_selected(False) for node in self.all_nodes()]
-        self._undo_stack.endMacro()
-
-    def get_node_by_id(self, node_id=None):
-        """
-        Returns the node from the node id string.
-
-        Args:
-            node_id (str): node id (:attr:`NodeObject.id`)
-
-        Returns:
-            NodeGraphQt.NodeObject: node object.
-        """
-        return self._model.nodes.get(node_id, None)
-
-    def get_node_by_name(self, name):
-        """
-        Returns node that matches the name.
-
-        Args:
-            name (str): name of the node.
-        Returns:
-            NodeGraphQt.NodeObject: node object.
-        """
-        for node_id, node in self._model.nodes.items():
-            if node.name() == name:
-                return node
-
-    def get_nodes_by_type(self, node_type):
-        """
-        Return all nodes by their node type identifier.
-        (see: :attr:`NodeGraphQt.NodeObject.type_`)
-
-        Args:
-            node_type (str): node type identifier.
-
-        Returns:
-            list[NodeGraphQt.NodeObject]: list of nodes.
-        """
-        return [n for n in self._model.nodes.values() if n.type_ == node_type]
-
-    def get_unique_name(self, name):
-        """
-        Creates a unique node name to avoid having nodes with the same name.
-
-        Args:
-            name (str): node name.
-
-        Returns:
-            str: unique node name.
-        """
-        name = ' '.join(name.split())
-        node_names = [n.name() for n in self.all_nodes()]
-        if name not in node_names:
-            return name
-
-        regex = re.compile(r'\w+ (\d+)$')
-        search = regex.search(name)
-        if not search:
-            for x in range(1, len(node_names) + 2):
-                new_name = '{} {}'.format(name, x)
-                if new_name not in node_names:
-                    return new_name
-
-        version = search.group(1)
-        name = name[:len(version) * -1].strip()
-        for x in range(1, len(node_names) + 2):
-            new_name = '{} {}'.format(name, x)
-            if new_name not in node_names:
-                return new_name
-
-    def current_session(self):
-        """
-        Returns the file path to the currently loaded session.
-
-        Returns:
-            str: path to the currently loaded session
-        """
-        return self._model.session
-
-    def clear_session(self):
-        """
-        Clears the current node graph session.
-        """
-        for n in self.all_nodes():
-            if isinstance(n, BaseNode):
-                for p in n.input_ports():
-                    if p.locked():
-                        p.set_locked(False, connected_ports=False)
-                    p.clear_connections()
-                for p in n.output_ports():
-                    if p.locked():
-                        p.set_locked(False, connected_ports=False)
-                    p.clear_connections()
-            self._undo_stack.push(NodeRemovedCmd(self, n))
-        self._undo_stack.clear()
-        self._model.session = ''
-
-    def _serialize(self, nodes):
-        """
-        serialize nodes to a dict.
-        (used internally by the node graph)
-
-        Args:
-            nodes (list[NodeGraphQt.Nodes]): list of node instances.
-
-        Returns:
-            dict: serialized data.
-        """
-        serial_data = {'graph': {}, 'nodes': {}, 'connections': []}
-        nodes_data = {}
-
-        # serialize graph session.
-        serial_data['graph']['layout_direction'] = self.layout_direction()
-        serial_data['graph']['acyclic'] = self.acyclic()
-        serial_data['graph']['pipe_collision'] = self.pipe_collision()
-        serial_data['graph']['pipe_slicing'] = self.pipe_slicing()
-        serial_data['graph']['pipe_style'] = self.pipe_style()
-
-        # connection constrains.
-        serial_data['graph']['accept_connection_types'] = self.model.accept_connection_types
-        serial_data['graph']['reject_connection_types'] = self.model.reject_connection_types
-
-        # serialize nodes.
-        for n in nodes:
-            # update the node model.
-            n.update_model()
-
-            node_dict = n.model.to_dict
-            nodes_data.update(node_dict)
-
-        for n_id, n_data in nodes_data.items():
-            serial_data['nodes'][n_id] = n_data
-
-            # serialize connections
-            inputs = n_data.pop('inputs') if n_data.get('inputs') else {}
-            outputs = n_data.pop('outputs') if n_data.get('outputs') else {}
-
-            for pname, conn_data in inputs.items():
-                for conn_id, prt_names in conn_data.items():
-                    for conn_prt in prt_names:
-                        pipe = {
-                            PortTypeEnum.IN.value: [n_id, pname],
-                            PortTypeEnum.OUT.value: [conn_id, conn_prt]
-                        }
-                        if pipe not in serial_data['connections']:
-                            serial_data['connections'].append(pipe)
-
-            for pname, conn_data in outputs.items():
-                for conn_id, prt_names in conn_data.items():
-                    for conn_prt in prt_names:
-                        pipe = {
-                            PortTypeEnum.OUT.value: [n_id, pname],
-                            PortTypeEnum.IN.value: [conn_id, conn_prt]
-                        }
-                        if pipe not in serial_data['connections']:
-                            serial_data['connections'].append(pipe)
-
-        if not serial_data['connections']:
-            serial_data.pop('connections')
-
-        return serial_data
-
-    def _deserialize(self, data, relative_pos=False, pos=None):
-        """
-        deserialize node data.
-        (used internally by the node graph)
-
-        Args:
-            data (dict): node data.
-            relative_pos (bool): position node relative to the cursor.
-            pos (tuple or list): custom x, y position.
-
-        Returns:
-            list[NodeGraphQt.Nodes]: list of node instances.
-        """
-        # update node graph properties.
-        for attr_name, attr_value in data.get('graph', {}).items():
-            if attr_name == 'layout_direction':
-                self.set_layout_direction(attr_value)
-            elif attr_name == 'acyclic':
-                self.set_acyclic(attr_value)
-            elif attr_name == 'pipe_collision':
-                self.set_pipe_collision(attr_value)
-            elif attr_name == 'pipe_slicing':
-                self.set_pipe_slicing(attr_value)
-            elif attr_name == 'pipe_style':
-                self.set_pipe_style(attr_value)
-
-            # connection constrains.
-            elif attr_name == 'accept_connection_types':
-                self.model.accept_connection_types = attr_value
-            elif attr_name == 'reject_connection_types':
-                self.model.reject_connection_types = attr_value
-
-        # build the nodes.
-        nodes = {}
-        for n_id, n_data in data.get('nodes', {}).items():
-            identifier = n_data['type_']
-            node = self._node_factory.create_node_instance(identifier)
-            if node:
-                node.NODE_NAME = n_data.get('name', node.NODE_NAME)
-                # set properties.
-                for prop in node.model.properties.keys():
-                    if prop in n_data.keys():
-                        node.model.set_property(prop, n_data[prop])
-                # set custom properties.
-                for prop, val in n_data.get('custom', {}).items():
-                    node.model.set_property(prop, val)
-                    if isinstance(node, BaseNode):
-                        if prop in node.view.widgets:
-                            node.view.widgets[prop].set_value(val)
-
-                nodes[n_id] = node
-                self.add_node(node, n_data.get('pos'))
-
-                if n_data.get('port_deletion_allowed', None):
-                    node.set_ports({
-                        'input_ports': n_data['input_ports'],
-                        'output_ports': n_data['output_ports']
-                    })
-
-        # build the connections.
-        for connection in data.get('connections', []):
-            nid, pname = connection.get('in', ('', ''))
-            in_node = nodes.get(nid) or self.get_node_by_id(nid)
-            if not in_node:
-                continue
-            in_port = in_node.inputs().get(pname) if in_node else None
-
-            nid, pname = connection.get('out', ('', ''))
-            out_node = nodes.get(nid) or self.get_node_by_id(nid)
-            if not out_node:
-                continue
-            out_port = out_node.outputs().get(pname) if out_node else None
-
-            if in_port and out_port:
-                # only connect if input port is not connected yet or input port
-                # can have multiple connections.
-                # important when duplicating nodes.
-                allow_connection = any([not in_port.model.connected_ports,
-                                        in_port.model.multi_connection])
-                if allow_connection:
-                    self._undo_stack.push(PortConnectedCmd(in_port, out_port))
-
-                # Run on_input_connected to ensure connections are fully set up after deserialization.
-                in_node.on_input_connected(in_port, out_port)
-
-        node_objs = nodes.values()
-        if relative_pos:
-            self._viewer.move_nodes([n.view for n in node_objs])
-            [setattr(n.model, 'pos', n.view.xy_pos) for n in node_objs]
-        elif pos:
-            self._viewer.move_nodes([n.view for n in node_objs], pos=pos)
-            [setattr(n.model, 'pos', n.view.xy_pos) for n in node_objs]
-
-        return node_objs
-
-    def serialize_session(self):
-        """
-        Serializes the current node graph layout to a dictionary.
-
-        See Also:
-            :meth:`NodeGraph.deserialize_session`,
-            :meth:`NodeGraph.save_session`,
-            :meth:`NodeGraph.load_session`
-
-        Returns:
-            dict: serialized session of the current node layout.
-        """
-        return self._serialize(self.all_nodes())
-
-    def deserialize_session(self, layout_data):
-        """
-        Load node graph session from a dictionary object.
-
-        See Also:
-            :meth:`NodeGraph.serialize_session`,
-            :meth:`NodeGraph.load_session`,
-            :meth:`NodeGraph.save_session`
-
-        Args:
-            layout_data (dict): dictionary object containing a node session.
-        """
-        self.clear_session()
-        self._deserialize(layout_data)
-        self.clear_selection()
-        self._undo_stack.clear()
-
-    def save_session(self, file_path):
-        """
-        Saves the current node graph session layout to a `JSON` formatted file.
-
-        See Also:
-            :meth:`NodeGraph.serialize_session`,
-            :meth:`NodeGraph.deserialize_session`,
-            :meth:`NodeGraph.load_session`,
-
-        Args:
-            file_path (str): path to the saved node layout.
-        """
-        serialized_data = self._serialize(self.all_nodes())
-        file_path = file_path.strip()
-        with open(file_path, 'w') as file_out:
-            json.dump(
-                serialized_data,
-                file_out,
-                indent=2,
-                separators=(',', ':')
-            )
-
-    def load_session(self, file_path):
-        """
-        Load node graph session layout file.
-
-        See Also:
-            :meth:`NodeGraph.deserialize_session`,
-            :meth:`NodeGraph.serialize_session`,
-            :meth:`NodeGraph.save_session`
-
-        Args:
-            file_path (str): path to the serialized layout file.
-        """
-        file_path = file_path.strip()
-        if not os.path.isfile(file_path):
-            raise IOError('file does not exist: {}'.format(file_path))
-
-        self.clear_session()
-        self.import_session(file_path)
-
-    def import_session(self, file_path):
-        """
-        Import node graph session layout file.
-
-        Args:
-            file_path (str): path to the serialized layout file.
-        """
-        file_path = file_path.strip()
-        if not os.path.isfile(file_path):
-            raise IOError('file does not exist: {}'.format(file_path))
-
-        try:
-            with open(file_path) as data_file:
-                layout_data = json.load(data_file)
-        except Exception as e:
-            layout_data = None
-            print('Cannot read data from file.\n{}'.format(e))
-
-        if not layout_data:
-            return
-
-        self._deserialize(layout_data)
-        self._undo_stack.clear()
-        self._model.session = file_path
-
-        self.session_changed.emit(file_path)
-
-    def copy_nodes(self, nodes=None):
-        """
-        Copy nodes to the clipboard.
-
-        See Also:
-            :meth:`NodeGraph.cut_nodes`
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]):
-                list of nodes (default: selected nodes).
-        """
-        nodes = nodes or self.selected_nodes()
-        if not nodes:
-            return False
-        clipboard = QtWidgets.QApplication.clipboard()
-        serial_data = self._serialize(nodes)
-        serial_str = json.dumps(serial_data)
-        if serial_str:
-            clipboard.setText(serial_str)
-            return True
-        return False
-
-    def cut_nodes(self, nodes=None):
-        """
-        Cut nodes to the clipboard.
-
-        Note:
-            This function doesn't not trigger the
-            :attr:`NodeGraph.nodes_deleted` signal.
-
-        See Also:
-            :meth:`NodeGraph.copy_nodes`
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]):
-                list of nodes (default: selected nodes).
-        """
-        nodes = nodes or self.selected_nodes()
-        self.copy_nodes(nodes)
-        self._undo_stack.beginMacro('cut nodes')
-
-        for node in nodes:
-            if isinstance(node, BaseNode):
-                for p in node.input_ports():
-                    if p.locked():
-                        p.set_locked(False,
-                                     connected_ports=False,
-                                     push_undo=True)
-                    p.clear_connections()
-                for p in node.output_ports():
-                    if p.locked():
-                        p.set_locked(False,
-                                     connected_ports=False,
-                                     push_undo=True)
-                    p.clear_connections()
-
-            # collapse group node before removing.
-            if isinstance(node, GroupNode) and node.is_expanded:
-                node.collapse()
-
-            self._undo_stack.push(NodeRemovedCmd(self, node))
-
-        self._undo_stack.endMacro()
-
-    def paste_nodes(self):
-        """
-        Pastes nodes copied from the clipboard.
-        
-        Returns:
-            list[NodeGraphQt.BaseNode]: list of pasted node instances.
-        """
-        clipboard = QtWidgets.QApplication.clipboard()
-        cb_text = clipboard.text()
-        if not cb_text:
-            return
-
-        try:
-            serial_data = json.loads(cb_text)
-        except json.decoder.JSONDecodeError as e:
-            print('ERROR: Can\'t Decode Clipboard Data:\n'
-                  '"{}"'.format(cb_text))
-            return
-
-        self._undo_stack.beginMacro('pasted nodes')
-        self.clear_selection()
-        nodes = self._deserialize(serial_data, relative_pos=True)
-        [n.set_selected(True) for n in nodes]
-        self._undo_stack.endMacro()
-        return nodes
-
-    def duplicate_nodes(self, nodes):
-        """
-        Create duplicate copy from the list of nodes.
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]): list of nodes.
-        Returns:
-            list[NodeGraphQt.BaseNode]: list of duplicated node instances.
-        """
-        if not nodes:
-            return
-
-        self._undo_stack.beginMacro('duplicate nodes')
-
-        self.clear_selection()
-        serial = self._serialize(nodes)
-        new_nodes = self._deserialize(serial)
-        offset = 50
-        for n in new_nodes:
-            x, y = n.pos()
-            n.set_pos(x + offset, y + offset)
-            n.set_property('selected', True)
-
-        self._undo_stack.endMacro()
-        return new_nodes
-
-    def disable_nodes(self, nodes, mode=None):
-        """
-        Toggle nodes to be either disabled or enabled state.
-
-        See Also:
-            :meth:`NodeObject.set_disabled`
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]): list of nodes.
-            mode (bool): (optional) override state of the nodes.
-        """
-        if not nodes:
-            return
-
-        if len(nodes) == 1:
-            if mode is None:
-                mode = not nodes[0].disabled()
-            nodes[0].set_disabled(mode)
-            return
-
-        if mode is not None:
-            states = {False: 'enable', True: 'disable'}
-            text = '{} ({}) nodes'.format(states[mode], len(nodes))
-            self._undo_stack.beginMacro(text)
-            [n.set_disabled(mode) for n in nodes]
-            self._undo_stack.endMacro()
-            return
-
-        text = []
-        enabled_count = len([n for n in nodes if n.disabled()])
-        disabled_count = len([n for n in nodes if not n.disabled()])
-        if enabled_count > 0:
-            text.append('enabled ({})'.format(enabled_count))
-        if disabled_count > 0:
-            text.append('disabled ({})'.format(disabled_count))
-        text = ' / '.join(text) + ' nodes'
-
-        self._undo_stack.beginMacro(text)
-        [n.set_disabled(not n.disabled()) for n in nodes]
-        self._undo_stack.endMacro()
-
-    def use_OpenGL(self):
-        """
-        Set the viewport to use QOpenGLWidget widget to draw the graph.
-        """
-        self._viewer.use_OpenGL()
-
-    # auto layout node functions.
-    # --------------------------------------------------------------------------
-
-    @staticmethod
-    def _update_node_rank(node, nodes_rank, down_stream=True):
-        """
-        Recursive function for updating the node ranking.
-
-        Args:
-            node (NodeGraphQt.BaseNode): node to start from.
-            nodes_rank (dict): node ranking object to be updated.
-            down_stream (bool): true to rank down stram.
-        """
-        if down_stream:
-            node_values = node.connected_output_nodes().values()
-        else:
-            node_values = node.connected_input_nodes().values()
-
-        connected_nodes = set()
-        for nodes in node_values:
-            connected_nodes.update(nodes)
-
-        rank = nodes_rank[node] + 1
-        for n in connected_nodes:
-            if n in nodes_rank:
-                nodes_rank[n] = max(nodes_rank[n], rank)
-            else:
-                nodes_rank[n] = rank
-            NodeGraph._update_node_rank(n, nodes_rank, down_stream)
-
-    @staticmethod
-    def _compute_node_rank(nodes, down_stream=True):
-        """
-        Compute the ranking of nodes.
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]): nodes to start ranking from.
-            down_stream (bool): true to compute down stream.
-
-        Returns:
-            dict: {NodeGraphQt.BaseNode: node_rank, ...}
-        """
-        nodes_rank = {}
-        for node in nodes:
-            nodes_rank[node] = 0
-            NodeGraph._update_node_rank(node, nodes_rank, down_stream)
-        return nodes_rank
-
-    def auto_layout_nodes(self, nodes=None, down_stream=True, start_nodes=None):
-        """
-        Auto layout the nodes in the node graph.
-
-        Note:
-            If the node graph is acyclic then the ``start_nodes`` will need
-            to be specified.
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]): list of nodes to auto layout
-                if nodes is None then all nodes is layed out.
-            down_stream (bool): false to layout up stream.
-            start_nodes (list[NodeGraphQt.BaseNode]):
-                list of nodes to start the auto layout from (Optional).
-        """
-        self.begin_undo('Auto Layout Nodes')
-
-        nodes = nodes or self.all_nodes()
-
-        # filter out the backdrops.
-        backdrops = {
-            n: n.nodes() for n in nodes if isinstance(n, BackdropNode)
-        }
-        filtered_nodes = [n for n in nodes if not isinstance(n, BackdropNode)]
-
-        start_nodes = start_nodes or []
-        if down_stream:
-            start_nodes += [
-                n for n in filtered_nodes
-                if not any(n.connected_input_nodes().values())
-            ]
-        else:
-            start_nodes += [
-                n for n in filtered_nodes
-                if not any(n.connected_output_nodes().values())
-            ]
-
-        if not start_nodes:
-            return
-
-        node_views = [n.view for n in nodes]
-        nodes_center_0 = self.viewer().nodes_rect_center(node_views)
-
-        nodes_rank = NodeGraph._compute_node_rank(start_nodes, down_stream)
-
-        rank_map = {}
-        for node, rank in nodes_rank.items():
-            if rank in rank_map:
-                rank_map[rank].append(node)
-            else:
-                rank_map[rank] = [node]
-
-        node_layout_direction = self._viewer.get_layout_direction()
-
-        if node_layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-            current_x = 0
-            node_height = 120
-            for rank in sorted(range(len(rank_map)), reverse=not down_stream):
-                ranked_nodes = rank_map[rank]
-                max_width = max([node.view.width for node in ranked_nodes])
-                current_x += max_width
-                current_y = 0
-                for idx, node in enumerate(ranked_nodes):
-                    dy = max(node_height, node.view.height)
-                    current_y += 0 if idx == 0 else dy
-                    node.set_pos(current_x, current_y)
-                    current_y += dy * 0.5 + 10
-
-                current_x += max_width * 0.5 + 100
-        elif node_layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            current_y = 0
-            node_width = 250
-            for rank in sorted(range(len(rank_map)), reverse=not down_stream):
-                ranked_nodes = rank_map[rank]
-                max_height = max([node.view.height for node in ranked_nodes])
-                current_y += max_height
-                current_x = 0
-                for idx, node in enumerate(ranked_nodes):
-                    dx = max(node_width, node.view.width)
-                    current_x += 0 if idx == 0 else dx
-                    node.set_pos(current_x, current_y)
-                    current_x += dx * 0.5 + 10
-
-                current_y += max_height * 0.5 + 100
-
-        nodes_center_1 = self.viewer().nodes_rect_center(node_views)
-        dx = nodes_center_0[0] - nodes_center_1[0]
-        dy = nodes_center_0[1] - nodes_center_1[1]
-        [n.set_pos(n.x_pos() + dx, n.y_pos() + dy) for n in nodes]
-
-        # wrap the backdrop nodes.
-        for backdrop, contained_nodes in backdrops.items():
-            backdrop.wrap_nodes(contained_nodes)
-
-        self.end_undo()
-
-    # convenience dialog functions.
-    # --------------------------------------------------------------------------
-
-    def question_dialog(self, text, title='Node Graph'):
-        """
-        Prompts a question open dialog with ``"Yes"`` and ``"No"`` buttons in
-        the node graph.
-
-        Note:
-            Convenience function to
-            :meth:`NodeGraph.viewer().question_dialog`
-
-        Args:
-            text (str): question text.
-            title (str): dialog window title.
-
-        Returns:
-            bool: true if user clicked yes.
-        """
-        return self._viewer.question_dialog(text, title)
-
-    def message_dialog(self, text, title='Node Graph'):
-        """
-        Prompts a file open dialog in the node graph.
-
-        Note:
-            Convenience function to
-            :meth:`NodeGraph.viewer().message_dialog`
-
-        Args:
-            text (str): message text.
-            title (str): dialog window title.
-        """
-        self._viewer.message_dialog(text, title)
-
-    def load_dialog(self, current_dir=None, ext=None):
-        """
-        Prompts a file open dialog in the node graph.
-
-        Note:
-            Convenience function to
-            :meth:`NodeGraph.viewer().load_dialog`
-
-        Args:
-            current_dir (str): path to a directory.
-            ext (str): custom file type extension (default: ``"json"``)
-
-        Returns:
-            str: selected file path.
-        """
-        return self._viewer.load_dialog(current_dir, ext)
-
-    def save_dialog(self, current_dir=None, ext=None):
-        """
-        Prompts a file save dialog in the node graph.
-
-        Note:
-            Convenience function to
-            :meth:`NodeGraph.viewer().save_dialog`
-
-        Args:
-            current_dir (str): path to a directory.
-            ext (str): custom file type extension (default: ``"json"``)
-
-        Returns:
-            str: selected file path.
-        """
-        return self._viewer.save_dialog(current_dir, ext)
-
-    # group node / sub graph.
-    # --------------------------------------------------------------------------
-
-    def _on_close_sub_graph_tab(self, index):
-        """
-        Called when the close button is clicked on a expanded sub graph tab.
-
-        Args:
-            index (int): tab index.
-        """
-        node_id = self.widget.tabToolTip(index)
-        group_node = self.get_node_by_id(node_id)
-        self.collapse_group_node(group_node)
-
-    @property
-    def is_root(self):
-        """
-        Returns if the node graph controller is the root graph.
-
-        Returns:
-            bool: true is the node graph is root.
-        """
-        return True
-
-    @property
-    def sub_graphs(self):
-        """
-        Returns expanded group node sub graphs.
-
-        Returns:
-            dict: {<node_id>: <sub_graph>}
-        """
-        return self._sub_graphs
-
-    # def graph_rect(self):
-    #     """
-    #     Get the graph viewer range (scene size).
-    #
-    #     Returns:
-    #         list[float]: [x, y, width, height].
-    #     """
-    #     return self._viewer.scene_rect()
-    #
-    # def set_graph_rect(self, rect):
-    #     """
-    #     Set the graph viewer range (scene size).
-    #
-    #     Args:
-    #         rect (list[float]): [x, y, width, height].
-    #     """
-    #     self._viewer.set_scene_rect(rect)
-
-    def expand_group_node(self, node):
-        """
-        Expands a group node session in a new tab.
-
-        Args:
-            node (NodeGraphQt.GroupNode): group node.
-
-        Returns:
-            SubGraph: sub node graph used to manage the group node session.
-        """
-        if not isinstance(node, GroupNode):
-            return
-        if self._widget is None:
-            raise RuntimeError('NodeGraph.widget not initialized!')
-
-        self.viewer().clear_key_state()
-        self.viewer().clearFocus()
-
-        if node.id in self._sub_graphs:
-            sub_graph = self._sub_graphs[node.id]
-            tab_index = self._widget.indexOf(sub_graph.widget)
-            self._widget.setCurrentIndex(tab_index)
-            return sub_graph
-
-        # build new sub graph.
-        node_factory = copy.deepcopy(self.node_factory)
-        layout_direction = self.layout_direction()
-        kwargs = {
-            'layout_direction': self.layout_direction(),
-            'pipe_style': self.pipe_style(),
-        }
-        sub_graph = SubGraph(self,
-                             node=node,
-                             node_factory=node_factory,
-                             **kwargs)
-
-        # populate the sub graph.
-        session = node.get_sub_graph_session()
-        sub_graph.deserialize_session(session)
-
-        # store reference to expanded.
-        self._sub_graphs[node.id] = sub_graph
-
-        # open new tab at root level.
-        self.widget.add_viewer(sub_graph.widget, node.name(), node.id)
-
-        return sub_graph
-
-    def collapse_group_node(self, node):
-        """
-        Collapse a group node session tab and it's expanded child sub graphs.
-
-        Args:
-            node (NodeGraphQt.GroupNode): group node.
-        """
-        assert isinstance(node, GroupNode), 'node must be a GroupNode instance.'
-        if self._widget is None:
-            return
-
-        if node.id not in self._sub_graphs:
-            err = '{} sub graph not initialized!'.format(node.name())
-            raise RuntimeError(err)
-
-        sub_graph = self._sub_graphs.pop(node.id)
-        sub_graph.collapse_group_node(node)
-
-        # remove the sub graph tab.
-        self.widget.remove_viewer(sub_graph.widget)
-
-        # TODO: delete sub graph hmm... not sure if I need this here.
-        del sub_graph
-
-
-class SubGraph(NodeGraph):
-    """
-    The ``SubGraph`` class is just like the ``NodeGraph`` but is the main
-    controller for managing the expanded node graph for a
-    :class:`NodeGraphQt.GroupNode`.
-
-    .. inheritance-diagram:: NodeGraphQt.SubGraph
-        :top-classes: PySide2.QtCore.QObject
-
-    .. image:: _images/sub_graph.png
-        :width: 70%
-
-    -
-    """
-
-    def __init__(self, parent=None, node=None, node_factory=None, **kwargs):
-        """
-        Args:
-            parent (object): object parent.
-            node (GroupNode): group node related to this sub graph.
-            node_factory (NodeFactory): override node factory.
-            **kwargs (dict): additional kwargs.
-        """
-        super(SubGraph, self).__init__(
-            parent, node_factory=node_factory, **kwargs
-        )
-
-        # sub graph attributes.
-        self._node = node
-        self._parent_graph = parent
-        self._subviewer_widget = None
-
-        if self._parent_graph.is_root:
-            self._initialized_graphs = [self]
-            self._sub_graphs[self._node.id] = self
-        else:
-            # delete attributes if not top level sub graph.
-            del self._widget
-            del self._sub_graphs
-
-        # clone context menu from the parent node graph.
-        self._clone_context_menu_from_parent()
-
-    def __repr__(self):
-        return '<{}("{}") object at {}>'.format(
-            self.__class__.__name__, self._node.name(), hex(id(self)))
-
-    def _register_builtin_nodes(self):
-        """
-        Register the default builtin nodes to the :meth:`NodeGraph.node_factory`
-        """
-        return
-
-    def _clone_context_menu_from_parent(self):
-        """
-        Clone the context menus from the parent node graph.
-        """
-        graph_menu = self.get_context_menu('graph')
-        parent_menu = self.parent_graph.get_context_menu('graph')
-        parent_viewer = self.parent_graph.viewer()
-        excl_actions = [parent_viewer.qaction_for_undo(),
-                        parent_viewer.qaction_for_redo()]
-
-        def clone_menu(menu, menu_to_clone):
-            """
-            Args:
-                menu (NodeGraphQt.NodeGraphMenu):
-                menu_to_clone (NodeGraphQt.NodeGraphMenu):
-            """
-            sub_items = []
-            for item in menu_to_clone.get_items():
-                if item is None:
-                    menu.add_separator()
-                    continue
-                name = item.name()
-                if isinstance(item, NodeGraphMenu):
-                    sub_menu = menu.add_menu(name)
-                    sub_items.append([sub_menu, item])
-                    continue
-
-                if item in excl_actions:
-                    continue
-
-                menu.add_command(
-                    name,
-                    func=item.slot_function,
-                    shortcut=item.qaction.shortcut()
-                )
-
-            for sub_menu, to_clone in sub_items:
-                clone_menu(sub_menu, to_clone)
-
-        # duplicate the menu items.
-        clone_menu(graph_menu, parent_menu)
-
-    def _build_port_nodes(self):
-        """
-        Build the corresponding input & output nodes from the parent node ports
-        and remove any port nodes that are outdated..
-
-        Returns:
-             tuple(dict, dict): input nodes, output nodes.
-        """
-        node_layout_direction = self._viewer.get_layout_direction()
-
-        # build the parent input port nodes.
-        input_nodes = {n.name(): n for n in
-                       self.get_nodes_by_type(PortInputNode.type_)}
-        for port in self.node.input_ports():
-            if port.name() not in input_nodes:
-                input_node = PortInputNode(parent_port=port)
-                input_node.NODE_NAME = port.name()
-                input_node.model.set_property('name', port.name())
-                input_node.add_output(port.name())
-                input_nodes[port.name()] = input_node
-                self.add_node(input_node, selected=False, push_undo=False)
-                x, y = input_node.pos()
-                if node_layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-                    x -= 100
-                elif node_layout_direction is LayoutDirectionEnum.VERTICAL.value:
-                    y -= 100
-                input_node.set_property('pos', [x, y], push_undo=False)
-
-        # build the parent output port nodes.
-        output_nodes = {n.name(): n for n in
-                        self.get_nodes_by_type(PortOutputNode.type_)}
-        for port in self.node.output_ports():
-            if port.name() not in output_nodes:
-                output_node = PortOutputNode(parent_port=port)
-                output_node.NODE_NAME = port.name()
-                output_node.model.set_property('name', port.name())
-                output_node.add_input(port.name())
-                output_nodes[port.name()] = output_node
-                self.add_node(output_node, selected=False, push_undo=False)
-                x, y = output_node.pos()
-                if node_layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-                    x += 100
-                elif node_layout_direction is LayoutDirectionEnum.VERTICAL.value:
-                    y += 100
-                output_node.set_property('pos', [x, y], push_undo=False)
-
-        return input_nodes, output_nodes
-
-    def _deserialize(self, data, relative_pos=False, pos=None):
-        """
-        deserialize node data.
-        (used internally by the node graph)
-
-        Args:
-            data (dict): node data.
-            relative_pos (bool): position node relative to the cursor.
-            pos (tuple or list): custom x, y position.
-
-        Returns:
-            list[NodeGraphQt.Nodes]: list of node instances.
-        """
-        # update node graph properties.
-        for attr_name, attr_value in data.get('graph', {}).items():
-            if attr_name == 'acyclic':
-                self.set_acyclic(attr_value)
-            elif attr_name == 'pipe_collision':
-                self.set_pipe_collision(attr_value)
-
-        # build the port input & output nodes here.
-        input_nodes, output_nodes = self._build_port_nodes()
-
-        # build the nodes.
-        nodes = {}
-        for n_id, n_data in data.get('nodes', {}).items():
-            identifier = n_data['type_']
-            name = n_data.get('name')
-            if identifier == PortInputNode.type_:
-                nodes[n_id] = input_nodes[name]
-                nodes[n_id].set_pos(*(n_data.get('pos') or [0, 0]))
-                continue
-            elif identifier == PortOutputNode.type_:
-                nodes[n_id] = output_nodes[name]
-                nodes[n_id].set_pos(*(n_data.get('pos') or [0, 0]))
-                continue
-
-            node = self._node_factory.create_node_instance(identifier)
-            if not node:
-                continue
-
-            node.NODE_NAME = name or node.NODE_NAME
-            # set properties.
-            for prop in node.model.properties.keys():
-                if prop in n_data.keys():
-                    node.model.set_property(prop, n_data[prop])
-            # set custom properties.
-            for prop, val in n_data.get('custom', {}).items():
-                node.model.set_property(prop, val)
-
-            nodes[n_id] = node
-            self.add_node(node, n_data.get('pos'))
-
-            if n_data.get('port_deletion_allowed', None):
-                node.set_ports({
-                    'input_ports': n_data['input_ports'],
-                    'output_ports': n_data['output_ports']
-                })
-
-        # build the connections.
-        for connection in data.get('connections', []):
-            nid, pname = connection.get('in', ('', ''))
-            in_node = nodes.get(nid)
-            if not in_node:
-                continue
-            in_port = in_node.inputs().get(pname) if in_node else None
-
-            nid, pname = connection.get('out', ('', ''))
-            out_node = nodes.get(nid)
-            if not out_node:
-                continue
-            out_port = out_node.outputs().get(pname) if out_node else None
-
-            if in_port and out_port:
-                self._undo_stack.push(PortConnectedCmd(in_port, out_port))
-
-        node_objs = list(nodes.values())
-        if relative_pos:
-            self._viewer.move_nodes([n.view for n in node_objs])
-            [setattr(n.model, 'pos', n.view.xy_pos) for n in node_objs]
-        elif pos:
-            self._viewer.move_nodes([n.view for n in node_objs], pos=pos)
-            [setattr(n.model, 'pos', n.view.xy_pos) for n in node_objs]
-
-        return node_objs
-
-    def _on_navigation_changed(self, node_id, rm_node_ids):
-        """
-        Slot when the node navigation widget has changed.
-
-        Args:
-            node_id (str): selected group node id.
-            rm_node_ids (list[str]): list of group node id to remove.
-        """
-        # collapse child sub graphs.
-        for rm_node_id in rm_node_ids:
-            child_node = self.sub_graphs[rm_node_id].node
-            self.collapse_group_node(child_node)
-
-        # show the selected node id sub graph.
-        sub_graph = self.sub_graphs.get(node_id)
-        if sub_graph:
-            self.widget.show_viewer(sub_graph.subviewer_widget)
-            sub_graph.viewer().setFocus()
-
-    @property
-    def is_root(self):
-        """
-        Returns if the node graph controller is the main root graph.
-
-        Returns:
-            bool: true is the node graph is root.
-        """
-        return False
-
-    @property
-    def sub_graphs(self):
-        """
-        Returns expanded group node sub graphs.
-
-        Returns:
-            dict: {<node_id>: <sub_graph>}
-        """
-        if self.parent_graph.is_root:
-            return self._sub_graphs
-        return self.parent_graph.sub_graphs
-
-    @property
-    def initialized_graphs(self):
-        """
-        Returns a list of the sub graphs in the order they were initialized.
-
-        Returns:
-            list[NodeGraphQt.SubGraph]: list of sub graph objects.
-        """
-        if self._parent_graph.is_root:
-            return self._initialized_graphs
-        return self._parent_graph.initialized_graphs
-
-    @property
-    def widget(self):
-        """
-        The sub graph widget from the top most sub graph.
-
-        Returns:
-            SubGraphWidget: node graph widget.
-        """
-        if self.parent_graph.is_root:
-            if self._widget is None:
-                self._widget = SubGraphWidget()
-                self._widget.add_viewer(self.subviewer_widget,
-                                        self.node.name(),
-                                        self.node.id)
-                # connect the navigator widget signals.
-                navigator = self._widget.navigator
-                navigator.navigation_changed.connect(
-                    self._on_navigation_changed
-                )
-            return self._widget
-        return self.parent_graph.widget
-
-    @property
-    def navigation_widget(self):
-        """
-        The navigation widget from the top most sub graph.
-
-        Returns:
-            NodeNavigationWidget: navigation widget.
-        """
-        if self.parent_graph.is_root:
-            return self.widget.navigator
-        return self.parent_graph.navigation_widget
-
-    @property
-    def subviewer_widget(self):
-        """
-        The widget to the sub graph.
-
-        Returns:
-            PySide2.QtWidgets.QWidget: node graph widget.
-        """
-        if self._subviewer_widget is None:
-            self._subviewer_widget = QtWidgets.QWidget()
-            layout = QtWidgets.QVBoxLayout(self._subviewer_widget)
-            layout.setContentsMargins(0, 0, 0, 0)
-            layout.setSpacing(1)
-            layout.addWidget(self._viewer)
-        return self._subviewer_widget
-
-    @property
-    def parent_graph(self):
-        """
-        The parent node graph controller.
-
-        Returns:
-            NodeGraphQt.NodeGraph or NodeGraphQt.SubGraph: parent graph.
-        """
-        return self._parent_graph
-
-    @property
-    def node(self):
-        """
-        Returns the parent node to the sub graph.
-
-        .. image:: _images/group_node.png
-            :width: 250px
-
-        Returns:
-            NodeGraphQt.GroupNode: group node.
-        """
-        return self._node
-
-    def delete_node(self, node, push_undo=True):
-        """
-        Remove the node from the node sub graph.
-
-        Note:
-            :class:`.PortInputNode` & :class:`.PortOutputNode` can't be deleted
-            as they are connected to a :class:`.Port` to remove these port nodes
-            see :meth:`BaseNode.delete_input`, :meth:`BaseNode.delete_output`.
-
-        Args:
-            node (NodeGraphQt.BaseNode): node object.
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        port_nodes = self.get_input_port_nodes() + self.get_output_port_nodes()
-        if node in port_nodes and node.parent_port is not None:
-            # note: port nodes can only be deleted by deleting the parent
-            #       port object.
-            raise NodeDeletionError(
-                '{} can\'t be deleted as it is attached to a port!'.format(node)
-            )
-        super(SubGraph, self).delete_node(node, push_undo=push_undo)
-
-    def delete_nodes(self, nodes, push_undo=True):
-        """
-        Remove a list of specified nodes from the node graph.
-
-        Args:
-            nodes (list[NodeGraphQt.BaseNode]): list of node instances.
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        if not nodes:
-            return
-
-        port_nodes = self.get_input_port_nodes() + self.get_output_port_nodes()
-        for node in nodes:
-            if node in port_nodes and node.parent_port is not None:
-                # note: port nodes can only be deleted by deleting the parent
-                #       port object.
-                raise NodeDeletionError(
-                    '{} can\'t be deleted as it is attached to a port!'
-                    .format(node)
-                )
-
-        super(SubGraph, self).delete_nodes(nodes, push_undo=push_undo)
-
-    def collapse_graph(self, clear_session=True):
-        """
-        Collapse the current sub graph and hide its widget.
-
-        Args:
-            clear_session (bool): clear the current session.
-        """
-        # update the group node.
-        serialized_session = self.serialize_session()
-        self.node.set_sub_graph_session(serialized_session)
-
-        # close the visible widgets.
-        if self._undo_view:
-            self._undo_view.close()
-
-        if self._subviewer_widget:
-            self.widget.hide_viewer(self._subviewer_widget)
-
-        if clear_session:
-            self.clear_session()
-
-    def expand_group_node(self, node):
-        """
-        Expands a group node session in current sub view.
-
-        Args:
-            node (NodeGraphQt.GroupNode): group node.
-
-        Returns:
-            SubGraph: sub node graph used to manage the group node session.
-        """
-        assert isinstance(node, GroupNode), 'node must be a GroupNode instance.'
-        if self._subviewer_widget is None:
-            raise RuntimeError('SubGraph.widget not initialized!')
-
-        self.viewer().clear_key_state()
-        self.viewer().clearFocus()
-
-        if node.id in self.sub_graphs:
-            sub_graph_viewer = self.sub_graphs[node.id].viewer()
-            sub_graph_viewer.setFocus()
-            return self.sub_graphs[node.id]
-
-        # collapse expanded child sub graphs.
-        group_ids = [n.id for n in self.all_nodes() if isinstance(n, GroupNode)]
-        for grp_node_id, grp_sub_graph in self.sub_graphs.items():
-            # collapse current group node.
-            if grp_node_id in group_ids:
-                grp_node = self.get_node_by_id(grp_node_id)
-                self.collapse_group_node(grp_node)
-
-            # close the widgets
-            grp_sub_graph.collapse_graph(clear_session=False)
-
-        # build new sub graph.
-        node_factory = copy.deepcopy(self.node_factory)
-        sub_graph = SubGraph(self,
-                             node=node,
-                             node_factory=node_factory,
-                             layout_direction=self.layout_direction())
-
-        # populate the sub graph.
-        serialized_session = node.get_sub_graph_session()
-        sub_graph.deserialize_session(serialized_session)
-
-        # open new sub graph view.
-        self.widget.add_viewer(sub_graph.subviewer_widget,
-                               node.name(),
-                               node.id)
-
-        # store the references.
-        self.sub_graphs[node.id] = sub_graph
-        self.initialized_graphs.append(sub_graph)
-
-        return sub_graph
-
-    def collapse_group_node(self, node):
-        """
-        Collapse a group node session and it's expanded child sub graphs.
-
-        Args:
-            node (NodeGraphQt.GroupNode): group node.
-        """
-        # update the references.
-        sub_graph = self.sub_graphs.pop(node.id, None)
-        if not sub_graph:
-            return
-
-        init_idx = self.initialized_graphs.index(sub_graph) + 1
-        for sgraph in reversed(self.initialized_graphs[init_idx:]):
-            self.initialized_graphs.remove(sgraph)
-
-        # collapse child sub graphs here.
-        child_ids = [
-            n.id for n in sub_graph.all_nodes() if isinstance(n, GroupNode)
-        ]
-        for child_id in child_ids:
-            if self.sub_graphs.get(child_id):
-                child_graph = self.sub_graphs.pop(child_id)
-                child_graph.collapse_graph(clear_session=True)
-                # remove child viewer widget.
-                self.widget.remove_viewer(child_graph.subviewer_widget)
-
-        sub_graph.collapse_graph(clear_session=True)
-        self.widget.remove_viewer(sub_graph.subviewer_widget)
-
-    def get_input_port_nodes(self):
-        """
-        Return all the port nodes related to the group node input ports.
-
-        .. image:: _images/port_in_node.png
-            :width: 150px
-
-        -
-
-        See Also:
-            :meth:`NodeGraph.get_nodes_by_type`,
-            :meth:`SubGraph.get_output_port_nodes`
-
-        Returns:
-            list[NodeGraphQt.PortInputNode]: input nodes.
-        """
-        return self.get_nodes_by_type(PortInputNode.type_)
-
-    def get_output_port_nodes(self):
-        """
-        Return all the port nodes related to the group node output ports.
-
-        .. image:: _images/port_out_node.png
-            :width: 150px
-
-        -
-
-        See Also:
-            :meth:`NodeGraph.get_nodes_by_type`,
-            :meth:`SubGraph.get_input_port_nodes`
-
-        Returns:
-            list[NodeGraphQt.PortOutputNode]: output nodes.
-        """
-        return self.get_nodes_by_type(PortOutputNode.type_)
-
-    def get_node_by_port(self, port):
-        """
-        Returns the node related to the parent group node port object.
-
-        Args:
-            port (NodeGraphQt.Port): parent node port object.
-
-        Returns:
-            PortInputNode or PortOutputNode: port node object.
-        """
-        func_type = {
-            PortTypeEnum.IN.value: self.get_input_port_nodes,
-            PortTypeEnum.OUT.value: self.get_output_port_nodes
-        }
-        for n in func_type.get(port.type_(), []):
-            if port == n.parent_port:
-                return n
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+import copy
+import json
+import os
+import re
+
+from Qt import QtCore, QtWidgets
+
+from NodeGraphQt.base.commands import (NodeAddedCmd,
+                                       NodeRemovedCmd,
+                                       NodeMovedCmd,
+                                       PortConnectedCmd)
+from NodeGraphQt.base.factory import NodeFactory
+from NodeGraphQt.base.menu import NodeGraphMenu, NodesMenu
+from NodeGraphQt.base.model import NodeGraphModel
+from NodeGraphQt.base.node import NodeObject
+from NodeGraphQt.base.port import Port
+from NodeGraphQt.constants import (
+    URI_SCHEME,
+    URN_SCHEME,
+    LayoutDirectionEnum,
+    PipeLayoutEnum,
+    PortTypeEnum,
+    ViewerEnum
+)
+from NodeGraphQt.errors import NodeCreationError, NodeDeletionError
+from NodeGraphQt.nodes.backdrop_node import BackdropNode
+from NodeGraphQt.nodes.base_node import BaseNode
+from NodeGraphQt.nodes.group_node import GroupNode
+from NodeGraphQt.nodes.port_node import PortInputNode, PortOutputNode
+from NodeGraphQt.widgets.node_graph import NodeGraphWidget, SubGraphWidget
+from NodeGraphQt.widgets.viewer import NodeViewer
+from NodeGraphQt.widgets.viewer_nav import NodeNavigationWidget
+
+
+class NodeGraph(QtCore.QObject):
+    """
+    The ``NodeGraph`` class is the main controller for managing all nodes
+    and the node graph.
+
+    .. inheritance-diagram:: NodeGraphQt.NodeGraph
+        :top-classes: PySide2.QtCore.QObject
+
+    .. image:: _images/graph.png
+        :width: 60%
+    """
+
+    nodes_registered = QtCore.Signal(list)
+    """
+    Signal triggered when a node is registered into the node graph.
+
+    :parameters: list[:class:`NodeGraphQt.NodeObject`]
+    :emits: registered nodes
+    """
+
+    node_created = QtCore.Signal(NodeObject)
+    """
+    Signal triggered when a node is created in the node graph.
+
+    :parameters: :class:`NodeGraphQt.NodeObject`
+    :emits: created node
+    """
+    nodes_deleted = QtCore.Signal(list)
+    """
+    Signal triggered when nodes have been deleted from the node graph.
+
+    :parameters: list[str]
+    :emits: list of deleted node ids.
+    """
+    node_selected = QtCore.Signal(NodeObject)
+    """
+    Signal triggered when a node is clicked with the LMB.
+
+    :parameters: :class:`NodeGraphQt.NodeObject`
+    :emits: selected node
+    """
+    node_selection_changed = QtCore.Signal(list, list)
+    """
+    Signal triggered when the node selection has changed.
+
+    :parameters: list[:class:`NodeGraphQt.NodeObject`],
+                 list[:class:`NodeGraphQt.NodeObject`]
+    :emits: selected node, deselected nodes.
+    """
+    node_double_clicked = QtCore.Signal(NodeObject)
+    """
+    Signal triggered when a node is double clicked and emits the node.
+
+    :parameters: :class:`NodeGraphQt.NodeObject`
+    :emits: selected node
+    """
+    port_connected = QtCore.Signal(Port, Port)
+    """
+    Signal triggered when a node port has been connected.
+
+    :parameters: :class:`NodeGraphQt.Port`, :class:`NodeGraphQt.Port`
+    :emits: input port, output port
+    """
+    port_disconnected = QtCore.Signal(Port, Port)
+    """
+    Signal triggered when a node port has been disconnected.
+
+    :parameters: :class:`NodeGraphQt.Port`, :class:`NodeGraphQt.Port`
+    :emits: input port, output port
+    """
+    property_changed = QtCore.Signal(NodeObject, str, object)
+    """
+    Signal is triggered when a property has changed on a node.
+
+    :parameters: :class:`NodeGraphQt.BaseNode`, str, object
+    :emits: triggered node, property name, property value
+    """
+    data_dropped = QtCore.Signal(QtCore.QMimeData, QtCore.QPoint)
+    """
+    Signal is triggered when data has been dropped to the graph.
+
+    :parameters: :class:`PySide2.QtCore.QMimeData`, :class:`PySide2.QtCore.QPoint`
+    :emits: mime data, node graph position
+    """
+    session_changed = QtCore.Signal(str)
+    """
+    Signal is triggered when session has been changed.
+
+    :parameters: :str
+    :emits: new session path
+    """
+
+    def __init__(self, parent=None, **kwargs):
+        """
+        Args:
+            parent (object): object parent.
+            **kwargs (dict): Used for overriding internal objects at init time.
+        """
+        super(NodeGraph, self).__init__(parent)
+        self.setObjectName('NodeGraph')
+        self._model = (
+            kwargs.get('model') or NodeGraphModel())
+        self._node_factory = (
+            kwargs.get('node_factory') or NodeFactory())
+        self._undo_view = None
+        self._undo_stack = (
+            kwargs.get('undo_stack') or QtWidgets.QUndoStack(self)
+        )
+        self._widget = None
+        self._sub_graphs = {}
+        self._viewer = (
+            kwargs.get('viewer') or NodeViewer(undo_stack=self._undo_stack)
+        )
+
+        layout_direction = kwargs.get('layout_direction')
+        if layout_direction:
+            if layout_direction not in [e.value for e in LayoutDirectionEnum]:
+                layout_direction = LayoutDirectionEnum.HORIZONTAL.value
+            self._model.layout_direction = layout_direction
+        else:
+            layout_direction = self._model.layout_direction
+        self._viewer.set_layout_direction(layout_direction)
+
+        pipe_style = kwargs.get('pipe_style')
+        if pipe_style is not None:
+            if pipe_style not in [e.value for e in PipeLayoutEnum]:
+                pipe_style = PipeLayoutEnum.CURVED.value
+            self._model.pipe_style = pipe_style
+        else:
+            pipe_style = self._model.pipe_style
+        self._viewer.set_pipe_layout(pipe_style)
+
+        # viewer needs a reference to the model port connection constrains
+        # for the user interaction with the live pipe.
+        self._viewer.accept_connection_types = self._model.accept_connection_types
+        self._viewer.reject_connection_types = self._model.reject_connection_types
+
+        self._context_menu = {}
+
+        self._register_context_menu()
+        self._register_builtin_nodes()
+        self._wire_signals()
+
+    def __repr__(self):
+        return '<{}("root") object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def _register_context_menu(self):
+        """
+        Register the default context menus.
+        """
+        if not self._viewer:
+            return
+        menus = self._viewer.context_menus()
+        if menus.get('graph'):
+            self._context_menu['graph'] = NodeGraphMenu(self, menus['graph'])
+        if menus.get('nodes'):
+            self._context_menu['nodes'] = NodesMenu(self, menus['nodes'])
+
+    def _register_builtin_nodes(self):
+        """
+        Register the default builtin nodes to the :meth:`NodeGraph.node_factory`
+        """
+        self.register_node(BackdropNode, alias='Backdrop')
+
+    def _wire_signals(self):
+        """
+        Connect up all the signals and slots here.
+        """
+
+        # internal signals.
+        self._viewer.search_triggered.connect(self._on_search_triggered)
+        self._viewer.connection_sliced.connect(self._on_connection_sliced)
+        self._viewer.connection_changed.connect(self._on_connection_changed)
+        self._viewer.moved_nodes.connect(self._on_nodes_moved)
+        self._viewer.node_double_clicked.connect(self._on_node_double_clicked)
+        self._viewer.node_name_changed.connect(self._on_node_name_changed)
+        self._viewer.node_backdrop_updated.connect(
+            self._on_node_backdrop_updated)
+        self._viewer.insert_node.connect(self._on_insert_node)
+
+        # pass through translated signals.
+        self._viewer.node_selected.connect(self._on_node_selected)
+        self._viewer.node_selection_changed.connect(
+            self._on_node_selection_changed)
+        self._viewer.data_dropped.connect(self._on_node_data_dropped)
+
+    def _on_insert_node(self, pipe, node_id, prev_node_pos):
+        """
+        Slot function triggered when a selected node has collided with a pipe.
+
+        Args:
+            pipe (Pipe): collided pipe item.
+            node_id (str): selected node id to insert.
+            prev_node_pos (dict): previous node position. {NodeItem: [prev_x, prev_y]}
+        """
+        node = self.get_node_by_id(node_id)
+
+        # exclude if not a BaseNode
+        if not isinstance(node, BaseNode):
+            return
+
+        disconnected = [(pipe.input_port, pipe.output_port)]
+        connected = []
+
+        if node.input_ports():
+            connected.append(
+                (pipe.output_port, node.input_ports()[0].view)
+            )
+        if node.output_ports():
+            connected.append(
+                (node.output_ports()[0].view, pipe.input_port)
+            )
+
+        self._undo_stack.beginMacro('inserted node')
+        self._on_connection_changed(disconnected, connected)
+        self._on_nodes_moved(prev_node_pos)
+        self._undo_stack.endMacro()
+
+    def _on_property_bin_changed(self, node_id, prop_name, prop_value):
+        """
+        called when a property widget has changed in a properties bin.
+        (emits the node object, property name, property value)
+
+        Args:
+            node_id (str): node id.
+            prop_name (str): node property name.
+            prop_value (object): python built in types.
+        """
+        node = self.get_node_by_id(node_id)
+
+        # prevent signals from causing a infinite loop.
+        if node.get_property(prop_name) != prop_value:
+            node.set_property(prop_name, prop_value)
+
+    def _on_node_name_changed(self, node_id, name):
+        """
+        called when a node text qgraphics item in the viewer is edited.
+        (sets the name through the node object so undo commands are registered.)
+
+        Args:
+            node_id (str): node id emitted by the viewer.
+            name (str): new node name.
+        """
+        node = self.get_node_by_id(node_id)
+        node.set_name(name)
+
+        # TODO: not sure about redrawing the node here.
+        node.view.draw_node()
+
+    def _on_node_double_clicked(self, node_id):
+        """
+        called when a node in the viewer is double click.
+        (emits the node object when the node is clicked)
+
+        Args:
+            node_id (str): node id emitted by the viewer.
+        """
+        node = self.get_node_by_id(node_id)
+        self.node_double_clicked.emit(node)
+
+    def _on_node_selected(self, node_id):
+        """
+        called when a node in the viewer is selected on left click.
+        (emits the node object when the node is clicked)
+
+        Args:
+            node_id (str): node id emitted by the viewer.
+        """
+        node = self.get_node_by_id(node_id)
+        self.node_selected.emit(node)
+
+    def _on_node_selection_changed(self, sel_ids, desel_ids):
+        """
+        called when the node selection changes in the viewer.
+        (emits node objects <selected nodes>, <deselected nodes>)
+
+        Args:
+            sel_ids (list[str]): new selected node ids.
+            desel_ids (list[str]): deselected node ids.
+        """
+        sel_nodes = [self.get_node_by_id(nid) for nid in sel_ids]
+        unsel_nodes = [self.get_node_by_id(nid) for nid in desel_ids]
+        self.node_selection_changed.emit(sel_nodes, unsel_nodes)
+
+    def _on_node_data_dropped(self, data, pos):
+        """
+        called when data has been dropped on the viewer.
+
+        Example Identifiers:
+            URI = ngqt://path/to/node/session.graph
+            URN = ngqt::node:com.nodes.MyNode1;node:com.nodes.MyNode2
+
+        Args:
+            data (QtCore.QMimeData): mime data.
+            pos (QtCore.QPoint): scene position relative to the drop.
+        """
+        uri_regex = re.compile(r'{}(?:/*)([\w/]+)(\.\w+)'.format(URI_SCHEME))
+        urn_regex = re.compile(r'{}([\w\.:;]+)'.format(URN_SCHEME))
+        if data.hasFormat('text/uri-list'):
+            for url in data.urls():
+                local_file = url.toLocalFile()
+                if local_file:
+                    try:
+                        self.import_session(local_file)
+                        continue
+                    except Exception as e:
+                        pass
+
+                url_str = url.toString()
+                uri_search = uri_regex.search(url_str)
+                urn_search = urn_regex.search(url_str)
+                if uri_search:
+                    path = uri_search.group(1)
+                    ext = uri_search.group(2)
+                    self.import_session('{}{}'.format(path, ext))
+                elif urn_search:
+                    search_str = urn_search.group(1)
+                    node_ids = sorted(re.findall('node:([\w\\.]+)', search_str))
+                    x, y = pos.x(), pos.y()
+                    for node_id in node_ids:
+                        self.create_node(node_id, pos=[x, y])
+                        x += 80
+                        y += 80
+
+    def _on_nodes_moved(self, node_data):
+        """
+        called when selected nodes in the viewer has changed position.
+
+        Args:
+            node_data (dict): {<node_view>: <previous_pos>}
+        """
+        self._undo_stack.beginMacro('move nodes')
+        for node_view, prev_pos in node_data.items():
+            node = self._model.nodes[node_view.id]
+            self._undo_stack.push(NodeMovedCmd(node, node.pos(), prev_pos))
+        self._undo_stack.endMacro()
+
+    def _on_node_backdrop_updated(self, node_id, update_property, value):
+        """
+        called when a BackdropNode is updated.
+
+        Args:
+            node_id (str): backdrop node id.
+            value (str): update type.
+        """
+        backdrop = self.get_node_by_id(node_id)
+        if backdrop and isinstance(backdrop, BackdropNode):
+            backdrop.on_backdrop_updated(update_property, value)
+
+    def _on_search_triggered(self, node_type, pos):
+        """
+        called when the tab search widget is triggered in the viewer.
+
+        Args:
+            node_type (str): node identifier.
+            pos (tuple or list): x, y position for the node.
+        """
+        self.create_node(node_type, pos=pos)
+
+    def _on_connection_changed(self, disconnected, connected):
+        """
+        called when a pipe connection has been changed in the viewer.
+
+        Args:
+            disconnected (list[list[widgets.port.PortItem]):
+                pair list of port view items.
+            connected (list[list[widgets.port.PortItem]]):
+                pair list of port view items.
+        """
+        if not (disconnected or connected):
+            return
+
+        label = 'connect node(s)' if connected else 'disconnect node(s)'
+        ptypes = {PortTypeEnum.IN.value: 'inputs',
+                  PortTypeEnum.OUT.value: 'outputs'}
+
+        self._undo_stack.beginMacro(label)
+        for p1_view, p2_view in disconnected:
+            node1 = self._model.nodes[p1_view.node.id]
+            node2 = self._model.nodes[p2_view.node.id]
+            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]
+            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]
+            port1.disconnect_from(port2)
+        for p1_view, p2_view in connected:
+            node1 = self._model.nodes[p1_view.node.id]
+            node2 = self._model.nodes[p2_view.node.id]
+            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]
+            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]
+            port1.connect_to(port2)
+        self._undo_stack.endMacro()
+
+    def _on_connection_sliced(self, ports):
+        """
+        slot when connection pipes have been sliced.
+
+        Args:
+            ports (list[list[widgets.port.PortItem]]):
+                pair list of port connections (in port, out port)
+        """
+        if not ports:
+            return
+        ptypes = {PortTypeEnum.IN.value: 'inputs',
+                  PortTypeEnum.OUT.value: 'outputs'}
+        self._undo_stack.beginMacro('slice connections')
+        for p1_view, p2_view in ports:
+            node1 = self._model.nodes[p1_view.node.id]
+            node2 = self._model.nodes[p2_view.node.id]
+            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]
+            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]
+            port1.disconnect_from(port2)
+        self._undo_stack.endMacro()
+
+    @property
+    def model(self):
+        """
+        The model used for storing the node graph data.
+
+        Returns:
+            NodeGraphQt.base.model.NodeGraphModel: node graph model.
+        """
+        return self._model
+
+    @property
+    def node_factory(self):
+        """
+        Return the node factory object used by the node graph.
+
+        Returns:
+            NodeFactory: node factory.
+        """
+        return self._node_factory
+
+    @property
+    def widget(self):
+        """
+        The node graph widget for adding into a layout.
+
+        Returns:
+            NodeGraphWidget: node graph widget.
+        """
+        if self._widget is None:
+            self._widget = NodeGraphWidget()
+            self._widget.addTab(self._viewer, 'Node Graph')
+            # hide the close button on the first tab.
+            tab_bar = self._widget.tabBar()
+            for btn_flag in [tab_bar.RightSide, tab_bar.LeftSide]:
+                tab_btn = tab_bar.tabButton(0, btn_flag)
+                if tab_btn:
+                    tab_btn.deleteLater()
+                    tab_bar.setTabButton(0, btn_flag, None)
+            self._widget.tabCloseRequested.connect(
+                self._on_close_sub_graph_tab
+            )
+        return self._widget
+
+    @property
+    def undo_view(self):
+        """
+        Returns node graph undo history list widget.
+
+        Returns:
+            PySide2.QtWidgets.QUndoView: node graph undo view.
+        """
+        if self._undo_view is None:
+            self._undo_view = QtWidgets.QUndoView(self._undo_stack)
+            self._undo_view.setWindowTitle('Undo History')
+        return self._undo_view
+
+    def toggle_node_search(self):
+        """
+        toggle the node search widget visibility.
+        """
+        if self._viewer.underMouse():
+            self._viewer.tab_search_set_nodes(self._node_factory.names)
+            self._viewer.tab_search_toggle()
+
+    def show(self):
+        """
+        Show node graph widget this is just a convenience
+        function to :meth:`NodeGraph.widget.show()`.
+        """
+        self.widget.show()
+
+    def close(self):
+        """
+        Close node graph NodeViewer widget this is just a convenience
+        function to :meth:`NodeGraph.widget.close()`.
+        """
+        self.widget.close()
+
+    def viewer(self):
+        """
+        Returns the internal view interface used by the node graph.
+
+        Warnings:
+            Methods in the ``NodeViewer`` are used internally
+            by ``NodeGraphQt`` components to get the widget use
+            :attr:`NodeGraph.widget`.
+
+        See Also:
+            :attr:`NodeGraph.widget` to add the node graph widget into a
+            :class:`PySide2.QtWidgets.QLayout`.
+
+        Returns:
+            NodeGraphQt.widgets.viewer.NodeViewer: viewer interface.
+        """
+        return self._viewer
+
+    def scene(self):
+        """
+        Returns the ``QGraphicsScene`` object used in the node graph.
+
+        Returns:
+            NodeGraphQt.widgets.scene.NodeScene: node scene.
+        """
+        return self._viewer.scene()
+
+    def background_color(self):
+        """
+        Return the node graph background color.
+
+        Returns:
+            tuple: r, g ,b
+        """
+        return self.scene().background_color
+
+    def set_background_color(self, r, g, b):
+        """
+        Set node graph background color.
+
+        Args:
+            r (int): red value.
+            g (int): green value.
+            b (int): blue value.
+        """
+        self.scene().background_color = (r, g, b)
+        self._viewer.force_update()
+
+    def grid_color(self):
+        """
+        Return the node graph grid color.
+
+        Returns:
+            tuple: r, g ,b
+        """
+        return self.scene().grid_color
+
+    def set_grid_color(self, r, g, b):
+        """
+        Set node graph grid color.
+
+        Args:
+            r (int): red value.
+            g (int): green value.
+            b (int): blue value.
+        """
+        self.scene().grid_color = (r, g, b)
+        self._viewer.force_update()
+
+    def set_grid_mode(self, mode=None):
+        """
+        Set node graph background grid mode.
+
+        (default: :attr:`NodeGraphQt.constants.ViewerEnum.GRID_DISPLAY_LINES`).
+
+        See: :attr:`NodeGraphQt.constants.ViewerEnum`
+
+        .. code-block:: python
+            :linenos:
+
+            graph = NodeGraph()
+            graph.set_grid_mode(ViewerEnum.CURVED.value)
+
+        Args:
+            mode (int): background style.
+        """
+        display_types = [
+            ViewerEnum.GRID_DISPLAY_NONE.value,
+            ViewerEnum.GRID_DISPLAY_DOTS.value,
+            ViewerEnum.GRID_DISPLAY_LINES.value
+        ]
+        if mode not in display_types:
+            mode = ViewerEnum.GRID_DISPLAY_LINES.value
+        self.scene().grid_mode = mode
+        self._viewer.force_update()
+
+    def add_properties_bin(self, prop_bin):
+        """
+        Wire up a properties bin widget to the node graph.
+
+        Args:
+            prop_bin (NodeGraphQt.PropertiesBinWidget): properties widget.
+        """
+        prop_bin.property_changed.connect(self._on_property_bin_changed)
+
+    def undo_stack(self):
+        """
+        Returns the undo stack used in the node graph.
+
+        See Also:
+            :meth:`NodeGraph.begin_undo()`,
+            :meth:`NodeGraph.end_undo()`
+
+        Returns:
+            QtWidgets.QUndoStack: undo stack.
+        """
+        return self._undo_stack
+
+    def clear_undo_stack(self):
+        """
+        Clears the undo stack.
+
+        Note:
+            Convenience function to
+            :meth:`NodeGraph.undo_stack().clear()`
+
+        See Also:
+            :meth:`NodeGraph.begin_undo()`,
+            :meth:`NodeGraph.end_undo()`,
+            :meth:`NodeGraph.undo_stack()`
+        """
+        self._undo_stack.clear()
+
+    def begin_undo(self, name):
+        """
+        Start of an undo block followed by a
+        :meth:`NodeGraph.end_undo()`.
+
+        Args:
+            name (str): name for the undo block.
+        """
+        self._undo_stack.beginMacro(name)
+
+    def end_undo(self):
+        """
+        End of an undo block started by
+        :meth:`NodeGraph.begin_undo()`.
+        """
+        self._undo_stack.endMacro()
+
+    def context_menu(self):
+        """
+        Returns the context menu for the node graph.
+
+        Note:
+            This is a convenience function to
+            :meth:`NodeGraph.get_context_menu`
+            with the arg ``menu="graph"``
+
+        Returns:
+            NodeGraphQt.NodeGraphMenu: context menu object.
+        """
+        return self.get_context_menu('graph')
+
+    def context_nodes_menu(self):
+        """
+        Returns the context menu for the nodes.
+
+        Note:
+            This is a convenience function to
+            :meth:`NodeGraph.get_context_menu`
+            with the arg ``menu="nodes"``
+
+        Returns:
+            NodeGraphQt.NodesMenu: context menu object.
+        """
+        return self.get_context_menu('nodes')
+
+    def get_context_menu(self, menu):
+        """
+        Returns the context menu specified by the name.
+
+        menu types:
+
+            - ``"graph"`` context menu from the node graph.
+            - ``"nodes"`` context menu for the nodes.
+
+        Args:
+            menu (str): menu name.
+
+        Returns:
+            NodeGraphQt.NodeGraphMenu or NodeGraphQt.NodesMenu: context menu object.
+        """
+        return self._context_menu.get(menu)
+
+    def _deserialize_context_menu(self, menu, menu_data):
+        """
+        Populate context menu from a dictionary.
+
+        Args:
+            menu (NodeGraphQt.NodeGraphMenu or NodeGraphQt.NodesMenu):
+                parent context menu.
+            menu_data (list[dict] or dict): serialized menu data.
+        """
+        if not menu:
+            raise ValueError('No context menu named: "{}"'.format(menu))
+
+        import sys
+        import importlib.util
+
+        nodes_menu = self.get_context_menu('nodes')
+
+        def build_menu_command(menu, data):
+            """
+            Create menu command from serialized data.
+
+            Args:
+                menu (NodeGraphQt.NodeGraphMenu or NodeGraphQt.NodesMenu):
+                    menu object.
+                data (dict): serialized menu command data.
+            """
+            full_path = os.path.abspath(data['file'])
+            base_dir, file_name = os.path.split(full_path)
+            base_name = os.path.basename(base_dir)
+            file_name, _ = file_name.split('.')
+
+            mod_name = '{}.{}'.format(base_name, file_name)
+
+            spec = importlib.util.spec_from_file_location(mod_name, full_path)
+            mod = importlib.util.module_from_spec(spec)
+            sys.modules[mod_name] = mod
+            spec.loader.exec_module(mod)
+
+            cmd_func = getattr(mod, data['function_name'])
+            cmd_name = data.get('label') or '<command>'
+            cmd_shortcut = data.get('shortcut')
+            cmd_kwargs = {'func': cmd_func, 'shortcut': cmd_shortcut}
+
+            if menu == nodes_menu and data.get('node_type'):
+                cmd_kwargs['node_type'] = data['node_type']
+
+            menu.add_command(name=cmd_name, **cmd_kwargs)
+
+        if isinstance(menu_data, dict):
+            item_type = menu_data.get('type')
+            if item_type == 'separator':
+                menu.add_separator()
+            elif item_type == 'command':
+                build_menu_command(menu, menu_data)
+            elif item_type == 'menu':
+                sub_menu = menu.add_menu(menu_data['label'])
+                items = menu_data.get('items', [])
+                self._deserialize_context_menu(sub_menu, items)
+        elif isinstance(menu_data, list):
+            for item_data in menu_data:
+                self._deserialize_context_menu(menu, item_data)
+
+    def set_context_menu(self, menu_name, data):
+        """
+        Populate a context menu from serialized data.
+
+        example of serialized menu data:
+
+        .. highlight:: python
+        .. code-block:: python
+
+            [
+                {
+                    'type': 'menu',
+                    'label': 'test sub menu',
+                    'items': [
+                        {
+                            'type': 'command',
+                            'label': 'test command',
+                            'file': '../path/to/my/test_module.py',
+                            'function': 'run_test',
+                            'shortcut': 'Ctrl+b',
+                            'node_type': 'nodeGraphQt.nodes.MyNodeClass'
+                        },
+
+                    ]
+                },
+            ]
+
+        the ``run_test`` example function:
+
+        .. highlight:: python
+        .. code-block:: python
+
+            def run_test(graph):
+                print(graph.selected_nodes())
+
+
+        Args:
+            menu_name (str): name of the parent context menu to populate under.
+            data (dict): serialized menu data.
+        """
+        context_menu = self.get_context_menu(menu_name)
+        self._deserialize_context_menu(context_menu, data)
+
+    def set_context_menu_from_file(self, file_path, menu=None):
+        """
+        Populate a context menu from a serialized json file.
+
+        menu types:
+
+            - ``"graph"`` context menu from the node graph.
+            - ``"nodes"`` context menu for the nodes.
+
+        Args:
+            menu (str): name of the parent context menu to populate under.
+            file_path (str): serialized menu commands json file.
+        """
+        file_path = os.path.abspath(file_path)
+
+        menu = menu or 'graph'
+        if not os.path.isfile(file_path):
+            raise IOError('file doesn\'t exists: "{}"'.format(file_path))
+
+        with open(file_path) as f:
+            data = json.load(f)
+        context_menu = self.get_context_menu(menu)
+        self._deserialize_context_menu(context_menu, data)
+
+    def disable_context_menu(self, disabled=True, name='all'):
+        """
+        Disable/Enable context menus from the node graph.
+
+        menu types:
+
+            - ``"all"`` all context menus from the node graph.
+            - ``"graph"`` context menu from the node graph.
+            - ``"nodes"`` context menu for the nodes.
+
+        Args:
+            disabled (bool): true to enable context menu.
+            name (str): menu name. (default: ``"all"``)
+        """
+        if name == 'all':
+            for k, menu in self._viewer.context_menus().items():
+                menu.setDisabled(disabled)
+                menu.setVisible(not disabled)
+            return
+        menus = self._viewer.context_menus()
+        if menus.get(name):
+            menus[name].setDisabled(disabled)
+            menus[name].setVisible(not disabled)
+
+    def acyclic(self):
+        """
+        Returns true if the current node graph is acyclic.
+
+        See Also:
+            :meth:`NodeGraph.set_acyclic`
+
+        Returns:
+            bool: true if acyclic (default: ``True``).
+        """
+        return self._model.acyclic
+
+    def set_acyclic(self, mode=True):
+        """
+        Enable the node graph to be a acyclic graph. (default: ``True``)
+
+        See Also:
+            :meth:`NodeGraph.acyclic`
+
+        Args:
+            mode (bool): true to enable acyclic.
+        """
+        self._model.acyclic = mode
+        self._viewer.acyclic = self._model.acyclic
+
+    def pipe_collision(self):
+        """
+        Returns if pipe collision is enabled.
+
+        See Also:
+            To enable/disable pipe collision
+            :meth:`NodeGraph.set_pipe_collision`
+
+        Returns:
+            bool: True if pipe collision is enabled.
+        """
+        return self._model.pipe_collision
+
+    def set_pipe_collision(self, mode=True):
+        """
+        Enable/Disable pipe collision.
+
+        When enabled dragging a node over a pipe will allow the node to be
+        inserted as a new connection between the pipe.
+
+        See Also:
+            :meth:`NodeGraph.pipe_collision`
+
+        Args:
+            mode (bool): False to disable pipe collision.
+        """
+        self._model.pipe_collision = mode
+        self._viewer.pipe_collision = self._model.pipe_collision
+
+    def pipe_slicing(self):
+        """
+        Returns if pipe slicing is enabled.
+
+        See Also:
+            To enable/disable pipe slicer
+            :meth:`NodeGraph.set_pipe_slicing`
+
+        Returns:
+            bool: True if pipe slicing is enabled.
+        """
+        return self._model.pipe_slicing
+
+    def set_pipe_slicing(self, mode=True):
+        """
+        Enable/Disable pipe slicer.
+
+        When set to true holding down ``Alt + Shift + LMB Drag`` will allow node
+        pipe connections to be sliced.
+
+        .. image:: _images/slicer.png
+            :width: 400px
+
+        See Also:
+            :meth:`NodeGraph.pipe_slicing`
+
+        Args:
+            mode (bool): False to disable the slicer pipe.
+        """
+        self._model.pipe_slicing = mode
+        self._viewer.pipe_slicing = self._model.pipe_slicing
+
+    def pipe_style(self):
+        """
+        Returns the current pipe layout style.
+
+        See Also:
+            :meth:`NodeGraph.set_pipe_style`
+
+        Returns:
+            int: pipe style value. :attr:`NodeGraphQt.constants.PipeLayoutEnum`
+        """
+        return self._model.pipe_style
+
+    def set_pipe_style(self, style=PipeLayoutEnum.CURVED.value):
+        """
+        Set node graph pipes to be drawn as curved `(default)`, straight or angled.
+
+        .. code-block:: python
+            :linenos:
+
+            graph = NodeGraph()
+            graph.set_pipe_style(PipeLayoutEnum.CURVED.value)
+
+        See: :attr:`NodeGraphQt.constants.PipeLayoutEnum`
+
+        .. image:: _images/pipe_layout_types.gif
+            :width: 80%
+
+
+        Args:
+            style (int): pipe layout style.
+        """
+        pipe_max = max([PipeLayoutEnum.CURVED.value,
+                        PipeLayoutEnum.STRAIGHT.value,
+                        PipeLayoutEnum.ANGLE.value])
+        style = style if 0 <= style <= pipe_max else PipeLayoutEnum.CURVED.value
+        self._model.pipe_style = style
+        self._viewer.set_pipe_layout(style)
+
+    def layout_direction(self):
+        """
+        Return the current node graph layout direction.
+
+        `Implemented in` ``v0.3.0``
+
+        See Also:
+            :meth:`NodeGraph.set_layout_direction`
+
+        Returns:
+            int: layout direction.
+        """
+        return self._model.layout_direction
+
+    def set_layout_direction(self, direction):
+        """
+        Sets the node graph layout direction to horizontal or vertical.
+        This function will also override the layout direction on all
+        nodes in the current node graph.
+
+        `Implemented in` ``v0.3.0``
+
+        **Layout Types:**
+
+        - :attr:`NodeGraphQt.constants.LayoutDirectionEnum.HORIZONTAL`
+        - :attr:`NodeGraphQt.constants.LayoutDirectionEnum.VERTICAL`
+
+        .. image:: _images/layout_direction_switch.gif
+            :width: 300px
+
+        Warnings:
+            This function does not register to the undo stack.
+
+        See Also:
+            :meth:`NodeGraph.layout_direction`,
+            :meth:`NodeObject.set_layout_direction`
+
+        Args:
+            direction (int): layout direction.
+        """
+        direction_types = [e.value for e in LayoutDirectionEnum]
+        if direction not in direction_types:
+            direction = LayoutDirectionEnum.HORIZONTAL.value
+        self._model.layout_direction = direction
+        for node in self.all_nodes():
+            node.set_layout_direction(direction)
+        self._viewer.set_layout_direction(direction)
+
+    def fit_to_selection(self):
+        """
+        Sets the zoom level to fit selected nodes.
+        If no nodes are selected then all nodes in the graph will be framed.
+        """
+        nodes = self.selected_nodes() or self.all_nodes()
+        if not nodes:
+            return
+        self._viewer.zoom_to_nodes([n.view for n in nodes])
+
+    def reset_zoom(self):
+        """
+        Reset the zoom level
+        """
+        self._viewer.reset_zoom()
+
+    def set_zoom(self, zoom=0):
+        """
+        Set the zoom factor of the Node Graph the default is ``0.0``
+
+        Args:
+            zoom (float): zoom factor (max zoom out ``-0.9`` / max zoom in ``2.0``)
+        """
+        self._viewer.set_zoom(zoom)
+
+    def get_zoom(self):
+        """
+        Get the current zoom level of the node graph.
+
+        Returns:
+            float: the current zoom level.
+        """
+        return self._viewer.get_zoom()
+
+    def center_on(self, nodes=None):
+        """
+        Center the node graph on the given nodes or all nodes by default.
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]): a list of nodes.
+        """
+        nodes = nodes or []
+        self._viewer.center_selection([n.view for n in nodes])
+
+    def center_selection(self):
+        """
+        Centers on the current selected nodes.
+        """
+        nodes = self._viewer.selected_nodes()
+        self._viewer.center_selection(nodes)
+
+    def registered_nodes(self):
+        """
+        Return a list of all node types that have been registered.
+
+        See Also:
+            To register a node :meth:`NodeGraph.register_node`
+
+        Returns:
+            list[str]: list of node type identifiers.
+        """
+        return sorted(self._node_factory.nodes.keys())
+
+    def register_node(self, node, alias=None):
+        """
+        Register the node to the :meth:`NodeGraph.node_factory`
+
+        Args:
+            node (NodeGraphQt.NodeObject): node object.
+            alias (str): custom alias name for the node type.
+        """
+        self._node_factory.register_node(node, alias)
+        self._viewer.rebuild_tab_search()
+        self.nodes_registered.emit([node])
+
+    def register_nodes(self, nodes):
+        """
+        Register the nodes to the :meth:`NodeGraph.node_factory`
+
+        Args:
+            nodes (list): list of nodes.
+        """
+        [self._node_factory.register_node(n) for n in nodes]
+        self._viewer.rebuild_tab_search()
+        self.nodes_registered.emit(nodes)
+
+    def create_node(self, node_type, name=None, selected=True, color=None,
+                    text_color=None, pos=None, push_undo=True):
+        """
+        Create a new node in the node graph.
+
+        See Also:
+            To list all node types :meth:`NodeGraph.registered_nodes`
+
+        Args:
+            node_type (str): node instance type.
+            name (str): set name of the node.
+            selected (bool): set created node to be selected.
+            color (tuple or str): node color ``(255, 255, 255)`` or ``"#FFFFFF"``.
+            text_color (tuple or str): text color ``(255, 255, 255)`` or ``"#FFFFFF"``.
+            pos (list[int, int]): initial x, y position for the node (default: ``(0, 0)``).
+            push_undo (bool): register the command to the undo stack. (default: True)
+
+        Returns:
+            BaseNode: the created instance of the node.
+        """
+        node = self._node_factory.create_node_instance(node_type)
+        if node:
+            node._graph = self
+            node.model._graph_model = self.model
+
+            wid_types = node.model.__dict__.pop('_TEMP_property_widget_types')
+            prop_attrs = node.model.__dict__.pop('_TEMP_property_attrs')
+
+            if self.model.get_node_common_properties(node.type_) is None:
+                node_attrs = {node.type_: {
+                    n: {'widget_type': wt} for n, wt in wid_types.items()
+                }}
+                for pname, pattrs in prop_attrs.items():
+                    node_attrs[node.type_][pname].update(pattrs)
+                self.model.set_node_common_properties(node_attrs)
+
+            accept_types = node.model.__dict__.pop(
+                '_TEMP_accept_connection_types'
+            )
+            for ptype, pdata in accept_types.get(node.type_, {}).items():
+                for pname, accept_data in pdata.items():
+                    for accept_ntype, accept_ndata in accept_data.items():
+                        for accept_ptype, accept_pnames in accept_ndata.items():
+                            for accept_pname in accept_pnames:
+                                self._model.add_port_accept_connection_type(
+                                    port_name=pname,
+                                    port_type=ptype,
+                                    node_type=node.type_,
+                                    accept_pname=accept_pname,
+                                    accept_ptype=accept_ptype,
+                                    accept_ntype=accept_ntype
+                                )
+            reject_types = node.model.__dict__.pop(
+                '_TEMP_reject_connection_types'
+            )
+            for ptype, pdata in reject_types.get(node.type_, {}).items():
+                for pname, reject_data in pdata.items():
+                    for reject_ntype, reject_ndata in reject_data.items():
+                        for reject_ptype, reject_pnames in reject_ndata.items():
+                            for reject_pname in reject_pnames:
+                                self._model.add_port_reject_connection_type(
+                                    port_name=pname,
+                                    port_type=ptype,
+                                    node_type=node.type_,
+                                    reject_pname=reject_pname,
+                                    reject_ptype=reject_ptype,
+                                    reject_ntype=reject_ntype
+                                )
+
+            node.NODE_NAME = self.get_unique_name(name or node.NODE_NAME)
+            node.model.name = node.NODE_NAME
+            node.model.selected = selected
+
+            def format_color(clr):
+                if isinstance(clr, str):
+                    clr = clr.strip('#')
+                    return tuple(int(clr[i:i + 2], 16) for i in (0, 2, 4))
+                return clr
+
+            if color:
+                node.model.color = format_color(color)
+            if text_color:
+                node.model.text_color = format_color(text_color)
+            if pos:
+                node.model.pos = [float(pos[0]), float(pos[1])]
+
+            # initial node direction layout.
+            node.model.layout_direction = self.layout_direction()
+
+            node.update()
+
+            undo_cmd = NodeAddedCmd(self, node, node.model.pos)
+            if push_undo:
+                undo_label = 'create node: "{}"'.format(node.NODE_NAME)
+                self._undo_stack.beginMacro(undo_label)
+                for n in self.selected_nodes():
+                    n.set_property('selected', False, push_undo=True)
+                self._undo_stack.push(undo_cmd)
+                self._undo_stack.endMacro()
+            else:
+                for n in self.selected_nodes():
+                    n.set_property('selected', False, push_undo=False)
+                NodeAddedCmd(self, node, node.model.pos).redo()
+
+            self.node_created.emit(node)
+            return node
+        raise NodeCreationError('Can\'t find node: "{}"'.format(node_type))
+
+    def add_node(self, node, pos=None, selected=True, push_undo=True):
+        """
+        Add a node into the node graph.
+        unlike the :meth:`NodeGraph.create_node` function this will not
+        trigger the :attr:`NodeGraph.node_created` signal.
+
+        Args:
+            node (NodeGraphQt.BaseNode): node object.
+            pos (list[float]): node x,y position. (optional)
+            selected (bool): node selected state. (optional)
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        assert isinstance(node, NodeObject), 'node must be a Node instance.'
+
+        wid_types = node.model.__dict__.pop('_TEMP_property_widget_types')
+        prop_attrs = node.model.__dict__.pop('_TEMP_property_attrs')
+
+        if self.model.get_node_common_properties(node.type_) is None:
+            node_attrs = {node.type_: {
+                n: {'widget_type': wt} for n, wt in wid_types.items()
+            }}
+            for pname, pattrs in prop_attrs.items():
+                node_attrs[node.type_][pname].update(pattrs)
+            self.model.set_node_common_properties(node_attrs)
+
+        accept_types = node.model.__dict__.pop(
+            '_TEMP_accept_connection_types'
+        )
+        for ptype, pdata in accept_types.get(node.type_, {}).items():
+            for pname, accept_data in pdata.items():
+                for accept_ntype, accept_ndata in accept_data.items():
+                    for accept_ptype, accept_pnames in accept_ndata.items():
+                        for accept_pname in accept_pnames:
+                            self._model.add_port_accept_connection_type(
+                                port_name=pname,
+                                port_type=ptype,
+                                node_type=node.type_,
+                                accept_pname=accept_pname,
+                                accept_ptype=accept_ptype,
+                                accept_ntype=accept_ntype
+                            )
+        reject_types = node.model.__dict__.pop(
+            '_TEMP_reject_connection_types'
+        )
+        for ptype, pdata in reject_types.get(node.type_, {}).items():
+            for pname, reject_data in pdata.items():
+                for reject_ntype, reject_ndata in reject_data.items():
+                    for reject_ptype, reject_pnames in reject_ndata.items():
+                        for reject_pname in reject_pnames:
+                            self._model.add_port_reject_connection_type(
+                                port_name=pname,
+                                port_type=ptype,
+                                node_type=node.type_,
+                                reject_pname=reject_pname,
+                                reject_ptype=reject_ptype,
+                                reject_ntype=reject_ntype
+                            )
+
+        node._graph = self
+        node.NODE_NAME = self.get_unique_name(node.NODE_NAME)
+        node.model._graph_model = self.model
+        node.model.name = node.NODE_NAME
+
+        # initial node direction layout.
+        node.model.layout_direction = self.layout_direction()
+
+        # update method must be called before it's been added to the viewer.
+        node.update()
+
+        if push_undo:
+            self._undo_stack.beginMacro('add node: "{}"'.format(node.name()))
+            self._undo_stack.push(NodeAddedCmd(self, node, pos))
+            if selected:
+                node.set_selected(True)
+            self._undo_stack.endMacro()
+        else:
+            NodeAddedCmd(self, node, pos).redo()
+
+    def delete_node(self, node, push_undo=True):
+        """
+        Remove the node from the node graph.
+
+        Args:
+            node (NodeGraphQt.BaseNode): node object.
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        assert isinstance(node, NodeObject), \
+            'node must be a instance of a NodeObject.'
+        node_id = node.id
+        if push_undo:
+            self._undo_stack.beginMacro('delete node: "{}"'.format(node.name()))
+
+        if isinstance(node, BaseNode):
+            for p in node.input_ports():
+                if p.locked():
+                    p.set_locked(False,
+                                 connected_ports=False,
+                                 push_undo=push_undo)
+                p.clear_connections(push_undo=push_undo)
+            for p in node.output_ports():
+                if p.locked():
+                    p.set_locked(False,
+                                 connected_ports=False,
+                                 push_undo=push_undo)
+                p.clear_connections(push_undo=push_undo)
+
+        # collapse group node before removing.
+        if isinstance(node, GroupNode) and node.is_expanded:
+            node.collapse()
+
+        if push_undo:
+            self._undo_stack.push(NodeRemovedCmd(self, node))
+            self._undo_stack.endMacro()
+        else:
+            NodeRemovedCmd(self, node).redo()
+
+        self.nodes_deleted.emit([node_id])
+
+    def remove_node(self, node, push_undo=True):
+        """
+        Remove the node from the node graph.
+
+        unlike the :meth:`NodeGraph.delete_node` function this will not
+        trigger the :attr:`NodeGraph.nodes_deleted` signal.
+
+        Args:
+            node (NodeGraphQt.BaseNode): node object.
+            push_undo (bool): register the command to the undo stack. (default: True)
+
+        """
+        assert isinstance(node, NodeObject), 'node must be a Node instance.'
+
+        if push_undo:
+            self._undo_stack.beginMacro('delete node: "{}"'.format(node.name()))
+
+        # collapse group node before removing.
+        if isinstance(node, GroupNode) and node.is_expanded:
+            node.collapse()
+
+        if isinstance(node, BaseNode):
+            for p in node.input_ports():
+                if p.locked():
+                    p.set_locked(False,
+                                 connected_ports=False,
+                                 push_undo=push_undo)
+                p.clear_connections(push_undo=push_undo)
+            for p in node.output_ports():
+                if p.locked():
+                    p.set_locked(False,
+                                 connected_ports=False,
+                                 push_undo=push_undo)
+                p.clear_connections(push_undo=push_undo)
+
+        if push_undo:
+            self._undo_stack.push(NodeRemovedCmd(self, node))
+            self._undo_stack.endMacro()
+        else:
+            NodeRemovedCmd(self, node).redo()
+
+    def delete_nodes(self, nodes, push_undo=True):
+        """
+        Remove a list of specified nodes from the node graph.
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]): list of node instances.
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        if not nodes:
+            return
+        if len(nodes) == 1:
+            self.delete_node(nodes[0], push_undo=push_undo)
+            return
+        node_ids = [n.id for n in nodes]
+        if push_undo:
+            self._undo_stack.beginMacro(
+                'deleted "{}" node(s)'.format(len(nodes))
+            )
+        for node in nodes:
+
+            # collapse group node before removing.
+            if isinstance(node, GroupNode) and node.is_expanded:
+                node.collapse()
+
+            if isinstance(node, BaseNode):
+                for p in node.input_ports():
+                    if p.locked():
+                        p.set_locked(False,
+                                     connected_ports=False,
+                                     push_undo=push_undo)
+                    p.clear_connections(push_undo=push_undo)
+                for p in node.output_ports():
+                    if p.locked():
+                        p.set_locked(False,
+                                     connected_ports=False,
+                                     push_undo=push_undo)
+                    p.clear_connections(push_undo=push_undo)
+            if push_undo:
+                self._undo_stack.push(NodeRemovedCmd(self, node))
+            else:
+                NodeRemovedCmd(self, node).redo()
+        if push_undo:
+            self._undo_stack.endMacro()
+        self.nodes_deleted.emit(node_ids)
+
+    def extract_nodes(self, nodes, push_undo=True, prompt_warning=True):
+        """
+        Extract select nodes from it connections.
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]): list of node instances.
+            push_undo (bool): register the command to the undo stack. (default: True)
+            prompt_warning (bool): prompt warning dialog box.
+        """
+        if not nodes:
+            return
+
+        locked_ports = []
+        base_nodes = []
+        for node in nodes:
+            if not isinstance(node, BaseNode):
+                continue
+
+            for port in node.input_ports() + node.output_ports():
+                if port.locked():
+                    locked_ports.append('{0.node.name}: {0.name}'.format(port))
+
+            base_nodes.append(node)
+
+        if locked_ports:
+            message = (
+                'Selected nodes cannot be extracted because the following '
+                'ports are locked:\n{}'.format('\n'.join(sorted(locked_ports)))
+            )
+            if prompt_warning:
+                self._viewer.message_dialog(message, 'Can\'t Extract Nodes')
+            return
+
+        if push_undo:
+            self._undo_stack.beginMacro(
+                'extracted "{}" node(s)'.format(len(nodes))
+            )
+
+        for node in base_nodes:
+            for port in node.input_ports() + node.output_ports():
+                for connected_port in port.connected_ports():
+                    if connected_port.node() in base_nodes:
+                        continue
+                    port.disconnect_from(connected_port, push_undo=push_undo)
+
+        if push_undo:
+            self._undo_stack.endMacro()
+
+    def all_nodes(self):
+        """
+        Return all nodes in the node graph.
+
+        Returns:
+            list[NodeGraphQt.BaseNode]: list of nodes.
+        """
+        return list(self._model.nodes.values())
+
+    def selected_nodes(self):
+        """
+        Return all selected nodes that are in the node graph.
+
+        Returns:
+            list[NodeGraphQt.BaseNode]: list of nodes.
+        """
+        nodes = []
+        for item in self._viewer.selected_nodes():
+            node = self._model.nodes[item.id]
+            nodes.append(node)
+        return nodes
+
+    def select_all(self):
+        """
+        Select all nodes in the node graph.
+        """
+        self._undo_stack.beginMacro('select all')
+        [node.set_selected(True) for node in self.all_nodes()]
+        self._undo_stack.endMacro()
+
+    def clear_selection(self):
+        """
+        Clears the selection in the node graph.
+        """
+        self._undo_stack.beginMacro('clear selection')
+        [node.set_selected(False) for node in self.all_nodes()]
+        self._undo_stack.endMacro()
+
+    def get_node_by_id(self, node_id=None):
+        """
+        Returns the node from the node id string.
+
+        Args:
+            node_id (str): node id (:attr:`NodeObject.id`)
+
+        Returns:
+            NodeGraphQt.NodeObject: node object.
+        """
+        return self._model.nodes.get(node_id, None)
+
+    def get_node_by_name(self, name):
+        """
+        Returns node that matches the name.
+
+        Args:
+            name (str): name of the node.
+        Returns:
+            NodeGraphQt.NodeObject: node object.
+        """
+        for node_id, node in self._model.nodes.items():
+            if node.name() == name:
+                return node
+
+    def get_nodes_by_type(self, node_type):
+        """
+        Return all nodes by their node type identifier.
+        (see: :attr:`NodeGraphQt.NodeObject.type_`)
+
+        Args:
+            node_type (str): node type identifier.
+
+        Returns:
+            list[NodeGraphQt.NodeObject]: list of nodes.
+        """
+        return [n for n in self._model.nodes.values() if n.type_ == node_type]
+
+    def get_unique_name(self, name):
+        """
+        Creates a unique node name to avoid having nodes with the same name.
+
+        Args:
+            name (str): node name.
+
+        Returns:
+            str: unique node name.
+        """
+        name = ' '.join(name.split())
+        node_names = [n.name() for n in self.all_nodes()]
+        if name not in node_names:
+            return name
+
+        regex = re.compile(r'\w+ (\d+)$')
+        search = regex.search(name)
+        if not search:
+            for x in range(1, len(node_names) + 2):
+                new_name = '{} {}'.format(name, x)
+                if new_name not in node_names:
+                    return new_name
+
+        version = search.group(1)
+        name = name[:len(version) * -1].strip()
+        for x in range(1, len(node_names) + 2):
+            new_name = '{} {}'.format(name, x)
+            if new_name not in node_names:
+                return new_name
+
+    def current_session(self):
+        """
+        Returns the file path to the currently loaded session.
+
+        Returns:
+            str: path to the currently loaded session
+        """
+        return self._model.session
+
+    def clear_session(self):
+        """
+        Clears the current node graph session.
+        """
+        for n in self.all_nodes():
+            if isinstance(n, BaseNode):
+                for p in n.input_ports():
+                    if p.locked():
+                        p.set_locked(False, connected_ports=False)
+                    p.clear_connections()
+                for p in n.output_ports():
+                    if p.locked():
+                        p.set_locked(False, connected_ports=False)
+                    p.clear_connections()
+            self._undo_stack.push(NodeRemovedCmd(self, n))
+        self._undo_stack.clear()
+        self._model.session = ''
+
+    def _serialize(self, nodes):
+        """
+        serialize nodes to a dict.
+        (used internally by the node graph)
+
+        Args:
+            nodes (list[NodeGraphQt.Nodes]): list of node instances.
+
+        Returns:
+            dict: serialized data.
+        """
+        serial_data = {'graph': {}, 'nodes': {}, 'connections': []}
+        nodes_data = {}
+
+        # serialize graph session.
+        serial_data['graph']['layout_direction'] = self.layout_direction()
+        serial_data['graph']['acyclic'] = self.acyclic()
+        serial_data['graph']['pipe_collision'] = self.pipe_collision()
+        serial_data['graph']['pipe_slicing'] = self.pipe_slicing()
+        serial_data['graph']['pipe_style'] = self.pipe_style()
+
+        # connection constrains.
+        serial_data['graph']['accept_connection_types'] = self.model.accept_connection_types
+        serial_data['graph']['reject_connection_types'] = self.model.reject_connection_types
+
+        # serialize nodes.
+        for n in nodes:
+            # update the node model.
+            n.update_model()
+
+            node_dict = n.model.to_dict
+            nodes_data.update(node_dict)
+
+        for n_id, n_data in nodes_data.items():
+            serial_data['nodes'][n_id] = n_data
+
+            # serialize connections
+            inputs = n_data.pop('inputs') if n_data.get('inputs') else {}
+            outputs = n_data.pop('outputs') if n_data.get('outputs') else {}
+
+            for pname, conn_data in inputs.items():
+                for conn_id, prt_names in conn_data.items():
+                    for conn_prt in prt_names:
+                        pipe = {
+                            PortTypeEnum.IN.value: [n_id, pname],
+                            PortTypeEnum.OUT.value: [conn_id, conn_prt]
+                        }
+                        if pipe not in serial_data['connections']:
+                            serial_data['connections'].append(pipe)
+
+            for pname, conn_data in outputs.items():
+                for conn_id, prt_names in conn_data.items():
+                    for conn_prt in prt_names:
+                        pipe = {
+                            PortTypeEnum.OUT.value: [n_id, pname],
+                            PortTypeEnum.IN.value: [conn_id, conn_prt]
+                        }
+                        if pipe not in serial_data['connections']:
+                            serial_data['connections'].append(pipe)
+
+        if not serial_data['connections']:
+            serial_data.pop('connections')
+
+        return serial_data
+
+    def _deserialize(self, data, relative_pos=False, pos=None):
+        """
+        deserialize node data.
+        (used internally by the node graph)
+
+        Args:
+            data (dict): node data.
+            relative_pos (bool): position node relative to the cursor.
+            pos (tuple or list): custom x, y position.
+
+        Returns:
+            list[NodeGraphQt.Nodes]: list of node instances.
+        """
+        # update node graph properties.
+        for attr_name, attr_value in data.get('graph', {}).items():
+            if attr_name == 'layout_direction':
+                self.set_layout_direction(attr_value)
+            elif attr_name == 'acyclic':
+                self.set_acyclic(attr_value)
+            elif attr_name == 'pipe_collision':
+                self.set_pipe_collision(attr_value)
+            elif attr_name == 'pipe_slicing':
+                self.set_pipe_slicing(attr_value)
+            elif attr_name == 'pipe_style':
+                self.set_pipe_style(attr_value)
+
+            # connection constrains.
+            elif attr_name == 'accept_connection_types':
+                self.model.accept_connection_types = attr_value
+            elif attr_name == 'reject_connection_types':
+                self.model.reject_connection_types = attr_value
+
+        # build the nodes.
+        nodes = {}
+        for n_id, n_data in data.get('nodes', {}).items():
+            identifier = n_data['type_']
+            node = self._node_factory.create_node_instance(identifier)
+            if node:
+                node.NODE_NAME = n_data.get('name', node.NODE_NAME)
+                # set properties.
+                for prop in node.model.properties.keys():
+                    if prop in n_data.keys():
+                        node.model.set_property(prop, n_data[prop])
+                # set custom properties.
+                for prop, val in n_data.get('custom', {}).items():
+                    node.model.set_property(prop, val)
+                    if isinstance(node, BaseNode):
+                        if prop in node.view.widgets:
+                            node.view.widgets[prop].set_value(val)
+
+                nodes[n_id] = node
+                self.add_node(node, n_data.get('pos'))
+
+                if n_data.get('port_deletion_allowed', None):
+                    node.set_ports({
+                        'input_ports': n_data['input_ports'],
+                        'output_ports': n_data['output_ports']
+                    })
+
+        # build the connections.
+        for connection in data.get('connections', []):
+            nid, pname = connection.get('in', ('', ''))
+            in_node = nodes.get(nid) or self.get_node_by_id(nid)
+            if not in_node:
+                continue
+            in_port = in_node.inputs().get(pname) if in_node else None
+
+            nid, pname = connection.get('out', ('', ''))
+            out_node = nodes.get(nid) or self.get_node_by_id(nid)
+            if not out_node:
+                continue
+            out_port = out_node.outputs().get(pname) if out_node else None
+
+            if in_port and out_port:
+                # only connect if input port is not connected yet or input port
+                # can have multiple connections.
+                # important when duplicating nodes.
+                allow_connection = any([not in_port.model.connected_ports,
+                                        in_port.model.multi_connection])
+                if allow_connection:
+                    self._undo_stack.push(PortConnectedCmd(in_port, out_port))
+
+                # Run on_input_connected to ensure connections are fully set up after deserialization.
+                in_node.on_input_connected(in_port, out_port)
+
+        node_objs = nodes.values()
+        if relative_pos:
+            self._viewer.move_nodes([n.view for n in node_objs])
+            [setattr(n.model, 'pos', n.view.xy_pos) for n in node_objs]
+        elif pos:
+            self._viewer.move_nodes([n.view for n in node_objs], pos=pos)
+            [setattr(n.model, 'pos', n.view.xy_pos) for n in node_objs]
+
+        return node_objs
+
+    def serialize_session(self):
+        """
+        Serializes the current node graph layout to a dictionary.
+
+        See Also:
+            :meth:`NodeGraph.deserialize_session`,
+            :meth:`NodeGraph.save_session`,
+            :meth:`NodeGraph.load_session`
+
+        Returns:
+            dict: serialized session of the current node layout.
+        """
+        return self._serialize(self.all_nodes())
+
+    def deserialize_session(self, layout_data):
+        """
+        Load node graph session from a dictionary object.
+
+        See Also:
+            :meth:`NodeGraph.serialize_session`,
+            :meth:`NodeGraph.load_session`,
+            :meth:`NodeGraph.save_session`
+
+        Args:
+            layout_data (dict): dictionary object containing a node session.
+        """
+        self.clear_session()
+        self._deserialize(layout_data)
+        self.clear_selection()
+        self._undo_stack.clear()
+
+    def save_session(self, file_path):
+        """
+        Saves the current node graph session layout to a `JSON` formatted file.
+
+        See Also:
+            :meth:`NodeGraph.serialize_session`,
+            :meth:`NodeGraph.deserialize_session`,
+            :meth:`NodeGraph.load_session`,
+
+        Args:
+            file_path (str): path to the saved node layout.
+        """
+        serialized_data = self._serialize(self.all_nodes())
+        file_path = file_path.strip()
+        with open(file_path, 'w') as file_out:
+            json.dump(
+                serialized_data,
+                file_out,
+                indent=2,
+                separators=(',', ':')
+            )
+
+    def load_session(self, file_path):
+        """
+        Load node graph session layout file.
+
+        See Also:
+            :meth:`NodeGraph.deserialize_session`,
+            :meth:`NodeGraph.serialize_session`,
+            :meth:`NodeGraph.save_session`
+
+        Args:
+            file_path (str): path to the serialized layout file.
+        """
+        file_path = file_path.strip()
+        if not os.path.isfile(file_path):
+            raise IOError('file does not exist: {}'.format(file_path))
+
+        self.clear_session()
+        self.import_session(file_path)
+
+    def import_session(self, file_path):
+        """
+        Import node graph session layout file.
+
+        Args:
+            file_path (str): path to the serialized layout file.
+        """
+        file_path = file_path.strip()
+        if not os.path.isfile(file_path):
+            raise IOError('file does not exist: {}'.format(file_path))
+
+        try:
+            with open(file_path) as data_file:
+                layout_data = json.load(data_file)
+        except Exception as e:
+            layout_data = None
+            print('Cannot read data from file.\n{}'.format(e))
+
+        if not layout_data:
+            return
+
+        self._deserialize(layout_data)
+        self._undo_stack.clear()
+        self._model.session = file_path
+
+        self.session_changed.emit(file_path)
+
+    def copy_nodes(self, nodes=None):
+        """
+        Copy nodes to the clipboard.
+
+        See Also:
+            :meth:`NodeGraph.cut_nodes`
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]):
+                list of nodes (default: selected nodes).
+        """
+        nodes = nodes or self.selected_nodes()
+        if not nodes:
+            return False
+        clipboard = QtWidgets.QApplication.clipboard()
+        serial_data = self._serialize(nodes)
+        serial_str = json.dumps(serial_data)
+        if serial_str:
+            clipboard.setText(serial_str)
+            return True
+        return False
+
+    def cut_nodes(self, nodes=None):
+        """
+        Cut nodes to the clipboard.
+
+        Note:
+            This function doesn't not trigger the
+            :attr:`NodeGraph.nodes_deleted` signal.
+
+        See Also:
+            :meth:`NodeGraph.copy_nodes`
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]):
+                list of nodes (default: selected nodes).
+        """
+        nodes = nodes or self.selected_nodes()
+        self.copy_nodes(nodes)
+        self._undo_stack.beginMacro('cut nodes')
+
+        for node in nodes:
+            if isinstance(node, BaseNode):
+                for p in node.input_ports():
+                    if p.locked():
+                        p.set_locked(False,
+                                     connected_ports=False,
+                                     push_undo=True)
+                    p.clear_connections()
+                for p in node.output_ports():
+                    if p.locked():
+                        p.set_locked(False,
+                                     connected_ports=False,
+                                     push_undo=True)
+                    p.clear_connections()
+
+            # collapse group node before removing.
+            if isinstance(node, GroupNode) and node.is_expanded:
+                node.collapse()
+
+            self._undo_stack.push(NodeRemovedCmd(self, node))
+
+        self._undo_stack.endMacro()
+
+    def paste_nodes(self):
+        """
+        Pastes nodes copied from the clipboard.
+        
+        Returns:
+            list[NodeGraphQt.BaseNode]: list of pasted node instances.
+        """
+        clipboard = QtWidgets.QApplication.clipboard()
+        cb_text = clipboard.text()
+        if not cb_text:
+            return
+
+        try:
+            serial_data = json.loads(cb_text)
+        except json.decoder.JSONDecodeError as e:
+            print('ERROR: Can\'t Decode Clipboard Data:\n'
+                  '"{}"'.format(cb_text))
+            return
+
+        self._undo_stack.beginMacro('pasted nodes')
+        self.clear_selection()
+        nodes = self._deserialize(serial_data, relative_pos=True)
+        [n.set_selected(True) for n in nodes]
+        self._undo_stack.endMacro()
+        return nodes
+
+    def duplicate_nodes(self, nodes):
+        """
+        Create duplicate copy from the list of nodes.
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]): list of nodes.
+        Returns:
+            list[NodeGraphQt.BaseNode]: list of duplicated node instances.
+        """
+        if not nodes:
+            return
+
+        self._undo_stack.beginMacro('duplicate nodes')
+
+        self.clear_selection()
+        serial = self._serialize(nodes)
+        new_nodes = self._deserialize(serial)
+        offset = 50
+        for n in new_nodes:
+            x, y = n.pos()
+            n.set_pos(x + offset, y + offset)
+            n.set_property('selected', True)
+
+        self._undo_stack.endMacro()
+        return new_nodes
+
+    def disable_nodes(self, nodes, mode=None):
+        """
+        Toggle nodes to be either disabled or enabled state.
+
+        See Also:
+            :meth:`NodeObject.set_disabled`
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]): list of nodes.
+            mode (bool): (optional) override state of the nodes.
+        """
+        if not nodes:
+            return
+
+        if len(nodes) == 1:
+            if mode is None:
+                mode = not nodes[0].disabled()
+            nodes[0].set_disabled(mode)
+            return
+
+        if mode is not None:
+            states = {False: 'enable', True: 'disable'}
+            text = '{} ({}) nodes'.format(states[mode], len(nodes))
+            self._undo_stack.beginMacro(text)
+            [n.set_disabled(mode) for n in nodes]
+            self._undo_stack.endMacro()
+            return
+
+        text = []
+        enabled_count = len([n for n in nodes if n.disabled()])
+        disabled_count = len([n for n in nodes if not n.disabled()])
+        if enabled_count > 0:
+            text.append('enabled ({})'.format(enabled_count))
+        if disabled_count > 0:
+            text.append('disabled ({})'.format(disabled_count))
+        text = ' / '.join(text) + ' nodes'
+
+        self._undo_stack.beginMacro(text)
+        [n.set_disabled(not n.disabled()) for n in nodes]
+        self._undo_stack.endMacro()
+
+    def use_OpenGL(self):
+        """
+        Set the viewport to use QOpenGLWidget widget to draw the graph.
+        """
+        self._viewer.use_OpenGL()
+
+    # auto layout node functions.
+    # --------------------------------------------------------------------------
+
+    @staticmethod
+    def _update_node_rank(node, nodes_rank, down_stream=True):
+        """
+        Recursive function for updating the node ranking.
+
+        Args:
+            node (NodeGraphQt.BaseNode): node to start from.
+            nodes_rank (dict): node ranking object to be updated.
+            down_stream (bool): true to rank down stram.
+        """
+        if down_stream:
+            node_values = node.connected_output_nodes().values()
+        else:
+            node_values = node.connected_input_nodes().values()
+
+        connected_nodes = set()
+        for nodes in node_values:
+            connected_nodes.update(nodes)
+
+        rank = nodes_rank[node] + 1
+        for n in connected_nodes:
+            if n in nodes_rank:
+                nodes_rank[n] = max(nodes_rank[n], rank)
+            else:
+                nodes_rank[n] = rank
+            NodeGraph._update_node_rank(n, nodes_rank, down_stream)
+
+    @staticmethod
+    def _compute_node_rank(nodes, down_stream=True):
+        """
+        Compute the ranking of nodes.
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]): nodes to start ranking from.
+            down_stream (bool): true to compute down stream.
+
+        Returns:
+            dict: {NodeGraphQt.BaseNode: node_rank, ...}
+        """
+        nodes_rank = {}
+        for node in nodes:
+            nodes_rank[node] = 0
+            NodeGraph._update_node_rank(node, nodes_rank, down_stream)
+        return nodes_rank
+
+    def auto_layout_nodes(self, nodes=None, down_stream=True, start_nodes=None):
+        """
+        Auto layout the nodes in the node graph.
+
+        Note:
+            If the node graph is acyclic then the ``start_nodes`` will need
+            to be specified.
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]): list of nodes to auto layout
+                if nodes is None then all nodes is layed out.
+            down_stream (bool): false to layout up stream.
+            start_nodes (list[NodeGraphQt.BaseNode]):
+                list of nodes to start the auto layout from (Optional).
+        """
+        self.begin_undo('Auto Layout Nodes')
+
+        nodes = nodes or self.all_nodes()
+
+        # filter out the backdrops.
+        backdrops = {
+            n: n.nodes() for n in nodes if isinstance(n, BackdropNode)
+        }
+        filtered_nodes = [n for n in nodes if not isinstance(n, BackdropNode)]
+
+        start_nodes = start_nodes or []
+        if down_stream:
+            start_nodes += [
+                n for n in filtered_nodes
+                if not any(n.connected_input_nodes().values())
+            ]
+        else:
+            start_nodes += [
+                n for n in filtered_nodes
+                if not any(n.connected_output_nodes().values())
+            ]
+
+        if not start_nodes:
+            return
+
+        node_views = [n.view for n in nodes]
+        nodes_center_0 = self.viewer().nodes_rect_center(node_views)
+
+        nodes_rank = NodeGraph._compute_node_rank(start_nodes, down_stream)
+
+        rank_map = {}
+        for node, rank in nodes_rank.items():
+            if rank in rank_map:
+                rank_map[rank].append(node)
+            else:
+                rank_map[rank] = [node]
+
+        node_layout_direction = self._viewer.get_layout_direction()
+
+        if node_layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+            current_x = 0
+            node_height = 120
+            for rank in sorted(range(len(rank_map)), reverse=not down_stream):
+                ranked_nodes = rank_map[rank]
+                max_width = max([node.view.width for node in ranked_nodes])
+                current_x += max_width
+                current_y = 0
+                for idx, node in enumerate(ranked_nodes):
+                    dy = max(node_height, node.view.height)
+                    current_y += 0 if idx == 0 else dy
+                    node.set_pos(current_x, current_y)
+                    current_y += dy * 0.5 + 10
+
+                current_x += max_width * 0.5 + 100
+        elif node_layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            current_y = 0
+            node_width = 250
+            for rank in sorted(range(len(rank_map)), reverse=not down_stream):
+                ranked_nodes = rank_map[rank]
+                max_height = max([node.view.height for node in ranked_nodes])
+                current_y += max_height
+                current_x = 0
+                for idx, node in enumerate(ranked_nodes):
+                    dx = max(node_width, node.view.width)
+                    current_x += 0 if idx == 0 else dx
+                    node.set_pos(current_x, current_y)
+                    current_x += dx * 0.5 + 10
+
+                current_y += max_height * 0.5 + 100
+
+        nodes_center_1 = self.viewer().nodes_rect_center(node_views)
+        dx = nodes_center_0[0] - nodes_center_1[0]
+        dy = nodes_center_0[1] - nodes_center_1[1]
+        [n.set_pos(n.x_pos() + dx, n.y_pos() + dy) for n in nodes]
+
+        # wrap the backdrop nodes.
+        for backdrop, contained_nodes in backdrops.items():
+            backdrop.wrap_nodes(contained_nodes)
+
+        self.end_undo()
+
+    # convenience dialog functions.
+    # --------------------------------------------------------------------------
+
+    def question_dialog(self, text, title='Node Graph'):
+        """
+        Prompts a question open dialog with ``"Yes"`` and ``"No"`` buttons in
+        the node graph.
+
+        Note:
+            Convenience function to
+            :meth:`NodeGraph.viewer().question_dialog`
+
+        Args:
+            text (str): question text.
+            title (str): dialog window title.
+
+        Returns:
+            bool: true if user clicked yes.
+        """
+        return self._viewer.question_dialog(text, title)
+
+    def message_dialog(self, text, title='Node Graph'):
+        """
+        Prompts a file open dialog in the node graph.
+
+        Note:
+            Convenience function to
+            :meth:`NodeGraph.viewer().message_dialog`
+
+        Args:
+            text (str): message text.
+            title (str): dialog window title.
+        """
+        self._viewer.message_dialog(text, title)
+
+    def load_dialog(self, current_dir=None, ext=None):
+        """
+        Prompts a file open dialog in the node graph.
+
+        Note:
+            Convenience function to
+            :meth:`NodeGraph.viewer().load_dialog`
+
+        Args:
+            current_dir (str): path to a directory.
+            ext (str): custom file type extension (default: ``"json"``)
+
+        Returns:
+            str: selected file path.
+        """
+        return self._viewer.load_dialog(current_dir, ext)
+
+    def save_dialog(self, current_dir=None, ext=None):
+        """
+        Prompts a file save dialog in the node graph.
+
+        Note:
+            Convenience function to
+            :meth:`NodeGraph.viewer().save_dialog`
+
+        Args:
+            current_dir (str): path to a directory.
+            ext (str): custom file type extension (default: ``"json"``)
+
+        Returns:
+            str: selected file path.
+        """
+        return self._viewer.save_dialog(current_dir, ext)
+
+    # group node / sub graph.
+    # --------------------------------------------------------------------------
+
+    def _on_close_sub_graph_tab(self, index):
+        """
+        Called when the close button is clicked on a expanded sub graph tab.
+
+        Args:
+            index (int): tab index.
+        """
+        node_id = self.widget.tabToolTip(index)
+        group_node = self.get_node_by_id(node_id)
+        self.collapse_group_node(group_node)
+
+    @property
+    def is_root(self):
+        """
+        Returns if the node graph controller is the root graph.
+
+        Returns:
+            bool: true is the node graph is root.
+        """
+        return True
+
+    @property
+    def sub_graphs(self):
+        """
+        Returns expanded group node sub graphs.
+
+        Returns:
+            dict: {<node_id>: <sub_graph>}
+        """
+        return self._sub_graphs
+
+    # def graph_rect(self):
+    #     """
+    #     Get the graph viewer range (scene size).
+    #
+    #     Returns:
+    #         list[float]: [x, y, width, height].
+    #     """
+    #     return self._viewer.scene_rect()
+    #
+    # def set_graph_rect(self, rect):
+    #     """
+    #     Set the graph viewer range (scene size).
+    #
+    #     Args:
+    #         rect (list[float]): [x, y, width, height].
+    #     """
+    #     self._viewer.set_scene_rect(rect)
+
+    def expand_group_node(self, node):
+        """
+        Expands a group node session in a new tab.
+
+        Args:
+            node (NodeGraphQt.GroupNode): group node.
+
+        Returns:
+            SubGraph: sub node graph used to manage the group node session.
+        """
+        if not isinstance(node, GroupNode):
+            return
+        if self._widget is None:
+            raise RuntimeError('NodeGraph.widget not initialized!')
+
+        self.viewer().clear_key_state()
+        self.viewer().clearFocus()
+
+        if node.id in self._sub_graphs:
+            sub_graph = self._sub_graphs[node.id]
+            tab_index = self._widget.indexOf(sub_graph.widget)
+            self._widget.setCurrentIndex(tab_index)
+            return sub_graph
+
+        # build new sub graph.
+        node_factory = copy.deepcopy(self.node_factory)
+        layout_direction = self.layout_direction()
+        kwargs = {
+            'layout_direction': self.layout_direction(),
+            'pipe_style': self.pipe_style(),
+        }
+        sub_graph = SubGraph(self,
+                             node=node,
+                             node_factory=node_factory,
+                             **kwargs)
+
+        # populate the sub graph.
+        session = node.get_sub_graph_session()
+        sub_graph.deserialize_session(session)
+
+        # store reference to expanded.
+        self._sub_graphs[node.id] = sub_graph
+
+        # open new tab at root level.
+        self.widget.add_viewer(sub_graph.widget, node.name(), node.id)
+
+        return sub_graph
+
+    def collapse_group_node(self, node):
+        """
+        Collapse a group node session tab and it's expanded child sub graphs.
+
+        Args:
+            node (NodeGraphQt.GroupNode): group node.
+        """
+        assert isinstance(node, GroupNode), 'node must be a GroupNode instance.'
+        if self._widget is None:
+            return
+
+        if node.id not in self._sub_graphs:
+            err = '{} sub graph not initialized!'.format(node.name())
+            raise RuntimeError(err)
+
+        sub_graph = self._sub_graphs.pop(node.id)
+        sub_graph.collapse_group_node(node)
+
+        # remove the sub graph tab.
+        self.widget.remove_viewer(sub_graph.widget)
+
+        # TODO: delete sub graph hmm... not sure if I need this here.
+        del sub_graph
+
+
+class SubGraph(NodeGraph):
+    """
+    The ``SubGraph`` class is just like the ``NodeGraph`` but is the main
+    controller for managing the expanded node graph for a
+    :class:`NodeGraphQt.GroupNode`.
+
+    .. inheritance-diagram:: NodeGraphQt.SubGraph
+        :top-classes: PySide2.QtCore.QObject
+
+    .. image:: _images/sub_graph.png
+        :width: 70%
+
+    -
+    """
+
+    def __init__(self, parent=None, node=None, node_factory=None, **kwargs):
+        """
+        Args:
+            parent (object): object parent.
+            node (GroupNode): group node related to this sub graph.
+            node_factory (NodeFactory): override node factory.
+            **kwargs (dict): additional kwargs.
+        """
+        super(SubGraph, self).__init__(
+            parent, node_factory=node_factory, **kwargs
+        )
+
+        # sub graph attributes.
+        self._node = node
+        self._parent_graph = parent
+        self._subviewer_widget = None
+
+        if self._parent_graph.is_root:
+            self._initialized_graphs = [self]
+            self._sub_graphs[self._node.id] = self
+        else:
+            # delete attributes if not top level sub graph.
+            del self._widget
+            del self._sub_graphs
+
+        # clone context menu from the parent node graph.
+        self._clone_context_menu_from_parent()
+
+    def __repr__(self):
+        return '<{}("{}") object at {}>'.format(
+            self.__class__.__name__, self._node.name(), hex(id(self)))
+
+    def _register_builtin_nodes(self):
+        """
+        Register the default builtin nodes to the :meth:`NodeGraph.node_factory`
+        """
+        return
+
+    def _clone_context_menu_from_parent(self):
+        """
+        Clone the context menus from the parent node graph.
+        """
+        graph_menu = self.get_context_menu('graph')
+        parent_menu = self.parent_graph.get_context_menu('graph')
+        parent_viewer = self.parent_graph.viewer()
+        excl_actions = [parent_viewer.qaction_for_undo(),
+                        parent_viewer.qaction_for_redo()]
+
+        def clone_menu(menu, menu_to_clone):
+            """
+            Args:
+                menu (NodeGraphQt.NodeGraphMenu):
+                menu_to_clone (NodeGraphQt.NodeGraphMenu):
+            """
+            sub_items = []
+            for item in menu_to_clone.get_items():
+                if item is None:
+                    menu.add_separator()
+                    continue
+                name = item.name()
+                if isinstance(item, NodeGraphMenu):
+                    sub_menu = menu.add_menu(name)
+                    sub_items.append([sub_menu, item])
+                    continue
+
+                if item in excl_actions:
+                    continue
+
+                menu.add_command(
+                    name,
+                    func=item.slot_function,
+                    shortcut=item.qaction.shortcut()
+                )
+
+            for sub_menu, to_clone in sub_items:
+                clone_menu(sub_menu, to_clone)
+
+        # duplicate the menu items.
+        clone_menu(graph_menu, parent_menu)
+
+    def _build_port_nodes(self):
+        """
+        Build the corresponding input & output nodes from the parent node ports
+        and remove any port nodes that are outdated..
+
+        Returns:
+             tuple(dict, dict): input nodes, output nodes.
+        """
+        node_layout_direction = self._viewer.get_layout_direction()
+
+        # build the parent input port nodes.
+        input_nodes = {n.name(): n for n in
+                       self.get_nodes_by_type(PortInputNode.type_)}
+        for port in self.node.input_ports():
+            if port.name() not in input_nodes:
+                input_node = PortInputNode(parent_port=port)
+                input_node.NODE_NAME = port.name()
+                input_node.model.set_property('name', port.name())
+                input_node.add_output(port.name())
+                input_nodes[port.name()] = input_node
+                self.add_node(input_node, selected=False, push_undo=False)
+                x, y = input_node.pos()
+                if node_layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+                    x -= 100
+                elif node_layout_direction is LayoutDirectionEnum.VERTICAL.value:
+                    y -= 100
+                input_node.set_property('pos', [x, y], push_undo=False)
+
+        # build the parent output port nodes.
+        output_nodes = {n.name(): n for n in
+                        self.get_nodes_by_type(PortOutputNode.type_)}
+        for port in self.node.output_ports():
+            if port.name() not in output_nodes:
+                output_node = PortOutputNode(parent_port=port)
+                output_node.NODE_NAME = port.name()
+                output_node.model.set_property('name', port.name())
+                output_node.add_input(port.name())
+                output_nodes[port.name()] = output_node
+                self.add_node(output_node, selected=False, push_undo=False)
+                x, y = output_node.pos()
+                if node_layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+                    x += 100
+                elif node_layout_direction is LayoutDirectionEnum.VERTICAL.value:
+                    y += 100
+                output_node.set_property('pos', [x, y], push_undo=False)
+
+        return input_nodes, output_nodes
+
+    def _deserialize(self, data, relative_pos=False, pos=None):
+        """
+        deserialize node data.
+        (used internally by the node graph)
+
+        Args:
+            data (dict): node data.
+            relative_pos (bool): position node relative to the cursor.
+            pos (tuple or list): custom x, y position.
+
+        Returns:
+            list[NodeGraphQt.Nodes]: list of node instances.
+        """
+        # update node graph properties.
+        for attr_name, attr_value in data.get('graph', {}).items():
+            if attr_name == 'acyclic':
+                self.set_acyclic(attr_value)
+            elif attr_name == 'pipe_collision':
+                self.set_pipe_collision(attr_value)
+
+        # build the port input & output nodes here.
+        input_nodes, output_nodes = self._build_port_nodes()
+
+        # build the nodes.
+        nodes = {}
+        for n_id, n_data in data.get('nodes', {}).items():
+            identifier = n_data['type_']
+            name = n_data.get('name')
+            if identifier == PortInputNode.type_:
+                nodes[n_id] = input_nodes[name]
+                nodes[n_id].set_pos(*(n_data.get('pos') or [0, 0]))
+                continue
+            elif identifier == PortOutputNode.type_:
+                nodes[n_id] = output_nodes[name]
+                nodes[n_id].set_pos(*(n_data.get('pos') or [0, 0]))
+                continue
+
+            node = self._node_factory.create_node_instance(identifier)
+            if not node:
+                continue
+
+            node.NODE_NAME = name or node.NODE_NAME
+            # set properties.
+            for prop in node.model.properties.keys():
+                if prop in n_data.keys():
+                    node.model.set_property(prop, n_data[prop])
+            # set custom properties.
+            for prop, val in n_data.get('custom', {}).items():
+                node.model.set_property(prop, val)
+
+            nodes[n_id] = node
+            self.add_node(node, n_data.get('pos'))
+
+            if n_data.get('port_deletion_allowed', None):
+                node.set_ports({
+                    'input_ports': n_data['input_ports'],
+                    'output_ports': n_data['output_ports']
+                })
+
+        # build the connections.
+        for connection in data.get('connections', []):
+            nid, pname = connection.get('in', ('', ''))
+            in_node = nodes.get(nid)
+            if not in_node:
+                continue
+            in_port = in_node.inputs().get(pname) if in_node else None
+
+            nid, pname = connection.get('out', ('', ''))
+            out_node = nodes.get(nid)
+            if not out_node:
+                continue
+            out_port = out_node.outputs().get(pname) if out_node else None
+
+            if in_port and out_port:
+                self._undo_stack.push(PortConnectedCmd(in_port, out_port))
+
+        node_objs = list(nodes.values())
+        if relative_pos:
+            self._viewer.move_nodes([n.view for n in node_objs])
+            [setattr(n.model, 'pos', n.view.xy_pos) for n in node_objs]
+        elif pos:
+            self._viewer.move_nodes([n.view for n in node_objs], pos=pos)
+            [setattr(n.model, 'pos', n.view.xy_pos) for n in node_objs]
+
+        return node_objs
+
+    def _on_navigation_changed(self, node_id, rm_node_ids):
+        """
+        Slot when the node navigation widget has changed.
+
+        Args:
+            node_id (str): selected group node id.
+            rm_node_ids (list[str]): list of group node id to remove.
+        """
+        # collapse child sub graphs.
+        for rm_node_id in rm_node_ids:
+            child_node = self.sub_graphs[rm_node_id].node
+            self.collapse_group_node(child_node)
+
+        # show the selected node id sub graph.
+        sub_graph = self.sub_graphs.get(node_id)
+        if sub_graph:
+            self.widget.show_viewer(sub_graph.subviewer_widget)
+            sub_graph.viewer().setFocus()
+
+    @property
+    def is_root(self):
+        """
+        Returns if the node graph controller is the main root graph.
+
+        Returns:
+            bool: true is the node graph is root.
+        """
+        return False
+
+    @property
+    def sub_graphs(self):
+        """
+        Returns expanded group node sub graphs.
+
+        Returns:
+            dict: {<node_id>: <sub_graph>}
+        """
+        if self.parent_graph.is_root:
+            return self._sub_graphs
+        return self.parent_graph.sub_graphs
+
+    @property
+    def initialized_graphs(self):
+        """
+        Returns a list of the sub graphs in the order they were initialized.
+
+        Returns:
+            list[NodeGraphQt.SubGraph]: list of sub graph objects.
+        """
+        if self._parent_graph.is_root:
+            return self._initialized_graphs
+        return self._parent_graph.initialized_graphs
+
+    @property
+    def widget(self):
+        """
+        The sub graph widget from the top most sub graph.
+
+        Returns:
+            SubGraphWidget: node graph widget.
+        """
+        if self.parent_graph.is_root:
+            if self._widget is None:
+                self._widget = SubGraphWidget()
+                self._widget.add_viewer(self.subviewer_widget,
+                                        self.node.name(),
+                                        self.node.id)
+                # connect the navigator widget signals.
+                navigator = self._widget.navigator
+                navigator.navigation_changed.connect(
+                    self._on_navigation_changed
+                )
+            return self._widget
+        return self.parent_graph.widget
+
+    @property
+    def navigation_widget(self):
+        """
+        The navigation widget from the top most sub graph.
+
+        Returns:
+            NodeNavigationWidget: navigation widget.
+        """
+        if self.parent_graph.is_root:
+            return self.widget.navigator
+        return self.parent_graph.navigation_widget
+
+    @property
+    def subviewer_widget(self):
+        """
+        The widget to the sub graph.
+
+        Returns:
+            PySide2.QtWidgets.QWidget: node graph widget.
+        """
+        if self._subviewer_widget is None:
+            self._subviewer_widget = QtWidgets.QWidget()
+            layout = QtWidgets.QVBoxLayout(self._subviewer_widget)
+            layout.setContentsMargins(0, 0, 0, 0)
+            layout.setSpacing(1)
+            layout.addWidget(self._viewer)
+        return self._subviewer_widget
+
+    @property
+    def parent_graph(self):
+        """
+        The parent node graph controller.
+
+        Returns:
+            NodeGraphQt.NodeGraph or NodeGraphQt.SubGraph: parent graph.
+        """
+        return self._parent_graph
+
+    @property
+    def node(self):
+        """
+        Returns the parent node to the sub graph.
+
+        .. image:: _images/group_node.png
+            :width: 250px
+
+        Returns:
+            NodeGraphQt.GroupNode: group node.
+        """
+        return self._node
+
+    def delete_node(self, node, push_undo=True):
+        """
+        Remove the node from the node sub graph.
+
+        Note:
+            :class:`.PortInputNode` & :class:`.PortOutputNode` can't be deleted
+            as they are connected to a :class:`.Port` to remove these port nodes
+            see :meth:`BaseNode.delete_input`, :meth:`BaseNode.delete_output`.
+
+        Args:
+            node (NodeGraphQt.BaseNode): node object.
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        port_nodes = self.get_input_port_nodes() + self.get_output_port_nodes()
+        if node in port_nodes and node.parent_port is not None:
+            # note: port nodes can only be deleted by deleting the parent
+            #       port object.
+            raise NodeDeletionError(
+                '{} can\'t be deleted as it is attached to a port!'.format(node)
+            )
+        super(SubGraph, self).delete_node(node, push_undo=push_undo)
+
+    def delete_nodes(self, nodes, push_undo=True):
+        """
+        Remove a list of specified nodes from the node graph.
+
+        Args:
+            nodes (list[NodeGraphQt.BaseNode]): list of node instances.
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        if not nodes:
+            return
+
+        port_nodes = self.get_input_port_nodes() + self.get_output_port_nodes()
+        for node in nodes:
+            if node in port_nodes and node.parent_port is not None:
+                # note: port nodes can only be deleted by deleting the parent
+                #       port object.
+                raise NodeDeletionError(
+                    '{} can\'t be deleted as it is attached to a port!'
+                    .format(node)
+                )
+
+        super(SubGraph, self).delete_nodes(nodes, push_undo=push_undo)
+
+    def collapse_graph(self, clear_session=True):
+        """
+        Collapse the current sub graph and hide its widget.
+
+        Args:
+            clear_session (bool): clear the current session.
+        """
+        # update the group node.
+        serialized_session = self.serialize_session()
+        self.node.set_sub_graph_session(serialized_session)
+
+        # close the visible widgets.
+        if self._undo_view:
+            self._undo_view.close()
+
+        if self._subviewer_widget:
+            self.widget.hide_viewer(self._subviewer_widget)
+
+        if clear_session:
+            self.clear_session()
+
+    def expand_group_node(self, node):
+        """
+        Expands a group node session in current sub view.
+
+        Args:
+            node (NodeGraphQt.GroupNode): group node.
+
+        Returns:
+            SubGraph: sub node graph used to manage the group node session.
+        """
+        assert isinstance(node, GroupNode), 'node must be a GroupNode instance.'
+        if self._subviewer_widget is None:
+            raise RuntimeError('SubGraph.widget not initialized!')
+
+        self.viewer().clear_key_state()
+        self.viewer().clearFocus()
+
+        if node.id in self.sub_graphs:
+            sub_graph_viewer = self.sub_graphs[node.id].viewer()
+            sub_graph_viewer.setFocus()
+            return self.sub_graphs[node.id]
+
+        # collapse expanded child sub graphs.
+        group_ids = [n.id for n in self.all_nodes() if isinstance(n, GroupNode)]
+        for grp_node_id, grp_sub_graph in self.sub_graphs.items():
+            # collapse current group node.
+            if grp_node_id in group_ids:
+                grp_node = self.get_node_by_id(grp_node_id)
+                self.collapse_group_node(grp_node)
+
+            # close the widgets
+            grp_sub_graph.collapse_graph(clear_session=False)
+
+        # build new sub graph.
+        node_factory = copy.deepcopy(self.node_factory)
+        sub_graph = SubGraph(self,
+                             node=node,
+                             node_factory=node_factory,
+                             layout_direction=self.layout_direction())
+
+        # populate the sub graph.
+        serialized_session = node.get_sub_graph_session()
+        sub_graph.deserialize_session(serialized_session)
+
+        # open new sub graph view.
+        self.widget.add_viewer(sub_graph.subviewer_widget,
+                               node.name(),
+                               node.id)
+
+        # store the references.
+        self.sub_graphs[node.id] = sub_graph
+        self.initialized_graphs.append(sub_graph)
+
+        return sub_graph
+
+    def collapse_group_node(self, node):
+        """
+        Collapse a group node session and it's expanded child sub graphs.
+
+        Args:
+            node (NodeGraphQt.GroupNode): group node.
+        """
+        # update the references.
+        sub_graph = self.sub_graphs.pop(node.id, None)
+        if not sub_graph:
+            return
+
+        init_idx = self.initialized_graphs.index(sub_graph) + 1
+        for sgraph in reversed(self.initialized_graphs[init_idx:]):
+            self.initialized_graphs.remove(sgraph)
+
+        # collapse child sub graphs here.
+        child_ids = [
+            n.id for n in sub_graph.all_nodes() if isinstance(n, GroupNode)
+        ]
+        for child_id in child_ids:
+            if self.sub_graphs.get(child_id):
+                child_graph = self.sub_graphs.pop(child_id)
+                child_graph.collapse_graph(clear_session=True)
+                # remove child viewer widget.
+                self.widget.remove_viewer(child_graph.subviewer_widget)
+
+        sub_graph.collapse_graph(clear_session=True)
+        self.widget.remove_viewer(sub_graph.subviewer_widget)
+
+    def get_input_port_nodes(self):
+        """
+        Return all the port nodes related to the group node input ports.
+
+        .. image:: _images/port_in_node.png
+            :width: 150px
+
+        -
+
+        See Also:
+            :meth:`NodeGraph.get_nodes_by_type`,
+            :meth:`SubGraph.get_output_port_nodes`
+
+        Returns:
+            list[NodeGraphQt.PortInputNode]: input nodes.
+        """
+        return self.get_nodes_by_type(PortInputNode.type_)
+
+    def get_output_port_nodes(self):
+        """
+        Return all the port nodes related to the group node output ports.
+
+        .. image:: _images/port_out_node.png
+            :width: 150px
+
+        -
+
+        See Also:
+            :meth:`NodeGraph.get_nodes_by_type`,
+            :meth:`SubGraph.get_input_port_nodes`
+
+        Returns:
+            list[NodeGraphQt.PortOutputNode]: output nodes.
+        """
+        return self.get_nodes_by_type(PortOutputNode.type_)
+
+    def get_node_by_port(self, port):
+        """
+        Returns the node related to the parent group node port object.
+
+        Args:
+            port (NodeGraphQt.Port): parent node port object.
+
+        Returns:
+            PortInputNode or PortOutputNode: port node object.
+        """
+        func_type = {
+            PortTypeEnum.IN.value: self.get_input_port_nodes,
+            PortTypeEnum.OUT.value: self.get_output_port_nodes
+        }
+        for n in func_type.get(port.type_(), []):
+            if port == n.parent_port:
+                return n
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/base/menu.py` & `NodeGraphQt-0.6.3/NodeGraphQt/base/menu.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,296 +1,296 @@
-#!/usr/bin/python
-import re
-from distutils.version import LooseVersion
-
-from Qt import QtGui, QtCore
-
-from NodeGraphQt.errors import NodeMenuError
-from NodeGraphQt.widgets.actions import BaseMenu, GraphAction, NodeAction
-
-
-class NodeGraphMenu(object):
-    """
-    The ``NodeGraphMenu`` is the main context menu triggered from the node graph.
-
-    .. inheritance-diagram:: NodeGraphQt.NodeGraphMenu
-        :parts: 1
-
-    example for accessing the node graph context menu.
-
-    .. code-block:: python
-        :linenos:
-
-        from NodeGraphQt import NodeGraph
-
-        node_graph = NodeGraph()
-
-        # get the context menu for the node graph.
-        context_menu = node_graph.get_context_menu('graph')
-
-    """
-
-    def __init__(self, graph, qmenu):
-        self._graph = graph
-        self._qmenu = qmenu
-        self._name = qmenu.title()
-        self._menus = {}
-        self._commands = {}
-        self._items = []
-
-    def __repr__(self):
-        return '<{}("{}") object at {}>'.format(
-            self.__class__.__name__, self.name(), hex(id(self)))
-
-    @property
-    def qmenu(self):
-        """
-        The underlying QMenu.
-
-        Returns:
-            BaseMenu: menu object.
-        """
-        return self._qmenu
-
-    def name(self):
-        """
-        Returns the name for the menu.
-
-        Returns:
-            str: label name.
-        """
-        return self._name
-
-    def get_items(self):
-        """
-        Return the menu items in the order they were added.
-
-        Returns:
-            list: current menu items.
-        """
-        return self._items
-
-    def get_menu(self, name):
-        """
-        Returns the child menu by name.
-
-        Args:
-            name (str): name of the menu.
-
-        Returns:
-            NodeGraphQt.NodeGraphMenu: menu item.
-        """
-        self._menus.get(name)
-
-    def get_command(self, name):
-        """
-        Returns the child menu command by name.
-
-        Args:
-            name (str): name of the command.
-
-        Returns:
-            NodeGraphQt.NodeGraphCommand: context menu command.
-        """
-        return self._commands.get(name)
-
-    def add_menu(self, name):
-        """
-        Adds a child menu to the current menu.
-
-        Args:
-            name (str): menu name.
-
-        Returns:
-            NodeGraphQt.NodeGraphMenu: the appended menu item.
-        """
-        if name in self._menus:
-            raise NodeMenuError('menu object "{}" already exists!'.format(name))
-        base_menu = BaseMenu(name, self.qmenu)
-        self.qmenu.addMenu(base_menu)
-        menu = NodeGraphMenu(self._graph, base_menu)
-        self._menus[name] = menu
-        self._items.append(menu)
-        return menu
-
-    def add_command(self, name, func=None, shortcut=None):
-        """
-        Adds a command to the menu.
-
-        Args:
-            name (str): command name.
-            func (function): command function eg. "func(``graph``)".
-            shortcut (str): shortcut key.
-
-        Returns:
-            NodeGraphQt.NodeGraphCommand: the appended command.
-        """
-        action = GraphAction(name, self._graph.viewer())
-        action.graph = self._graph
-        if LooseVersion(QtCore.qVersion()) >= LooseVersion('5.10'):
-            action.setShortcutVisibleInContextMenu(True)
-
-        if isinstance(shortcut, str):
-            search = re.search(r'(?:\.|)QKeySequence\.(\w+)', shortcut)
-            if search:
-                shortcut = getattr(QtGui.QKeySequence, search.group(1))
-            elif all([i in ['Alt', 'Enter'] for i in shortcut.split('+')]):
-                shortcut = QtGui.QKeySequence(
-                    QtCore.Qt.ALT + QtCore.Qt.Key_Return
-                )
-            elif all([i in ['Return', 'Enter'] for i in shortcut.split('+')]):
-                shortcut = QtCore.Qt.Key_Return
-
-        if shortcut:
-            action.setShortcut(shortcut)
-        if func:
-            action.executed.connect(func)
-        self.qmenu.addAction(action)
-        command = NodeGraphCommand(self._graph, action, func)
-        self._commands[name] = command
-        self._items.append(command)
-        return command
-
-    def add_separator(self):
-        """
-        Adds a separator to the menu.
-        """
-        self.qmenu.addSeparator()
-        self._items.append(None)
-
-
-class NodesMenu(NodeGraphMenu):
-    """
-    The ``NodesMenu`` is the context menu triggered from a node.
-
-    .. inheritance-diagram:: NodeGraphQt.NodesMenu
-        :parts: 1
-
-    example for accessing the nodes context menu.
-
-    .. code-block:: python
-        :linenos:
-
-        from NodeGraphQt import NodeGraph
-
-        node_graph = NodeGraph()
-
-        # get the nodes context menu.
-        nodes_menu = node_graph.get_context_menu('nodes')
-    """
-
-    def add_command(self, name, func=None, node_type=None, node_class=None):
-        """
-        Re-implemented to add a command to the specified node type menu.
-
-        Args:
-            name (str): command name.
-            func (function): command function eg. "func(``graph``, ``node``)".
-            node_type (str): specified node type for the command.
-            node_class (class): specified node class for the command.
-
-        Returns:
-            NodeGraphQt.NodeGraphCommand: the appended command.
-        """
-        if not node_type and not node_class:
-            raise NodeMenuError('Node type or Node class not specified!')
-
-        if node_class:
-            node_type = node_class.__name__
-
-        node_menu = self.qmenu.get_menu(node_type)
-        if not node_menu:
-            node_menu = BaseMenu(node_type, self.qmenu)
-
-            if node_class:
-                node_menu.node_class = node_class
-                node_menu.graph = self._graph
-
-            self.qmenu.addMenu(node_menu)
-
-        if not self.qmenu.isEnabled():
-            self.qmenu.setDisabled(False)
-
-        action = NodeAction(name, self._graph.viewer())
-        action.graph = self._graph
-        if LooseVersion(QtCore.qVersion()) >= LooseVersion('5.10'):
-            action.setShortcutVisibleInContextMenu(True)
-        if func:
-            action.executed.connect(func)
-
-        if node_class:
-            node_menus = self.qmenu.get_menus(node_class)
-            if node_menu in node_menus:
-                node_menus.remove(node_menu)
-            for menu in node_menus:
-                menu.addAction(action)
-
-        qaction = node_menu.addAction(action)
-        command = NodeGraphCommand(self._graph, qaction, func)
-        self._commands[name] = command
-        self._items.append(command)
-        return command
-
-
-class NodeGraphCommand(object):
-    """
-    Node graph menu command.
-
-    .. inheritance-diagram:: NodeGraphQt.NodeGraphCommand
-        :parts: 1
-
-    """
-
-    def __init__(self, graph, qaction, func=None):
-        self._graph = graph
-        self._qaction = qaction
-        self._name = qaction.text()
-        self._func = func
-
-    def __repr__(self):
-        return '<{}("{}") object at {}>'.format(
-            self.__class__.__name__, self.name(), hex(id(self)))
-
-    @property
-    def qaction(self):
-        """
-        The underlying qaction.
-
-        Returns:
-            GraphAction: qaction object.
-        """
-        return self._qaction
-
-    @property
-    def slot_function(self):
-        """
-        The function executed by this command.
-
-        Returns:
-            function: command function.
-        """
-        return self._func
-
-    def name(self):
-        """
-        Returns the name for the menu command.
-
-        Returns:
-            str: label name.
-        """
-        return self._name
-
-    def set_shortcut(self, shortcut=None):
-        """
-        Sets the shortcut key combination for the menu command.
-
-        Args:
-            shortcut (str): shortcut key.
-        """
-        shortcut = shortcut or QtGui.QKeySequence()
-        self.qaction.setShortcut(shortcut)
-
-    def run_command(self):
-        """
-        execute the menu command.
-        """
-        self.qaction.trigger()
+#!/usr/bin/python
+import re
+from distutils.version import LooseVersion
+
+from Qt import QtGui, QtCore
+
+from NodeGraphQt.errors import NodeMenuError
+from NodeGraphQt.widgets.actions import BaseMenu, GraphAction, NodeAction
+
+
+class NodeGraphMenu(object):
+    """
+    The ``NodeGraphMenu`` is the main context menu triggered from the node graph.
+
+    .. inheritance-diagram:: NodeGraphQt.NodeGraphMenu
+        :parts: 1
+
+    example for accessing the node graph context menu.
+
+    .. code-block:: python
+        :linenos:
+
+        from NodeGraphQt import NodeGraph
+
+        node_graph = NodeGraph()
+
+        # get the context menu for the node graph.
+        context_menu = node_graph.get_context_menu('graph')
+
+    """
+
+    def __init__(self, graph, qmenu):
+        self._graph = graph
+        self._qmenu = qmenu
+        self._name = qmenu.title()
+        self._menus = {}
+        self._commands = {}
+        self._items = []
+
+    def __repr__(self):
+        return '<{}("{}") object at {}>'.format(
+            self.__class__.__name__, self.name(), hex(id(self)))
+
+    @property
+    def qmenu(self):
+        """
+        The underlying QMenu.
+
+        Returns:
+            BaseMenu: menu object.
+        """
+        return self._qmenu
+
+    def name(self):
+        """
+        Returns the name for the menu.
+
+        Returns:
+            str: label name.
+        """
+        return self._name
+
+    def get_items(self):
+        """
+        Return the menu items in the order they were added.
+
+        Returns:
+            list: current menu items.
+        """
+        return self._items
+
+    def get_menu(self, name):
+        """
+        Returns the child menu by name.
+
+        Args:
+            name (str): name of the menu.
+
+        Returns:
+            NodeGraphQt.NodeGraphMenu: menu item.
+        """
+        self._menus.get(name)
+
+    def get_command(self, name):
+        """
+        Returns the child menu command by name.
+
+        Args:
+            name (str): name of the command.
+
+        Returns:
+            NodeGraphQt.NodeGraphCommand: context menu command.
+        """
+        return self._commands.get(name)
+
+    def add_menu(self, name):
+        """
+        Adds a child menu to the current menu.
+
+        Args:
+            name (str): menu name.
+
+        Returns:
+            NodeGraphQt.NodeGraphMenu: the appended menu item.
+        """
+        if name in self._menus:
+            raise NodeMenuError('menu object "{}" already exists!'.format(name))
+        base_menu = BaseMenu(name, self.qmenu)
+        self.qmenu.addMenu(base_menu)
+        menu = NodeGraphMenu(self._graph, base_menu)
+        self._menus[name] = menu
+        self._items.append(menu)
+        return menu
+
+    def add_command(self, name, func=None, shortcut=None):
+        """
+        Adds a command to the menu.
+
+        Args:
+            name (str): command name.
+            func (function): command function eg. "func(``graph``)".
+            shortcut (str): shortcut key.
+
+        Returns:
+            NodeGraphQt.NodeGraphCommand: the appended command.
+        """
+        action = GraphAction(name, self._graph.viewer())
+        action.graph = self._graph
+        if LooseVersion(QtCore.qVersion()) >= LooseVersion('5.10'):
+            action.setShortcutVisibleInContextMenu(True)
+
+        if isinstance(shortcut, str):
+            search = re.search(r'(?:\.|)QKeySequence\.(\w+)', shortcut)
+            if search:
+                shortcut = getattr(QtGui.QKeySequence, search.group(1))
+            elif all([i in ['Alt', 'Enter'] for i in shortcut.split('+')]):
+                shortcut = QtGui.QKeySequence(
+                    QtCore.Qt.ALT + QtCore.Qt.Key_Return
+                )
+            elif all([i in ['Return', 'Enter'] for i in shortcut.split('+')]):
+                shortcut = QtCore.Qt.Key_Return
+
+        if shortcut:
+            action.setShortcut(shortcut)
+        if func:
+            action.executed.connect(func)
+        self.qmenu.addAction(action)
+        command = NodeGraphCommand(self._graph, action, func)
+        self._commands[name] = command
+        self._items.append(command)
+        return command
+
+    def add_separator(self):
+        """
+        Adds a separator to the menu.
+        """
+        self.qmenu.addSeparator()
+        self._items.append(None)
+
+
+class NodesMenu(NodeGraphMenu):
+    """
+    The ``NodesMenu`` is the context menu triggered from a node.
+
+    .. inheritance-diagram:: NodeGraphQt.NodesMenu
+        :parts: 1
+
+    example for accessing the nodes context menu.
+
+    .. code-block:: python
+        :linenos:
+
+        from NodeGraphQt import NodeGraph
+
+        node_graph = NodeGraph()
+
+        # get the nodes context menu.
+        nodes_menu = node_graph.get_context_menu('nodes')
+    """
+
+    def add_command(self, name, func=None, node_type=None, node_class=None):
+        """
+        Re-implemented to add a command to the specified node type menu.
+
+        Args:
+            name (str): command name.
+            func (function): command function eg. "func(``graph``, ``node``)".
+            node_type (str): specified node type for the command.
+            node_class (class): specified node class for the command.
+
+        Returns:
+            NodeGraphQt.NodeGraphCommand: the appended command.
+        """
+        if not node_type and not node_class:
+            raise NodeMenuError('Node type or Node class not specified!')
+
+        if node_class:
+            node_type = node_class.__name__
+
+        node_menu = self.qmenu.get_menu(node_type)
+        if not node_menu:
+            node_menu = BaseMenu(node_type, self.qmenu)
+
+            if node_class:
+                node_menu.node_class = node_class
+                node_menu.graph = self._graph
+
+            self.qmenu.addMenu(node_menu)
+
+        if not self.qmenu.isEnabled():
+            self.qmenu.setDisabled(False)
+
+        action = NodeAction(name, self._graph.viewer())
+        action.graph = self._graph
+        if LooseVersion(QtCore.qVersion()) >= LooseVersion('5.10'):
+            action.setShortcutVisibleInContextMenu(True)
+        if func:
+            action.executed.connect(func)
+
+        if node_class:
+            node_menus = self.qmenu.get_menus(node_class)
+            if node_menu in node_menus:
+                node_menus.remove(node_menu)
+            for menu in node_menus:
+                menu.addAction(action)
+
+        qaction = node_menu.addAction(action)
+        command = NodeGraphCommand(self._graph, qaction, func)
+        self._commands[name] = command
+        self._items.append(command)
+        return command
+
+
+class NodeGraphCommand(object):
+    """
+    Node graph menu command.
+
+    .. inheritance-diagram:: NodeGraphQt.NodeGraphCommand
+        :parts: 1
+
+    """
+
+    def __init__(self, graph, qaction, func=None):
+        self._graph = graph
+        self._qaction = qaction
+        self._name = qaction.text()
+        self._func = func
+
+    def __repr__(self):
+        return '<{}("{}") object at {}>'.format(
+            self.__class__.__name__, self.name(), hex(id(self)))
+
+    @property
+    def qaction(self):
+        """
+        The underlying qaction.
+
+        Returns:
+            GraphAction: qaction object.
+        """
+        return self._qaction
+
+    @property
+    def slot_function(self):
+        """
+        The function executed by this command.
+
+        Returns:
+            function: command function.
+        """
+        return self._func
+
+    def name(self):
+        """
+        Returns the name for the menu command.
+
+        Returns:
+            str: label name.
+        """
+        return self._name
+
+    def set_shortcut(self, shortcut=None):
+        """
+        Sets the shortcut key combination for the menu command.
+
+        Args:
+            shortcut (str): shortcut key.
+        """
+        shortcut = shortcut or QtGui.QKeySequence()
+        self.qaction.setShortcut(shortcut)
+
+    def run_command(self):
+        """
+        execute the menu command.
+        """
+        self.qaction.trigger()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/base/model.py` & `NodeGraphQt-0.6.3/NodeGraphQt/base/model.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,621 +1,621 @@
-#!/usr/bin/python
-import json
-from collections import defaultdict
-
-from NodeGraphQt.constants import (
-    LayoutDirectionEnum,
-    NodePropWidgetEnum,
-    PipeLayoutEnum
-)
-from NodeGraphQt.errors import NodePropertyError
-
-
-class PortModel(object):
-    """
-    Data dump for a port object.
-    """
-
-    def __init__(self, node):
-        self.node = node
-        self.type_ = ''
-        self.name = 'port'
-        self.display_name = True
-        self.multi_connection = False
-        self.visible = True
-        self.locked = False
-        self.connected_ports = defaultdict(list)
-
-    def __repr__(self):
-        return '<{}(\'{}\') object at {}>'.format(
-            self.__class__.__name__, self.name, hex(id(self)))
-
-    @property
-    def to_dict(self):
-        """
-        serialize model information to a dictionary.
-
-        Returns:
-            dict: node port dictionary eg.
-                {
-                    'type': 'in',
-                    'name': 'port',
-                    'display_name': True,
-                    'multi_connection': False,
-                    'visible': True,
-                    'locked': False,
-                    'connected_ports': {<node_id>: [<port_name>, <port_name>]}
-                }
-        """
-        props = self.__dict__.copy()
-        props.pop('node')
-        props['connected_ports'] = dict(props.pop('connected_ports'))
-        return props
-
-
-class NodeModel(object):
-    """
-    Data dump for a node object.
-    """
-
-    def __init__(self):
-        self.type_ = None
-        self.id = hex(id(self))
-        self.icon = None
-        self.name = 'node'
-        self.color = (13, 18, 23, 255)
-        self.border_color = (74, 84, 85, 255)
-        self.text_color = (255, 255, 255, 180)
-        self.disabled = False
-        self.selected = False
-        self.visible = True
-        self.width = 100.0
-        self.height = 80.0
-        self.pos = [0.0, 0.0]
-        self.layout_direction = LayoutDirectionEnum.HORIZONTAL.value
-
-        # BaseNode attrs.
-        self.inputs = {}
-        self.outputs = {}
-        self.port_deletion_allowed = False
-
-        # GroupNode attrs.
-        self.subgraph_session = {}
-
-        # Custom
-        self._custom_prop = {}
-
-        # node graph model set at node added time.
-        self._graph_model = None
-
-        # store the property attributes.
-        # (deleted when node is added to the graph)
-        self._TEMP_property_attrs = {}
-
-        # temp store the property widget types.
-        # (deleted when node is added to the graph)
-        self._TEMP_property_widget_types = {
-            'type_': NodePropWidgetEnum.QLABEL.value,
-            'id': NodePropWidgetEnum.QLABEL.value,
-            'icon': NodePropWidgetEnum.HIDDEN.value,
-            'name': NodePropWidgetEnum.QLINE_EDIT.value,
-            'color': NodePropWidgetEnum.COLOR_PICKER.value,
-            'border_color': NodePropWidgetEnum.HIDDEN.value,
-            'text_color': NodePropWidgetEnum.COLOR_PICKER.value,
-            'disabled': NodePropWidgetEnum.QCHECK_BOX.value,
-            'selected': NodePropWidgetEnum.HIDDEN.value,
-            'width': NodePropWidgetEnum.HIDDEN.value,
-            'height': NodePropWidgetEnum.HIDDEN.value,
-            'pos': NodePropWidgetEnum.HIDDEN.value,
-            'layout_direction': NodePropWidgetEnum.HIDDEN.value,
-            'inputs': NodePropWidgetEnum.HIDDEN.value,
-            'outputs': NodePropWidgetEnum.HIDDEN.value,
-        }
-
-        # temp store connection constrains.
-        # (deleted when node is added to the graph)
-        self._TEMP_accept_connection_types = {}
-        self._TEMP_reject_connection_types = {}
-
-    def __repr__(self):
-        return '<{}(\'{}\') object at {}>'.format(
-            self.__class__.__name__, self.name, self.id)
-
-    def add_property(self, name, value, items=None, range=None,
-                     widget_type=None, tab=None):
-        """
-        add custom property or raises an error if the property name is already
-        taken.
-
-        Args:
-            name (str): name of the property.
-            value (object): data.
-            items (list[str]): items used by widget type NODE_PROP_QCOMBO.
-            range (tuple): min, max values used by NODE_PROP_SLIDER.
-            widget_type (int): widget type flag.
-            tab (str): widget tab name.
-        """
-        widget_type = widget_type or NodePropWidgetEnum.HIDDEN.value
-        tab = tab or 'Properties'
-
-        if name in self.properties.keys():
-            raise NodePropertyError(
-                '"{}" reserved for default property.'.format(name))
-        if name in self._custom_prop.keys():
-            raise NodePropertyError(
-                '"{}" property already exists.'.format(name))
-
-        self._custom_prop[name] = value
-
-        if self._graph_model is None:
-            self._TEMP_property_widget_types[name] = widget_type
-            self._TEMP_property_attrs[name] = {'tab': tab}
-            if items:
-                self._TEMP_property_attrs[name]['items'] = items
-            if range:
-                self._TEMP_property_attrs[name]['range'] = range
-        else:
-            attrs = {
-                self.type_: {
-                    name: {
-                        'widget_type': widget_type,
-                        'tab': tab
-                    }
-                }
-            }
-            if items:
-                attrs[self.type_][name]['items'] = items
-            if range:
-                attrs[self.type_][name]['range'] = range
-            self._graph_model.set_node_common_properties(attrs)
-
-    def set_property(self, name, value):
-        """
-        Args:
-            name (str): property name.
-            value (object): property value.
-        """
-        if name in self.properties.keys():
-            setattr(self, name, value)
-        elif name in self._custom_prop.keys():
-            self._custom_prop[name] = value
-        else:
-            raise NodePropertyError('No property "{}"'.format(name))
-
-    def get_property(self, name):
-        """
-        Args:
-            name (str): property name.
-
-        Returns:
-            object: property value.
-        """
-        if name in self.properties.keys():
-            return self.properties[name]
-        return self._custom_prop.get(name)
-
-    def is_custom_property(self, name):
-        """
-        Args:
-            name (str): property name.
-
-        Returns:
-            bool: true if custom property.
-        """
-        return name in self._custom_prop
-
-    def get_widget_type(self, name):
-        """
-        Args:
-            name (str): property name.
-
-        Returns:
-            int: node property widget type.
-        """
-        model = self._graph_model
-        if model is None:
-            return self._TEMP_property_widget_types.get(name)
-        return model.get_node_common_properties(self.type_)[name]['widget_type']
-
-    def get_tab_name(self, name):
-        """
-        Args:
-            name (str): property name.
-
-        Returns:
-            str: name of the tab for the properties bin.
-        """
-        model = self._graph_model
-        if model is None:
-            attrs = self._TEMP_property_attrs.get(name)
-            if attrs:
-                return attrs[name].get('tab')
-            return
-        return model.get_node_common_properties(self.type_)[name]['tab']
-
-    def add_port_accept_connection_type(
-            self,
-            port_name, port_type, node_type,
-            accept_pname, accept_ptype, accept_ntype
-    ):
-        """
-        Convenience function for adding to the "accept_connection_types" dict.
-        If the node graph model is unavailable yet then we store it to a
-        temp var that gets deleted.
-
-        Args:
-            port_name (str): current port name.
-            port_type (str): current port type.
-            node_type (str): current port node type.
-            accept_pname (str):port name to accept.
-            accept_ptype (str): port type accept.
-            accept_ntype (str):port node type to accept.
-        """
-        model = self._graph_model
-        if model:
-            model.add_port_accept_connection_type(
-                port_name, port_type, node_type,
-                accept_pname, accept_ptype, accept_ntype
-            )
-            return
-
-        connection_data = self._TEMP_accept_connection_types
-        keys = [node_type, port_type, port_name, accept_ntype]
-        for key in keys:
-            if key not in connection_data.keys():
-                connection_data[key] = {}
-            connection_data = connection_data[key]
-
-        if accept_ptype not in connection_data:
-            connection_data[accept_ptype] = set([accept_pname])
-        else:
-            connection_data[accept_ptype].add(accept_pname)
-
-    def add_port_reject_connection_type(
-        self,
-        port_name, port_type, node_type,
-        reject_pname, reject_ptype, reject_ntype
-    ):
-        """
-        Convenience function for adding to the "reject_connection_types" dict.
-        If the node graph model is unavailable yet then we store it to a
-        temp var that gets deleted.
-
-        Args:
-            port_name (str): current port name.
-            port_type (str): current port type.
-            node_type (str): current port node type.
-            reject_pname:
-            reject_ptype:
-            reject_ntype:
-
-        Returns:
-
-        """
-        model = self._graph_model
-        if model:
-            model.add_port_reject_connection_type(
-                port_name, port_type, node_type,
-                reject_pname, reject_ptype, reject_ntype
-            )
-            return
-
-        connection_data = self._TEMP_reject_connection_types
-        keys = [node_type, port_type, port_name, reject_ntype]
-        for key in keys:
-            if key not in connection_data.keys():
-                connection_data[key] = {}
-            connection_data = connection_data[key]
-
-        if reject_ptype not in connection_data:
-            connection_data[reject_ptype] = set([reject_pname])
-        else:
-            connection_data[reject_ptype].add(reject_pname)
-
-    @property
-    def properties(self):
-        """
-        return all default node properties.
-
-        Returns:
-            dict: default node properties.
-        """
-        props = self.__dict__.copy()
-        exclude = ['_custom_prop',
-                   '_graph_model',
-                   '_TEMP_property_attrs',
-                   '_TEMP_property_widget_types']
-        [props.pop(i) for i in exclude if i in props.keys()]
-        return props
-
-    @property
-    def custom_properties(self):
-        """
-        return all custom properties specified by the user.
-
-        Returns:
-            dict: user defined properties.
-        """
-        return self._custom_prop
-
-    @property
-    def to_dict(self):
-        """
-        serialize model information to a dictionary.
-
-        Returns:
-            dict: node id as the key and properties as the values eg.
-                {'0x106cf75a8': {
-                    'name': 'foo node',
-                    'color': (48, 58, 69, 255),
-                    'border_color': (85, 100, 100, 255),
-                    'text_color': (255, 255, 255, 180),
-                    'type_': 'io.github.jchanvfx.FooNode',
-                    'selected': False,
-                    'disabled': False,
-                    'visible': True,
-                    'width': 0.0,
-                    'height: 0.0,
-                    'pos': (0.0, 0.0),
-                    'layout_direction': 0,
-                    'custom': {},
-                    'inputs': {
-                        <port_name>: {<node_id>: [<port_name>, <port_name>]}
-                    },
-                    'outputs': {
-                        <port_name>: {<node_id>: [<port_name>, <port_name>]}
-                    },
-                    'input_ports': [<port_name>, <port_name>],
-                    'output_ports': [<port_name>, <port_name>],
-                    },
-                    subgraph_session: <sub graph session data>
-                }
-        """
-        node_dict = self.__dict__.copy()
-        node_id = node_dict.pop('id')
-
-        inputs = {}
-        outputs = {}
-        input_ports = []
-        output_ports = []
-        for name, model in node_dict.pop('inputs').items():
-            if self.port_deletion_allowed:
-                input_ports.append({
-                    'name': name,
-                    'multi_connection': model.multi_connection,
-                    'display_name': model.display_name,
-                })
-            connected_ports = model.to_dict['connected_ports']
-            if connected_ports:
-                inputs[name] = connected_ports
-        for name, model in node_dict.pop('outputs').items():
-            if self.port_deletion_allowed:
-                output_ports.append({
-                    'name': name,
-                    'multi_connection': model.multi_connection,
-                    'display_name': model.display_name,
-                })
-            connected_ports = model.to_dict['connected_ports']
-            if connected_ports:
-                outputs[name] = connected_ports
-        if inputs:
-            node_dict['inputs'] = inputs
-        if outputs:
-            node_dict['outputs'] = outputs
-
-        if self.port_deletion_allowed:
-            node_dict['input_ports'] = input_ports
-            node_dict['output_ports'] = output_ports
-
-        if self.subgraph_session:
-            node_dict['subgraph_session'] = self.subgraph_session
-
-        custom_props = node_dict.pop('_custom_prop', {})
-        if custom_props:
-            node_dict['custom'] = custom_props
-
-        exclude = ['_graph_model',
-                   '_TEMP_property_attrs',
-                   '_TEMP_property_widget_types']
-        [node_dict.pop(i) for i in exclude if i in node_dict.keys()]
-
-        return {node_id: node_dict}
-
-    @property
-    def serial(self):
-        """
-        Serialize model information to a string.
-
-        Returns:
-            str: serialized JSON string.
-        """
-        model_dict = self.to_dict
-        return json.dumps(model_dict)
-
-
-class NodeGraphModel(object):
-    """
-    Data dump for a node graph.
-    """
-
-    def __init__(self):
-        self.__common_node_props = {}
-
-        self.accept_connection_types = {}
-        self.reject_connection_types = {}
-
-        self.nodes = {}
-        self.session = ''
-        self.acyclic = True
-        self.pipe_collision = False
-        self.pipe_slicing = True
-        self.pipe_style = PipeLayoutEnum.CURVED.value
-        self.layout_direction = LayoutDirectionEnum.HORIZONTAL.value
-
-    def common_properties(self):
-        """
-        Return all common node properties.
-
-        Returns:
-            dict: common node properties.
-                eg.
-                    {'nodeGraphQt.nodes.FooNode': {
-                        'my_property': {
-                            'widget_type': 0,
-                            'tab': 'Properties',
-                            'items': ['foo', 'bar', 'test'],
-                            'range': (0, 100)
-                            }
-                        }
-                    }
-        """
-        return self.__common_node_props
-
-    def set_node_common_properties(self, attrs):
-        """
-        Store common node properties.
-
-        Args:
-            attrs (dict): common node properties.
-                eg.
-                    {'nodeGraphQt.nodes.FooNode': {
-                        'my_property': {
-                            'widget_type': 0,
-                            'tab': 'Properties',
-                            'items': ['foo', 'bar', 'test'],
-                            'range': (0, 100)
-                            }
-                        }
-                    }
-        """
-        for node_type in attrs.keys():
-            node_props = attrs[node_type]
-
-            if node_type not in self.__common_node_props.keys():
-                self.__common_node_props[node_type] = node_props
-                continue
-
-            for prop_name, prop_attrs in node_props.items():
-                common_props = self.__common_node_props[node_type]
-                if prop_name not in common_props.keys():
-                    common_props[prop_name] = prop_attrs
-                    continue
-                common_props[prop_name].update(prop_attrs)
-
-    def get_node_common_properties(self, node_type):
-        """
-        Return all the common properties for a registered node.
-
-        Args:
-            node_type (str): node type.
-
-        Returns:
-            dict: node common properties.
-        """
-        return self.__common_node_props.get(node_type)
-
-    def add_port_accept_connection_type(
-            self,
-            port_name, port_type, node_type,
-            accept_pname, accept_ptype, accept_ntype
-    ):
-        """
-        Convenience function for adding to the "accept_connection_types" dict.
-
-        Args:
-            port_name (str): current port name.
-            port_type (str): current port type.
-            node_type (str): current port node type.
-            accept_pname (str):port name to accept.
-            accept_ptype (str): port type accept.
-            accept_ntype (str):port node type to accept.
-        """
-        connection_data = self.accept_connection_types
-        keys = [node_type, port_type, port_name, accept_ntype]
-        for key in keys:
-            if key not in connection_data.keys():
-                connection_data[key] = {}
-            connection_data = connection_data[key]
-
-        if accept_ptype not in connection_data:
-            connection_data[accept_ptype] = set([accept_pname])
-        else:
-            connection_data[accept_ptype].add(accept_pname)
-
-    def port_accept_connection_types(self, node_type, port_type, port_name):
-        """
-        Convenience function for getting the accepted port types from the
-        "accept_connection_types" dict.
-
-        Args:
-            node_type (str):
-            port_type (str):
-            port_name (str):
-
-        Returns:
-            dict: {<node_type>: {<port_type>: [<port_name>]}}
-        """
-        data = self.accept_connection_types.get(node_type) or {}
-        accepted_types = data.get(port_type) or {}
-        return accepted_types.get(port_name) or {}
-
-    def add_port_reject_connection_type(
-            self,
-            port_name, port_type, node_type,
-            reject_pname, reject_ptype, reject_ntype
-    ):
-        """
-        Convenience function for adding to the "reject_connection_types" dict.
-
-        Args:
-            port_name (str): current port name.
-            port_type (str): current port type.
-            node_type (str): current port node type.
-            reject_pname (str): port name to reject.
-            reject_ptype (str): port type to reject.
-            reject_ntype (str): port node type to reject.
-        """
-        connection_data = self.reject_connection_types
-        keys = [node_type, port_type, port_name, reject_ntype]
-        for key in keys:
-            if key not in connection_data.keys():
-                connection_data[key] = {}
-            connection_data = connection_data[key]
-
-        if reject_ptype not in connection_data:
-            connection_data[reject_ptype] = set([reject_pname])
-        else:
-            connection_data[reject_ptype].add(reject_pname)
-
-    def port_reject_connection_types(self, node_type, port_type, port_name):
-        """
-        Convenience function for getting the accepted port types from the
-        "reject_connection_types" dict.
-
-        Args:
-            node_type (str):
-            port_type (str):
-            port_name (str):
-
-        Returns:
-            dict: {<node_type>: {<port_type>: [<port_name>]}}
-        """
-        data = self.reject_connection_types.get(node_type) or {}
-        rejected_types = data.get(port_type) or {}
-        return rejected_types.get(port_name) or {}
-
-
-if __name__ == '__main__':
-    p = PortModel(None)
-    # print(p.to_dict)
-
-    n = NodeModel()
-    n.inputs[p.name] = p
-    n.add_property('foo', 'bar')
-
-    print('-'*100)
-    print('property keys\n')
-    print(list(n.properties.keys()))
-    print('-'*100)
-    print('to_dict\n')
-    for k, v in n.to_dict[n.id].items():
-        print(k, v)
+#!/usr/bin/python
+import json
+from collections import defaultdict
+
+from NodeGraphQt.constants import (
+    LayoutDirectionEnum,
+    NodePropWidgetEnum,
+    PipeLayoutEnum
+)
+from NodeGraphQt.errors import NodePropertyError
+
+
+class PortModel(object):
+    """
+    Data dump for a port object.
+    """
+
+    def __init__(self, node):
+        self.node = node
+        self.type_ = ''
+        self.name = 'port'
+        self.display_name = True
+        self.multi_connection = False
+        self.visible = True
+        self.locked = False
+        self.connected_ports = defaultdict(list)
+
+    def __repr__(self):
+        return '<{}(\'{}\') object at {}>'.format(
+            self.__class__.__name__, self.name, hex(id(self)))
+
+    @property
+    def to_dict(self):
+        """
+        serialize model information to a dictionary.
+
+        Returns:
+            dict: node port dictionary eg.
+                {
+                    'type': 'in',
+                    'name': 'port',
+                    'display_name': True,
+                    'multi_connection': False,
+                    'visible': True,
+                    'locked': False,
+                    'connected_ports': {<node_id>: [<port_name>, <port_name>]}
+                }
+        """
+        props = self.__dict__.copy()
+        props.pop('node')
+        props['connected_ports'] = dict(props.pop('connected_ports'))
+        return props
+
+
+class NodeModel(object):
+    """
+    Data dump for a node object.
+    """
+
+    def __init__(self):
+        self.type_ = None
+        self.id = hex(id(self))
+        self.icon = None
+        self.name = 'node'
+        self.color = (13, 18, 23, 255)
+        self.border_color = (74, 84, 85, 255)
+        self.text_color = (255, 255, 255, 180)
+        self.disabled = False
+        self.selected = False
+        self.visible = True
+        self.width = 100.0
+        self.height = 80.0
+        self.pos = [0.0, 0.0]
+        self.layout_direction = LayoutDirectionEnum.HORIZONTAL.value
+
+        # BaseNode attrs.
+        self.inputs = {}
+        self.outputs = {}
+        self.port_deletion_allowed = False
+
+        # GroupNode attrs.
+        self.subgraph_session = {}
+
+        # Custom
+        self._custom_prop = {}
+
+        # node graph model set at node added time.
+        self._graph_model = None
+
+        # store the property attributes.
+        # (deleted when node is added to the graph)
+        self._TEMP_property_attrs = {}
+
+        # temp store the property widget types.
+        # (deleted when node is added to the graph)
+        self._TEMP_property_widget_types = {
+            'type_': NodePropWidgetEnum.QLABEL.value,
+            'id': NodePropWidgetEnum.QLABEL.value,
+            'icon': NodePropWidgetEnum.HIDDEN.value,
+            'name': NodePropWidgetEnum.QLINE_EDIT.value,
+            'color': NodePropWidgetEnum.COLOR_PICKER.value,
+            'border_color': NodePropWidgetEnum.HIDDEN.value,
+            'text_color': NodePropWidgetEnum.COLOR_PICKER.value,
+            'disabled': NodePropWidgetEnum.QCHECK_BOX.value,
+            'selected': NodePropWidgetEnum.HIDDEN.value,
+            'width': NodePropWidgetEnum.HIDDEN.value,
+            'height': NodePropWidgetEnum.HIDDEN.value,
+            'pos': NodePropWidgetEnum.HIDDEN.value,
+            'layout_direction': NodePropWidgetEnum.HIDDEN.value,
+            'inputs': NodePropWidgetEnum.HIDDEN.value,
+            'outputs': NodePropWidgetEnum.HIDDEN.value,
+        }
+
+        # temp store connection constrains.
+        # (deleted when node is added to the graph)
+        self._TEMP_accept_connection_types = {}
+        self._TEMP_reject_connection_types = {}
+
+    def __repr__(self):
+        return '<{}(\'{}\') object at {}>'.format(
+            self.__class__.__name__, self.name, self.id)
+
+    def add_property(self, name, value, items=None, range=None,
+                     widget_type=None, tab=None):
+        """
+        add custom property or raises an error if the property name is already
+        taken.
+
+        Args:
+            name (str): name of the property.
+            value (object): data.
+            items (list[str]): items used by widget type NODE_PROP_QCOMBO.
+            range (tuple): min, max values used by NODE_PROP_SLIDER.
+            widget_type (int): widget type flag.
+            tab (str): widget tab name.
+        """
+        widget_type = widget_type or NodePropWidgetEnum.HIDDEN.value
+        tab = tab or 'Properties'
+
+        if name in self.properties.keys():
+            raise NodePropertyError(
+                '"{}" reserved for default property.'.format(name))
+        if name in self._custom_prop.keys():
+            raise NodePropertyError(
+                '"{}" property already exists.'.format(name))
+
+        self._custom_prop[name] = value
+
+        if self._graph_model is None:
+            self._TEMP_property_widget_types[name] = widget_type
+            self._TEMP_property_attrs[name] = {'tab': tab}
+            if items:
+                self._TEMP_property_attrs[name]['items'] = items
+            if range:
+                self._TEMP_property_attrs[name]['range'] = range
+        else:
+            attrs = {
+                self.type_: {
+                    name: {
+                        'widget_type': widget_type,
+                        'tab': tab
+                    }
+                }
+            }
+            if items:
+                attrs[self.type_][name]['items'] = items
+            if range:
+                attrs[self.type_][name]['range'] = range
+            self._graph_model.set_node_common_properties(attrs)
+
+    def set_property(self, name, value):
+        """
+        Args:
+            name (str): property name.
+            value (object): property value.
+        """
+        if name in self.properties.keys():
+            setattr(self, name, value)
+        elif name in self._custom_prop.keys():
+            self._custom_prop[name] = value
+        else:
+            raise NodePropertyError('No property "{}"'.format(name))
+
+    def get_property(self, name):
+        """
+        Args:
+            name (str): property name.
+
+        Returns:
+            object: property value.
+        """
+        if name in self.properties.keys():
+            return self.properties[name]
+        return self._custom_prop.get(name)
+
+    def is_custom_property(self, name):
+        """
+        Args:
+            name (str): property name.
+
+        Returns:
+            bool: true if custom property.
+        """
+        return name in self._custom_prop
+
+    def get_widget_type(self, name):
+        """
+        Args:
+            name (str): property name.
+
+        Returns:
+            int: node property widget type.
+        """
+        model = self._graph_model
+        if model is None:
+            return self._TEMP_property_widget_types.get(name)
+        return model.get_node_common_properties(self.type_)[name]['widget_type']
+
+    def get_tab_name(self, name):
+        """
+        Args:
+            name (str): property name.
+
+        Returns:
+            str: name of the tab for the properties bin.
+        """
+        model = self._graph_model
+        if model is None:
+            attrs = self._TEMP_property_attrs.get(name)
+            if attrs:
+                return attrs[name].get('tab')
+            return
+        return model.get_node_common_properties(self.type_)[name]['tab']
+
+    def add_port_accept_connection_type(
+            self,
+            port_name, port_type, node_type,
+            accept_pname, accept_ptype, accept_ntype
+    ):
+        """
+        Convenience function for adding to the "accept_connection_types" dict.
+        If the node graph model is unavailable yet then we store it to a
+        temp var that gets deleted.
+
+        Args:
+            port_name (str): current port name.
+            port_type (str): current port type.
+            node_type (str): current port node type.
+            accept_pname (str):port name to accept.
+            accept_ptype (str): port type accept.
+            accept_ntype (str):port node type to accept.
+        """
+        model = self._graph_model
+        if model:
+            model.add_port_accept_connection_type(
+                port_name, port_type, node_type,
+                accept_pname, accept_ptype, accept_ntype
+            )
+            return
+
+        connection_data = self._TEMP_accept_connection_types
+        keys = [node_type, port_type, port_name, accept_ntype]
+        for key in keys:
+            if key not in connection_data.keys():
+                connection_data[key] = {}
+            connection_data = connection_data[key]
+
+        if accept_ptype not in connection_data:
+            connection_data[accept_ptype] = set([accept_pname])
+        else:
+            connection_data[accept_ptype].add(accept_pname)
+
+    def add_port_reject_connection_type(
+        self,
+        port_name, port_type, node_type,
+        reject_pname, reject_ptype, reject_ntype
+    ):
+        """
+        Convenience function for adding to the "reject_connection_types" dict.
+        If the node graph model is unavailable yet then we store it to a
+        temp var that gets deleted.
+
+        Args:
+            port_name (str): current port name.
+            port_type (str): current port type.
+            node_type (str): current port node type.
+            reject_pname:
+            reject_ptype:
+            reject_ntype:
+
+        Returns:
+
+        """
+        model = self._graph_model
+        if model:
+            model.add_port_reject_connection_type(
+                port_name, port_type, node_type,
+                reject_pname, reject_ptype, reject_ntype
+            )
+            return
+
+        connection_data = self._TEMP_reject_connection_types
+        keys = [node_type, port_type, port_name, reject_ntype]
+        for key in keys:
+            if key not in connection_data.keys():
+                connection_data[key] = {}
+            connection_data = connection_data[key]
+
+        if reject_ptype not in connection_data:
+            connection_data[reject_ptype] = set([reject_pname])
+        else:
+            connection_data[reject_ptype].add(reject_pname)
+
+    @property
+    def properties(self):
+        """
+        return all default node properties.
+
+        Returns:
+            dict: default node properties.
+        """
+        props = self.__dict__.copy()
+        exclude = ['_custom_prop',
+                   '_graph_model',
+                   '_TEMP_property_attrs',
+                   '_TEMP_property_widget_types']
+        [props.pop(i) for i in exclude if i in props.keys()]
+        return props
+
+    @property
+    def custom_properties(self):
+        """
+        return all custom properties specified by the user.
+
+        Returns:
+            dict: user defined properties.
+        """
+        return self._custom_prop
+
+    @property
+    def to_dict(self):
+        """
+        serialize model information to a dictionary.
+
+        Returns:
+            dict: node id as the key and properties as the values eg.
+                {'0x106cf75a8': {
+                    'name': 'foo node',
+                    'color': (48, 58, 69, 255),
+                    'border_color': (85, 100, 100, 255),
+                    'text_color': (255, 255, 255, 180),
+                    'type_': 'io.github.jchanvfx.FooNode',
+                    'selected': False,
+                    'disabled': False,
+                    'visible': True,
+                    'width': 0.0,
+                    'height: 0.0,
+                    'pos': (0.0, 0.0),
+                    'layout_direction': 0,
+                    'custom': {},
+                    'inputs': {
+                        <port_name>: {<node_id>: [<port_name>, <port_name>]}
+                    },
+                    'outputs': {
+                        <port_name>: {<node_id>: [<port_name>, <port_name>]}
+                    },
+                    'input_ports': [<port_name>, <port_name>],
+                    'output_ports': [<port_name>, <port_name>],
+                    },
+                    subgraph_session: <sub graph session data>
+                }
+        """
+        node_dict = self.__dict__.copy()
+        node_id = node_dict.pop('id')
+
+        inputs = {}
+        outputs = {}
+        input_ports = []
+        output_ports = []
+        for name, model in node_dict.pop('inputs').items():
+            if self.port_deletion_allowed:
+                input_ports.append({
+                    'name': name,
+                    'multi_connection': model.multi_connection,
+                    'display_name': model.display_name,
+                })
+            connected_ports = model.to_dict['connected_ports']
+            if connected_ports:
+                inputs[name] = connected_ports
+        for name, model in node_dict.pop('outputs').items():
+            if self.port_deletion_allowed:
+                output_ports.append({
+                    'name': name,
+                    'multi_connection': model.multi_connection,
+                    'display_name': model.display_name,
+                })
+            connected_ports = model.to_dict['connected_ports']
+            if connected_ports:
+                outputs[name] = connected_ports
+        if inputs:
+            node_dict['inputs'] = inputs
+        if outputs:
+            node_dict['outputs'] = outputs
+
+        if self.port_deletion_allowed:
+            node_dict['input_ports'] = input_ports
+            node_dict['output_ports'] = output_ports
+
+        if self.subgraph_session:
+            node_dict['subgraph_session'] = self.subgraph_session
+
+        custom_props = node_dict.pop('_custom_prop', {})
+        if custom_props:
+            node_dict['custom'] = custom_props
+
+        exclude = ['_graph_model',
+                   '_TEMP_property_attrs',
+                   '_TEMP_property_widget_types']
+        [node_dict.pop(i) for i in exclude if i in node_dict.keys()]
+
+        return {node_id: node_dict}
+
+    @property
+    def serial(self):
+        """
+        Serialize model information to a string.
+
+        Returns:
+            str: serialized JSON string.
+        """
+        model_dict = self.to_dict
+        return json.dumps(model_dict)
+
+
+class NodeGraphModel(object):
+    """
+    Data dump for a node graph.
+    """
+
+    def __init__(self):
+        self.__common_node_props = {}
+
+        self.accept_connection_types = {}
+        self.reject_connection_types = {}
+
+        self.nodes = {}
+        self.session = ''
+        self.acyclic = True
+        self.pipe_collision = False
+        self.pipe_slicing = True
+        self.pipe_style = PipeLayoutEnum.CURVED.value
+        self.layout_direction = LayoutDirectionEnum.HORIZONTAL.value
+
+    def common_properties(self):
+        """
+        Return all common node properties.
+
+        Returns:
+            dict: common node properties.
+                eg.
+                    {'nodeGraphQt.nodes.FooNode': {
+                        'my_property': {
+                            'widget_type': 0,
+                            'tab': 'Properties',
+                            'items': ['foo', 'bar', 'test'],
+                            'range': (0, 100)
+                            }
+                        }
+                    }
+        """
+        return self.__common_node_props
+
+    def set_node_common_properties(self, attrs):
+        """
+        Store common node properties.
+
+        Args:
+            attrs (dict): common node properties.
+                eg.
+                    {'nodeGraphQt.nodes.FooNode': {
+                        'my_property': {
+                            'widget_type': 0,
+                            'tab': 'Properties',
+                            'items': ['foo', 'bar', 'test'],
+                            'range': (0, 100)
+                            }
+                        }
+                    }
+        """
+        for node_type in attrs.keys():
+            node_props = attrs[node_type]
+
+            if node_type not in self.__common_node_props.keys():
+                self.__common_node_props[node_type] = node_props
+                continue
+
+            for prop_name, prop_attrs in node_props.items():
+                common_props = self.__common_node_props[node_type]
+                if prop_name not in common_props.keys():
+                    common_props[prop_name] = prop_attrs
+                    continue
+                common_props[prop_name].update(prop_attrs)
+
+    def get_node_common_properties(self, node_type):
+        """
+        Return all the common properties for a registered node.
+
+        Args:
+            node_type (str): node type.
+
+        Returns:
+            dict: node common properties.
+        """
+        return self.__common_node_props.get(node_type)
+
+    def add_port_accept_connection_type(
+            self,
+            port_name, port_type, node_type,
+            accept_pname, accept_ptype, accept_ntype
+    ):
+        """
+        Convenience function for adding to the "accept_connection_types" dict.
+
+        Args:
+            port_name (str): current port name.
+            port_type (str): current port type.
+            node_type (str): current port node type.
+            accept_pname (str):port name to accept.
+            accept_ptype (str): port type accept.
+            accept_ntype (str):port node type to accept.
+        """
+        connection_data = self.accept_connection_types
+        keys = [node_type, port_type, port_name, accept_ntype]
+        for key in keys:
+            if key not in connection_data.keys():
+                connection_data[key] = {}
+            connection_data = connection_data[key]
+
+        if accept_ptype not in connection_data:
+            connection_data[accept_ptype] = set([accept_pname])
+        else:
+            connection_data[accept_ptype].add(accept_pname)
+
+    def port_accept_connection_types(self, node_type, port_type, port_name):
+        """
+        Convenience function for getting the accepted port types from the
+        "accept_connection_types" dict.
+
+        Args:
+            node_type (str):
+            port_type (str):
+            port_name (str):
+
+        Returns:
+            dict: {<node_type>: {<port_type>: [<port_name>]}}
+        """
+        data = self.accept_connection_types.get(node_type) or {}
+        accepted_types = data.get(port_type) or {}
+        return accepted_types.get(port_name) or {}
+
+    def add_port_reject_connection_type(
+            self,
+            port_name, port_type, node_type,
+            reject_pname, reject_ptype, reject_ntype
+    ):
+        """
+        Convenience function for adding to the "reject_connection_types" dict.
+
+        Args:
+            port_name (str): current port name.
+            port_type (str): current port type.
+            node_type (str): current port node type.
+            reject_pname (str): port name to reject.
+            reject_ptype (str): port type to reject.
+            reject_ntype (str): port node type to reject.
+        """
+        connection_data = self.reject_connection_types
+        keys = [node_type, port_type, port_name, reject_ntype]
+        for key in keys:
+            if key not in connection_data.keys():
+                connection_data[key] = {}
+            connection_data = connection_data[key]
+
+        if reject_ptype not in connection_data:
+            connection_data[reject_ptype] = set([reject_pname])
+        else:
+            connection_data[reject_ptype].add(reject_pname)
+
+    def port_reject_connection_types(self, node_type, port_type, port_name):
+        """
+        Convenience function for getting the accepted port types from the
+        "reject_connection_types" dict.
+
+        Args:
+            node_type (str):
+            port_type (str):
+            port_name (str):
+
+        Returns:
+            dict: {<node_type>: {<port_type>: [<port_name>]}}
+        """
+        data = self.reject_connection_types.get(node_type) or {}
+        rejected_types = data.get(port_type) or {}
+        return rejected_types.get(port_name) or {}
+
+
+if __name__ == '__main__':
+    p = PortModel(None)
+    # print(p.to_dict)
+
+    n = NodeModel()
+    n.inputs[p.name] = p
+    n.add_property('foo', 'bar')
+
+    print('-'*100)
+    print('property keys\n')
+    print(list(n.properties.keys()))
+    print('-'*100)
+    print('to_dict\n')
+    for k, v in n.to_dict[n.id].items():
+        print(k, v)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/base/node.py` & `NodeGraphQt-0.6.3/NodeGraphQt/base/node.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,528 +1,528 @@
-#!/usr/bin/python
-from NodeGraphQt.base.commands import PropertyChangedCmd
-from NodeGraphQt.base.model import NodeModel
-from NodeGraphQt.constants import NodePropWidgetEnum
-
-
-class _ClassProperty(object):
-
-    def __init__(self, f):
-        self.f = f
-
-    def __get__(self, instance, owner):
-        return self.f(owner)
-
-
-class NodeObject(object):
-    """
-    The ``NodeGraphQt.NodeObject`` class is the main base class that all
-    nodes inherit from.
-
-    .. inheritance-diagram:: NodeGraphQt.NodeObject
-
-    Args:
-        qgraphics_item (AbstractNodeItem): QGraphicsItem item used for drawing.
-    """
-
-    __identifier__ = 'nodeGraphQt.nodes'
-    """
-    Unique node identifier domain. eg. ``"io.github.jchanvfx"``
-
-    .. important:: re-implement this attribute to provide a unique node type.
-    
-        .. code-block:: python
-            :linenos:
-    
-            from NodeGraphQt import NodeObject
-    
-            class ExampleNode(NodeObject):
-    
-                # unique node identifier domain.
-                __identifier__ = 'io.github.jchanvfx'
-    
-                def __init__(self):
-                    ...
-    
-    :return: node type domain.
-    :rtype: str
-    
-    :meta hide-value:
-    """
-
-    NODE_NAME = None
-    """
-    Initial base node name.
-
-    .. important:: re-implement this attribute to provide a base node name.
-    
-        .. code-block:: python
-            :linenos:
-    
-            from NodeGraphQt import NodeObject
-    
-            class ExampleNode(NodeObject):
-    
-                # initial default node name.
-                NODE_NAME = 'Example Node'
-    
-                def __init__(self):
-                    ...
-    
-    :return: node name
-    :rtype: str
-    
-    :meta hide-value:
-    """
-
-    def __init__(self, qgraphics_item=None):
-        """
-        Args:
-            qgraphics_item (AbstractNodeItem): QGraphicsItem used for drawing.
-        """
-        self._graph = None
-        self._model = NodeModel()
-        self._model.type_ = self.type_
-        self._model.name = self.NODE_NAME
-
-        _NodeItem = qgraphics_item
-        if _NodeItem is None:
-            raise RuntimeError(
-                'No qgraphics item specified for the node object!'
-            )
-
-        self._view = _NodeItem()
-        self._view.type_ = self.type_
-        self._view.name = self.model.name
-        self._view.id = self._model.id
-        self._view.layout_direction = self._model.layout_direction
-
-    def __repr__(self):
-        return '<{}("{}") object at {}>'.format(
-            self.__class__.__name__, self.NODE_NAME, hex(id(self)))
-
-    @_ClassProperty
-    def type_(cls):
-        """
-        Node type identifier followed by the class name.
-        `eg.` ``"nodeGraphQt.nodes.NodeObject"``
-
-        Returns:
-            str: node type (``__identifier__.__className__``)
-        """
-        return cls.__identifier__ + '.' + cls.__name__
-
-    @property
-    def id(self):
-        """
-        The node unique id.
-
-        Returns:
-            str: unique identifier string to the node.
-        """
-        return self.model.id
-
-    @property
-    def graph(self):
-        """
-        The parent node graph.
-
-        Returns:
-            NodeGraphQt.NodeGraph: node graph instance.
-        """
-        return self._graph
-
-    @property
-    def view(self):
-        """
-        Returns the :class:`QtWidgets.QGraphicsItem` used in the scene.
-
-        Returns:
-            NodeGraphQt.qgraphics.node_abstract.AbstractNodeItem: node item.
-        """
-        return self._view
-
-    def set_view(self, item):
-        """
-        Set a new ``QGraphicsItem`` item to be used as the view.
-        (the provided qgraphics item must be subclassed from the
-        ``AbstractNodeItem`` object.)
-
-        Args:
-            item (NodeGraphQt.qgraphics.node_abstract.AbstractNodeItem): node item.
-        """
-        if self._view:
-            old_view = self._view
-            scene = self._view.scene()
-            scene.removeItem(old_view)
-            self._view = item
-            scene.addItem(self._view)
-        else:
-            self._view = item
-        self.NODE_NAME = self._view.name
-
-        # update the view.
-        self.update()
-
-    @property
-    def model(self):
-        """
-        Return the node model.
-
-        Returns:
-            NodeGraphQt.base.model.NodeModel: node model object.
-        """
-        return self._model
-
-    def set_model(self, model):
-        """
-        Set a new model to the node model.
-        (Setting a new node model will also update the views qgraphics item.)
-
-        Args:
-            model (NodeGraphQt.base.model.NodeModel): node model object.
-        """
-        self._model = model
-        self._model.type_ = self.type_
-        self._model.id = self.view.id
-
-        # update the view.
-        self.update()
-
-    def update_model(self):
-        """
-        Update the node model from view.
-        """
-        for name, val in self.view.properties.items():
-            if name in self.model.properties.keys():
-                setattr(self.model, name, val)
-            if name in self.model.custom_properties.keys():
-                self.model.custom_properties[name] = val
-
-    def update(self):
-        """
-        Update the node view from model.
-        """
-        settings = self.model.to_dict[self.model.id]
-        settings['id'] = self.model.id
-        if settings.get('custom'):
-            settings['widgets'] = settings.pop('custom')
-
-        self.view.from_dict(settings)
-
-    def serialize(self):
-        """
-        Serialize node model to a dictionary.
-
-        example:
-
-        .. highlight:: python
-        .. code-block:: python
-
-            {'0x106cf75a8': {
-                'name': 'foo node',
-                'color': (48, 58, 69, 255),
-                'border_color': (85, 100, 100, 255),
-                'text_color': (255, 255, 255, 180),
-                'type': 'io.github.jchanvfx.MyNode',
-                'selected': False,
-                'disabled': False,
-                'visible': True,
-                'inputs': {
-                    <port_name>: {<node_id>: [<port_name>, <port_name>]}
-                },
-                'outputs': {
-                    <port_name>: {<node_id>: [<port_name>, <port_name>]}
-                },
-                'input_ports': [<port_name>, <port_name>],
-                'output_ports': [<port_name>, <port_name>],
-                'width': 0.0,
-                'height: 0.0,
-                'pos': (0.0, 0.0),
-                'layout_direction': 0,
-                'custom': {},
-                }
-            }
-
-        Returns:
-            dict: serialized node
-        """
-        return self.model.to_dict
-
-    def name(self):
-        """
-        Name of the node.
-
-        Returns:
-            str: name of the node.
-        """
-        return self.model.name
-
-    def set_name(self, name=''):
-        """
-        Set the name of the node.
-
-        Args:
-            name (str): name for the node.
-        """
-        self.set_property('name', name)
-
-    def color(self):
-        """
-        Returns the node color in (red, green, blue) value.
-
-        Returns:
-            tuple: ``(r, g, b)`` from ``0-255`` range.
-        """
-        r, g, b, a = self.model.color
-        return r, g, b
-
-    def set_color(self, r=0, g=0, b=0):
-        """
-        Sets the color of the node in (red, green, blue) value.
-
-        Args:
-            r (int): red value ``0-255`` range.
-            g (int): green value ``0-255`` range.
-            b (int): blue value ``0-255`` range.
-        """
-        self.set_property('color', (r, g, b, 255))
-
-    def disabled(self):
-        """
-        Returns whether the node is enabled or disabled.
-
-        Returns:
-            bool: True if the node is disabled.
-        """
-        return self.model.disabled
-
-    def set_disabled(self, mode=False):
-        """
-        Set the node state to either disabled or enabled.
-
-        Args:
-            mode(bool): True to disable node.
-        """
-        self.set_property('disabled', mode)
-
-    def selected(self):
-        """
-        Returns the selected state of the node.
-
-        Returns:
-            bool: True if the node is selected.
-        """
-        self.model.selected = self.view.isSelected()
-        return self.model.selected
-
-    def set_selected(self, selected=True):
-        """
-        Set the node to be selected or not selected.
-
-        Args:
-            selected (bool): True to select the node.
-        """
-        self.set_property('selected', selected)
-
-    def create_property(self, name, value, items=None, range=None,
-                        widget_type=None, tab=None):
-        """
-        Creates a custom property to the node.
-
-        See Also:
-            Custom node properties bin widget
-            :class:`NodeGraphQt.PropertiesBinWidget`
-
-        Hint:
-            To see all the available property widget types to display in
-            the ``PropertiesBinWidget`` widget checkout
-            :attr:`NodeGraphQt.constants.NodePropWidgetEnum`.
-
-        Args:
-            name (str): name of the property.
-            value (object): data.
-            items (list[str]): items used by widget type
-                attr:`NodeGraphQt.constants.NodePropWidgetEnum.QCOMBO_BOX`
-            range (tuple or list): ``(min, max)`` values used by
-                :attr:`NodeGraphQt.constants.NodePropWidgetEnum.SLIDER`
-            widget_type (int): widget flag to display in the
-                :class:`NodeGraphQt.PropertiesBinWidget`
-            tab (str): name of the widget tab to display in the
-                :class:`NodeGraphQt.PropertiesBinWidget`.
-        """
-        widget_type = widget_type or NodePropWidgetEnum.HIDDEN.value
-        self.model.add_property(name, value, items, range, widget_type, tab)
-
-    def properties(self):
-        """
-        Returns all the node properties.
-
-        Returns:
-            dict: a dictionary of node properties.
-        """
-        props = self.model.to_dict[self.id].copy()
-        props['id'] = self.id
-        return props
-
-    def get_property(self, name):
-        """
-        Return the node custom property.
-
-        Args:
-            name (str): name of the property.
-
-        Returns:
-            object: property data.
-        """
-        if self.graph and name == 'selected':
-            self.model.set_property(name, self.view.selected)
-
-        return self.model.get_property(name)
-
-    def set_property(self, name, value, push_undo=True):
-        """
-        Set the value on the node custom property.
-
-        Note:
-            When setting the node ``"name"`` property a new unique name will be
-            used if another node in the graph has the same node name.
-
-        Args:
-            name (str): name of the property.
-            value (object): property data (python built in types).
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-
-        # prevent signals from causing a infinite loop.
-        if self.get_property(name) == value:
-            return
-
-        # prevent nodes from have the same name.
-        if self.graph and name == 'name':
-            value = self.graph.get_unique_name(value)
-            self.NODE_NAME = value
-
-        if self.graph:
-            undo_cmd = PropertyChangedCmd(self, name, value)
-            if name == 'name':
-                undo_cmd.setText(
-                    'renamed "{}" to "{}"'.format(self.name(), value)
-                )
-            if push_undo:
-                undo_stack = self.graph.undo_stack()
-                undo_stack.push(undo_cmd)
-            else:
-                undo_cmd.redo()
-        else:
-            if hasattr(self.view, name):
-                setattr(self.view, name, value)
-            self.model.set_property(name, value)
-
-        # redraw the node for custom properties.
-        if self.model.is_custom_property(name):
-            self.view.draw_node()
-
-    def has_property(self, name):
-        """
-        Check if node custom property exists.
-
-        Args:
-            name (str): name of the node.
-
-        Returns:
-            bool: true if property name exists in the Node.
-        """
-        return name in self.model.custom_properties.keys()
-
-    def set_x_pos(self, x):
-        """
-        Set the node horizontal X position in the node graph.
-
-        Args:
-            x (float or int): node X position.
-        """
-        y = self.pos()[1]
-        self.set_pos(float(x), y)
-
-    def set_y_pos(self, y):
-        """
-        Set the node horizontal Y position in the node graph.
-
-        Args:
-            y (float or int): node Y position.
-        """
-
-        x = self.pos()[0]
-        self.set_pos(x, float(y))
-
-    def set_pos(self, x, y):
-        """
-        Set the node X and Y position in the node graph.
-
-        Args:
-            x (float or int): node X position.
-            y (float or int): node Y position.
-        """
-        self.set_property('pos', [float(x), float(y)])
-
-    def x_pos(self):
-        """
-        Get the node X position in the node graph.
-
-        Returns:
-            float: x position.
-        """
-        return self.model.pos[0]
-
-    def y_pos(self):
-        """
-        Get the node Y position in the node graph.
-
-        Returns:
-            float: y position.
-        """
-        return self.model.pos[1]
-
-    def pos(self):
-        """
-        Get the node XY position in the node graph.
-
-        Returns:
-            list[float, float]: x, y position.
-        """
-        if self.view.xy_pos and self.view.xy_pos != self.model.pos:
-            self.model.pos = self.view.xy_pos
-
-        return self.model.pos
-
-    def layout_direction(self):
-        """
-        Returns layout direction for this node.
-
-        See Also:
-            :meth:`NodeObject.set_layout_direction`
-
-        Returns:
-            int: node layout direction.
-        """
-        return self.model.layout_direction
-
-    def set_layout_direction(self, value=0):
-        """
-        Sets the node layout direction to either horizontal or vertical on
-        the current node only.
-
-        `Implemented in` ``v0.3.0``
-
-        See Also:
-            :meth:`NodeGraph.set_layout_direction`
-            :meth:`NodeObject.layout_direction`
-
-        Warnings:
-            This function does not register to the undo stack.
-
-        Args:
-            value (int): layout direction mode.
-        """
-        self.model.layout_direction = value
-        self.view.layout_direction = value
+#!/usr/bin/python
+from NodeGraphQt.base.commands import PropertyChangedCmd
+from NodeGraphQt.base.model import NodeModel
+from NodeGraphQt.constants import NodePropWidgetEnum
+
+
+class _ClassProperty(object):
+
+    def __init__(self, f):
+        self.f = f
+
+    def __get__(self, instance, owner):
+        return self.f(owner)
+
+
+class NodeObject(object):
+    """
+    The ``NodeGraphQt.NodeObject`` class is the main base class that all
+    nodes inherit from.
+
+    .. inheritance-diagram:: NodeGraphQt.NodeObject
+
+    Args:
+        qgraphics_item (AbstractNodeItem): QGraphicsItem item used for drawing.
+    """
+
+    __identifier__ = 'nodeGraphQt.nodes'
+    """
+    Unique node identifier domain. eg. ``"io.github.jchanvfx"``
+
+    .. important:: re-implement this attribute to provide a unique node type.
+    
+        .. code-block:: python
+            :linenos:
+    
+            from NodeGraphQt import NodeObject
+    
+            class ExampleNode(NodeObject):
+    
+                # unique node identifier domain.
+                __identifier__ = 'io.github.jchanvfx'
+    
+                def __init__(self):
+                    ...
+    
+    :return: node type domain.
+    :rtype: str
+    
+    :meta hide-value:
+    """
+
+    NODE_NAME = None
+    """
+    Initial base node name.
+
+    .. important:: re-implement this attribute to provide a base node name.
+    
+        .. code-block:: python
+            :linenos:
+    
+            from NodeGraphQt import NodeObject
+    
+            class ExampleNode(NodeObject):
+    
+                # initial default node name.
+                NODE_NAME = 'Example Node'
+    
+                def __init__(self):
+                    ...
+    
+    :return: node name
+    :rtype: str
+    
+    :meta hide-value:
+    """
+
+    def __init__(self, qgraphics_item=None):
+        """
+        Args:
+            qgraphics_item (AbstractNodeItem): QGraphicsItem used for drawing.
+        """
+        self._graph = None
+        self._model = NodeModel()
+        self._model.type_ = self.type_
+        self._model.name = self.NODE_NAME
+
+        _NodeItem = qgraphics_item
+        if _NodeItem is None:
+            raise RuntimeError(
+                'No qgraphics item specified for the node object!'
+            )
+
+        self._view = _NodeItem()
+        self._view.type_ = self.type_
+        self._view.name = self.model.name
+        self._view.id = self._model.id
+        self._view.layout_direction = self._model.layout_direction
+
+    def __repr__(self):
+        return '<{}("{}") object at {}>'.format(
+            self.__class__.__name__, self.NODE_NAME, hex(id(self)))
+
+    @_ClassProperty
+    def type_(cls):
+        """
+        Node type identifier followed by the class name.
+        `eg.` ``"nodeGraphQt.nodes.NodeObject"``
+
+        Returns:
+            str: node type (``__identifier__.__className__``)
+        """
+        return cls.__identifier__ + '.' + cls.__name__
+
+    @property
+    def id(self):
+        """
+        The node unique id.
+
+        Returns:
+            str: unique identifier string to the node.
+        """
+        return self.model.id
+
+    @property
+    def graph(self):
+        """
+        The parent node graph.
+
+        Returns:
+            NodeGraphQt.NodeGraph: node graph instance.
+        """
+        return self._graph
+
+    @property
+    def view(self):
+        """
+        Returns the :class:`QtWidgets.QGraphicsItem` used in the scene.
+
+        Returns:
+            NodeGraphQt.qgraphics.node_abstract.AbstractNodeItem: node item.
+        """
+        return self._view
+
+    def set_view(self, item):
+        """
+        Set a new ``QGraphicsItem`` item to be used as the view.
+        (the provided qgraphics item must be subclassed from the
+        ``AbstractNodeItem`` object.)
+
+        Args:
+            item (NodeGraphQt.qgraphics.node_abstract.AbstractNodeItem): node item.
+        """
+        if self._view:
+            old_view = self._view
+            scene = self._view.scene()
+            scene.removeItem(old_view)
+            self._view = item
+            scene.addItem(self._view)
+        else:
+            self._view = item
+        self.NODE_NAME = self._view.name
+
+        # update the view.
+        self.update()
+
+    @property
+    def model(self):
+        """
+        Return the node model.
+
+        Returns:
+            NodeGraphQt.base.model.NodeModel: node model object.
+        """
+        return self._model
+
+    def set_model(self, model):
+        """
+        Set a new model to the node model.
+        (Setting a new node model will also update the views qgraphics item.)
+
+        Args:
+            model (NodeGraphQt.base.model.NodeModel): node model object.
+        """
+        self._model = model
+        self._model.type_ = self.type_
+        self._model.id = self.view.id
+
+        # update the view.
+        self.update()
+
+    def update_model(self):
+        """
+        Update the node model from view.
+        """
+        for name, val in self.view.properties.items():
+            if name in self.model.properties.keys():
+                setattr(self.model, name, val)
+            if name in self.model.custom_properties.keys():
+                self.model.custom_properties[name] = val
+
+    def update(self):
+        """
+        Update the node view from model.
+        """
+        settings = self.model.to_dict[self.model.id]
+        settings['id'] = self.model.id
+        if settings.get('custom'):
+            settings['widgets'] = settings.pop('custom')
+
+        self.view.from_dict(settings)
+
+    def serialize(self):
+        """
+        Serialize node model to a dictionary.
+
+        example:
+
+        .. highlight:: python
+        .. code-block:: python
+
+            {'0x106cf75a8': {
+                'name': 'foo node',
+                'color': (48, 58, 69, 255),
+                'border_color': (85, 100, 100, 255),
+                'text_color': (255, 255, 255, 180),
+                'type': 'io.github.jchanvfx.MyNode',
+                'selected': False,
+                'disabled': False,
+                'visible': True,
+                'inputs': {
+                    <port_name>: {<node_id>: [<port_name>, <port_name>]}
+                },
+                'outputs': {
+                    <port_name>: {<node_id>: [<port_name>, <port_name>]}
+                },
+                'input_ports': [<port_name>, <port_name>],
+                'output_ports': [<port_name>, <port_name>],
+                'width': 0.0,
+                'height: 0.0,
+                'pos': (0.0, 0.0),
+                'layout_direction': 0,
+                'custom': {},
+                }
+            }
+
+        Returns:
+            dict: serialized node
+        """
+        return self.model.to_dict
+
+    def name(self):
+        """
+        Name of the node.
+
+        Returns:
+            str: name of the node.
+        """
+        return self.model.name
+
+    def set_name(self, name=''):
+        """
+        Set the name of the node.
+
+        Args:
+            name (str): name for the node.
+        """
+        self.set_property('name', name)
+
+    def color(self):
+        """
+        Returns the node color in (red, green, blue) value.
+
+        Returns:
+            tuple: ``(r, g, b)`` from ``0-255`` range.
+        """
+        r, g, b, a = self.model.color
+        return r, g, b
+
+    def set_color(self, r=0, g=0, b=0):
+        """
+        Sets the color of the node in (red, green, blue) value.
+
+        Args:
+            r (int): red value ``0-255`` range.
+            g (int): green value ``0-255`` range.
+            b (int): blue value ``0-255`` range.
+        """
+        self.set_property('color', (r, g, b, 255))
+
+    def disabled(self):
+        """
+        Returns whether the node is enabled or disabled.
+
+        Returns:
+            bool: True if the node is disabled.
+        """
+        return self.model.disabled
+
+    def set_disabled(self, mode=False):
+        """
+        Set the node state to either disabled or enabled.
+
+        Args:
+            mode(bool): True to disable node.
+        """
+        self.set_property('disabled', mode)
+
+    def selected(self):
+        """
+        Returns the selected state of the node.
+
+        Returns:
+            bool: True if the node is selected.
+        """
+        self.model.selected = self.view.isSelected()
+        return self.model.selected
+
+    def set_selected(self, selected=True):
+        """
+        Set the node to be selected or not selected.
+
+        Args:
+            selected (bool): True to select the node.
+        """
+        self.set_property('selected', selected)
+
+    def create_property(self, name, value, items=None, range=None,
+                        widget_type=None, tab=None):
+        """
+        Creates a custom property to the node.
+
+        See Also:
+            Custom node properties bin widget
+            :class:`NodeGraphQt.PropertiesBinWidget`
+
+        Hint:
+            To see all the available property widget types to display in
+            the ``PropertiesBinWidget`` widget checkout
+            :attr:`NodeGraphQt.constants.NodePropWidgetEnum`.
+
+        Args:
+            name (str): name of the property.
+            value (object): data.
+            items (list[str]): items used by widget type
+                attr:`NodeGraphQt.constants.NodePropWidgetEnum.QCOMBO_BOX`
+            range (tuple or list): ``(min, max)`` values used by
+                :attr:`NodeGraphQt.constants.NodePropWidgetEnum.SLIDER`
+            widget_type (int): widget flag to display in the
+                :class:`NodeGraphQt.PropertiesBinWidget`
+            tab (str): name of the widget tab to display in the
+                :class:`NodeGraphQt.PropertiesBinWidget`.
+        """
+        widget_type = widget_type or NodePropWidgetEnum.HIDDEN.value
+        self.model.add_property(name, value, items, range, widget_type, tab)
+
+    def properties(self):
+        """
+        Returns all the node properties.
+
+        Returns:
+            dict: a dictionary of node properties.
+        """
+        props = self.model.to_dict[self.id].copy()
+        props['id'] = self.id
+        return props
+
+    def get_property(self, name):
+        """
+        Return the node custom property.
+
+        Args:
+            name (str): name of the property.
+
+        Returns:
+            object: property data.
+        """
+        if self.graph and name == 'selected':
+            self.model.set_property(name, self.view.selected)
+
+        return self.model.get_property(name)
+
+    def set_property(self, name, value, push_undo=True):
+        """
+        Set the value on the node custom property.
+
+        Note:
+            When setting the node ``"name"`` property a new unique name will be
+            used if another node in the graph has the same node name.
+
+        Args:
+            name (str): name of the property.
+            value (object): property data (python built in types).
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+
+        # prevent signals from causing a infinite loop.
+        if self.get_property(name) == value:
+            return
+
+        # prevent nodes from have the same name.
+        if self.graph and name == 'name':
+            value = self.graph.get_unique_name(value)
+            self.NODE_NAME = value
+
+        if self.graph:
+            undo_cmd = PropertyChangedCmd(self, name, value)
+            if name == 'name':
+                undo_cmd.setText(
+                    'renamed "{}" to "{}"'.format(self.name(), value)
+                )
+            if push_undo:
+                undo_stack = self.graph.undo_stack()
+                undo_stack.push(undo_cmd)
+            else:
+                undo_cmd.redo()
+        else:
+            if hasattr(self.view, name):
+                setattr(self.view, name, value)
+            self.model.set_property(name, value)
+
+        # redraw the node for custom properties.
+        if self.model.is_custom_property(name):
+            self.view.draw_node()
+
+    def has_property(self, name):
+        """
+        Check if node custom property exists.
+
+        Args:
+            name (str): name of the node.
+
+        Returns:
+            bool: true if property name exists in the Node.
+        """
+        return name in self.model.custom_properties.keys()
+
+    def set_x_pos(self, x):
+        """
+        Set the node horizontal X position in the node graph.
+
+        Args:
+            x (float or int): node X position.
+        """
+        y = self.pos()[1]
+        self.set_pos(float(x), y)
+
+    def set_y_pos(self, y):
+        """
+        Set the node horizontal Y position in the node graph.
+
+        Args:
+            y (float or int): node Y position.
+        """
+
+        x = self.pos()[0]
+        self.set_pos(x, float(y))
+
+    def set_pos(self, x, y):
+        """
+        Set the node X and Y position in the node graph.
+
+        Args:
+            x (float or int): node X position.
+            y (float or int): node Y position.
+        """
+        self.set_property('pos', [float(x), float(y)])
+
+    def x_pos(self):
+        """
+        Get the node X position in the node graph.
+
+        Returns:
+            float: x position.
+        """
+        return self.model.pos[0]
+
+    def y_pos(self):
+        """
+        Get the node Y position in the node graph.
+
+        Returns:
+            float: y position.
+        """
+        return self.model.pos[1]
+
+    def pos(self):
+        """
+        Get the node XY position in the node graph.
+
+        Returns:
+            list[float, float]: x, y position.
+        """
+        if self.view.xy_pos and self.view.xy_pos != self.model.pos:
+            self.model.pos = self.view.xy_pos
+
+        return self.model.pos
+
+    def layout_direction(self):
+        """
+        Returns layout direction for this node.
+
+        See Also:
+            :meth:`NodeObject.set_layout_direction`
+
+        Returns:
+            int: node layout direction.
+        """
+        return self.model.layout_direction
+
+    def set_layout_direction(self, value=0):
+        """
+        Sets the node layout direction to either horizontal or vertical on
+        the current node only.
+
+        `Implemented in` ``v0.3.0``
+
+        See Also:
+            :meth:`NodeGraph.set_layout_direction`
+            :meth:`NodeObject.layout_direction`
+
+        Warnings:
+            This function does not register to the undo stack.
+
+        Args:
+            value (int): layout direction mode.
+        """
+        self.model.layout_direction = value
+        self.view.layout_direction = value
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/base/port.py` & `NodeGraphQt-0.6.3/NodeGraphQt/base/port.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,481 +1,481 @@
-#!/usr/bin/python
-from NodeGraphQt.base.commands import (
-    PortConnectedCmd,
-    PortDisconnectedCmd,
-    PortLockedCmd,
-    PortUnlockedCmd,
-    PortVisibleCmd,
-    NodeInputConnectedCmd,
-    NodeInputDisconnectedCmd
-)
-from NodeGraphQt.base.model import PortModel
-from NodeGraphQt.constants import PortTypeEnum
-from NodeGraphQt.errors import PortError
-
-
-class Port(object):
-    """
-    The ``Port`` class is used for connecting one node to another.
-
-    .. inheritance-diagram:: NodeGraphQt.Port
-
-    .. image:: _images/port.png
-        :width: 50%
-
-    See Also:
-        For adding a ports into a node see:
-        :meth:`BaseNode.add_input`, :meth:`BaseNode.add_output`
-
-    Args:
-        node (NodeGraphQt.NodeObject): parent node.
-        port (PortItem): graphic item used for drawing.
-    """
-
-    def __init__(self, node, port):
-        self.__view = port
-        self.__model = PortModel(node)
-
-    def __repr__(self):
-        port = str(self.__class__.__name__)
-        return '<{}("{}") object at {}>'.format(
-            port, self.name(), hex(id(self)))
-
-    @property
-    def view(self):
-        """
-        Returns the :class:`QtWidgets.QGraphicsItem` used in the scene.
-
-        Returns:
-            NodeGraphQt.qgraphics.port.PortItem: port item.
-        """
-        return self.__view
-
-    @property
-    def model(self):
-        """
-        Returns the port model.
-
-        Returns:
-            NodeGraphQt.base.model.PortModel: port model.
-        """
-        return self.__model
-
-    def type_(self):
-        """
-        Returns the port type.
-
-        Port Types:
-            - :attr:`NodeGraphQt.constants.IN_PORT` for input port
-            - :attr:`NodeGraphQt.constants.OUT_PORT` for output port
-
-        Returns:
-            str: port connection type.
-        """
-        return self.model.type_
-
-    def multi_connection(self):
-        """
-        Returns if the ports is a single connection or not.
-
-        Returns:
-            bool: false if port is a single connection port
-        """
-        return self.model.multi_connection
-
-    def node(self):
-        """
-        Return the parent node.
-
-        Returns:
-            NodeGraphQt.BaseNode: parent node object.
-        """
-        return self.model.node
-
-    def name(self):
-        """
-        Returns the port name.
-
-        Returns:
-            str: port name.
-        """
-        return self.model.name
-
-    def visible(self):
-        """
-        Port visible in the node graph.
-
-        Returns:
-            bool: true if visible.
-        """
-        return self.model.visible
-
-    def set_visible(self, visible=True, push_undo=True):
-        """
-        Sets weather the port should be visible or not.
-
-        Args:
-            visible (bool): true if visible.
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        undo_cmd = PortVisibleCmd(self, visible)
-        if push_undo:
-            undo_stack = self.node().graph.undo_stack()
-            undo_stack.push(undo_cmd)
-        else:
-            undo_cmd.redo()
-
-    def locked(self):
-        """
-        Returns the locked state.
-
-        If ports are locked then new pipe connections can't be connected
-        and current connected pipes can't be disconnected.
-
-        Returns:
-            bool: true if locked.
-        """
-        return self.model.locked
-
-    def lock(self):
-        """
-        Lock the port so new pipe connections can't be connected and
-        current connected pipes can't be disconnected.
-
-        This is the same as calling :meth:`Port.set_locked` with the arg
-        set to ``True``
-        """
-        self.set_locked(True, connected_ports=True)
-
-    def unlock(self):
-        """
-        Unlock the port so new pipe connections can be connected and
-        existing connected pipes can be disconnected.
-
-        This is the same as calling :meth:`Port.set_locked` with the arg
-        set to ``False``
-        """
-        self.set_locked(False, connected_ports=True)
-
-    def set_locked(self, state=False, connected_ports=True, push_undo=True):
-        """
-        Sets the port locked state. When locked pipe connections can't be
-        connected or disconnected from this port.
-
-        Args:
-            state (Bool): port lock state.
-            connected_ports (Bool): apply to lock state to connected ports.
-            push_undo (bool): register the command to the undo stack. (default: True)
-
-        """
-        graph = self.node().graph
-        undo_stack = graph.undo_stack()
-        if state:
-            undo_cmd = PortLockedCmd(self)
-        else:
-            undo_cmd = PortUnlockedCmd(self)
-        if push_undo:
-            undo_stack.push(undo_cmd)
-        else:
-            undo_cmd.redo()
-        if connected_ports:
-            for port in self.connected_ports():
-                port.set_locked(state,
-                                connected_ports=False,
-                                push_undo=push_undo)
-
-    def connected_ports(self):
-        """
-        Returns all connected ports.
-
-        Returns:
-            list[NodeGraphQt.Port]: list of connected ports.
-        """
-        ports = []
-        graph = self.node().graph
-        for node_id, port_names in self.model.connected_ports.items():
-            for port_name in port_names:
-                node = graph.get_node_by_id(node_id)
-                if self.type_() == PortTypeEnum.IN.value:
-                    ports.append(node.outputs()[port_name])
-                elif self.type_() == PortTypeEnum.OUT.value:
-                    ports.append(node.inputs()[port_name])
-        return ports
-
-    def connect_to(self, port=None, push_undo=True):
-        """
-        Create connection to the specified port and emits the
-        :attr:`NodeGraph.port_connected` signal from the parent node graph.
-
-        Args:
-            port (NodeGraphQt.Port): port object.
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        if not port:
-            return
-
-        if self in port.connected_ports():
-            return
-
-        if self.locked() or port.locked():
-            name = [p.name() for p in [self, port] if p.locked()][0]
-            raise PortError(
-                'Can\'t connect port because "{}" is locked.'.format(name))
-
-        # validate accept connection.
-        node_type = self.node().type_
-        accepted_types = port.accepted_port_types().get(node_type)
-        if accepted_types:
-            accepted_pnames = accepted_types.get(self.type_()) or set([])
-            if self.name() not in accepted_pnames:
-                return
-        node_type = port.node().type_
-        accepted_types = self.accepted_port_types().get(node_type)
-        if accepted_types:
-            accepted_pnames = accepted_types.get(port.type_()) or set([])
-            if port.name() not in accepted_pnames:
-                return
-
-        # validate reject connection.
-        node_type = self.node().type_
-        rejected_types = port.rejected_port_types().get(node_type)
-        if rejected_types:
-            rejected_pnames = rejected_types.get(self.type_()) or set([])
-            if self.name() in rejected_pnames:
-                return
-        node_type = port.node().type_
-        rejected_types = self.rejected_port_types().get(node_type)
-        if rejected_types:
-            rejected_pnames = rejected_types.get(port.type_()) or set([])
-            if port.name() in rejected_pnames:
-                return
-
-        # make the connection from here.
-        graph = self.node().graph
-        viewer = graph.viewer()
-
-        if push_undo:
-            undo_stack = graph.undo_stack()
-            undo_stack.beginMacro('connect port')
-
-        pre_conn_port = None
-        src_conn_ports = self.connected_ports()
-        if not self.multi_connection() and src_conn_ports:
-            pre_conn_port = src_conn_ports[0]
-
-        if not port:
-            if pre_conn_port:
-                if push_undo:
-                    undo_stack.push(PortDisconnectedCmd(self, port))
-                    undo_stack.push(NodeInputDisconnectedCmd(self, port))
-                    undo_stack.endMacro()
-                else:
-                    PortDisconnectedCmd(self, port).redo()
-                    NodeInputDisconnectedCmd(self, port).redo()
-            return
-
-        if graph.acyclic() and viewer.acyclic_check(self.view, port.view):
-            if pre_conn_port:
-                if push_undo:
-                    undo_stack.push(PortDisconnectedCmd(self, pre_conn_port))
-                    undo_stack.push(NodeInputDisconnectedCmd(
-                        self, pre_conn_port))
-                    undo_stack.endMacro()
-                else:
-                    PortDisconnectedCmd(self, pre_conn_port).redo()
-                    NodeInputDisconnectedCmd(self, pre_conn_port).redo()
-                return
-
-        trg_conn_ports = port.connected_ports()
-        if not port.multi_connection() and trg_conn_ports:
-            dettached_port = trg_conn_ports[0]
-            if push_undo:
-                undo_stack.push(PortDisconnectedCmd(port, dettached_port))
-                undo_stack.push(NodeInputDisconnectedCmd(port, dettached_port))
-            else:
-                PortDisconnectedCmd(port, dettached_port).redo()
-                NodeInputDisconnectedCmd(port, dettached_port).redo()
-        if pre_conn_port:
-            if push_undo:
-                undo_stack.push(PortDisconnectedCmd(self, pre_conn_port))
-                undo_stack.push(NodeInputDisconnectedCmd(self, pre_conn_port))
-            else:
-                PortDisconnectedCmd(self, pre_conn_port).redo()
-                NodeInputDisconnectedCmd(self, pre_conn_port).redo()
-
-        if push_undo:
-            undo_stack.push(PortConnectedCmd(self, port))
-            undo_stack.push(NodeInputConnectedCmd(self, port))
-            undo_stack.endMacro()
-        else:
-            PortConnectedCmd(self, port).redo()
-            NodeInputConnectedCmd(self, port).redo()
-
-        # emit "port_connected" signal from the parent graph.
-        ports = {p.type_(): p for p in [self, port]}
-        graph.port_connected.emit(ports[PortTypeEnum.IN.value],
-                                  ports[PortTypeEnum.OUT.value])
-
-    def disconnect_from(self, port=None, push_undo=True):
-        """
-        Disconnect from the specified port and emits the
-        :attr:`NodeGraph.port_disconnected` signal from the parent node graph.
-
-        Args:
-            port (NodeGraphQt.Port): port object.
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        if not port:
-            return
-
-        if self.locked() or port.locked():
-            name = [p.name() for p in [self, port] if p.locked()][0]
-            raise PortError(
-                'Can\'t disconnect port because "{}" is locked.'.format(name))
-
-        graph = self.node().graph
-        if push_undo:
-            graph.undo_stack().beginMacro('disconnect port')
-            graph.undo_stack().push(PortDisconnectedCmd(self, port))
-            graph.undo_stack().push(NodeInputDisconnectedCmd(self, port))
-            graph.undo_stack().endMacro()
-        else:
-            PortDisconnectedCmd(self, port).redo()
-            NodeInputDisconnectedCmd(self, port).redo()
-
-        # emit "port_disconnected" signal from the parent graph.
-        ports = {p.type_(): p for p in [self, port]}
-        graph.port_disconnected.emit(ports[PortTypeEnum.IN.value],
-                                     ports[PortTypeEnum.OUT.value])
-
-    def clear_connections(self, push_undo=True):
-        """
-        Disconnect from all port connections and emit the
-        :attr:`NodeGraph.port_disconnected` signals from the node graph.
-
-        See Also:
-            :meth:`Port.disconnect_from`,
-            :meth:`Port.connect_to`,
-            :meth:`Port.connected_ports`
-
-        Args:
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        if self.locked():
-            err = 'Can\'t clear connections because port "{}" is locked.'
-            raise PortError(err.format(self.name()))
-
-        if not self.connected_ports():
-            return
-
-        if push_undo:
-            graph = self.node().graph
-            undo_stack = graph.undo_stack()
-            undo_stack.beginMacro('"{}" clear connections')
-            for cp in self.connected_ports():
-                self.disconnect_from(cp)
-            undo_stack.endMacro()
-        else:
-            for cp in self.connected_ports():
-                self.disconnect_from(cp, push_undo=False)
-
-    def add_accept_port_type(self, port_name, port_type, node_type):
-        """
-        Add a constrain to "accept" a pipe connection.
-
-        Once a constrain has been added only ports of that type specified will
-        be allowed a pipe connection.
-
-        `Implemented in` ``v0.6.0``
-
-        See Also:
-            :meth:`NodeGraphQt.Port.add_reject_ports_type`,
-            :meth:`NodeGraphQt.BaseNode.add_accept_port_type`
-
-        Args:
-            port_name (str): name of the port.
-            port_type (str): port type.
-            node_type (str): port node type.
-        """
-        # storing the connection constrain at the graph level instead of the
-        # port level so we don't serialize the same data for every port
-        # instance.
-        self.node().add_accept_port_type(
-            port=self,
-            port_type_data={
-                'port_name': port_name,
-                'port_type': port_type,
-                'node_type': node_type,
-            }
-        )
-
-    def accepted_port_types(self):
-        """
-        Returns a dictionary of connection constrains of the port types
-        that allow for a pipe connection to this node.
-
-        See Also:
-            :meth:`NodeGraphQt.BaseNode.accepted_port_types`
-
-        Returns:
-            dict: {<node_type>: {<port_type>: [<port_name>]}}
-        """
-        return self.node().accepted_port_types(self)
-
-    def add_reject_port_type(self, port_name, port_type, node_type):
-        """
-        Add a constrain to "reject" a pipe connection.
-
-        Once a constrain has been added only ports of that type specified will
-        be rejected a pipe connection.
-
-        `Implemented in` ``v0.6.0``
-
-        See Also:
-            :meth:`NodeGraphQt.Port.add_accept_ports_type`,
-            :meth:`NodeGraphQt.BaseNode.add_reject_port_type`
-
-        Args:
-            port_name (str): name of the port.
-            port_type (str): port type.
-            node_type (str): port node type.
-        """
-        # storing the connection constrain at the graph level instead of the
-        # port level so we don't serialize the same data for every port
-        # instance.
-        self.node().add_reject_port_type(
-            port=self,
-            port_type_data={
-                'port_name': port_name,
-                'port_type': port_type,
-                'node_type': node_type,
-            }
-        )
-
-    def rejected_port_types(self):
-        """
-        Returns a dictionary of connection constrains of the port types
-        that are NOT allowed for a pipe connection to this node.
-
-        See Also:
-            :meth:`NodeGraphQt.BaseNode.rejected_port_types`
-
-        Returns:
-            dict: {<node_type>: {<port_type>: [<port_name>]}}
-        """
-        return self.node().rejected_port_types(self)
-
-    @property
-    def color(self):
-        return self.__view.color
-
-    @color.setter
-    def color(self, color=(0, 0, 0, 255)):
-        self.__view.color = color
-
-    @property
-    def border_color(self):
-        return self.__view.border_color
-
-    @border_color.setter
-    def border_color(self, color=(0, 0, 0, 255)):
-        self.__view.border_color = color
+#!/usr/bin/python
+from NodeGraphQt.base.commands import (
+    PortConnectedCmd,
+    PortDisconnectedCmd,
+    PortLockedCmd,
+    PortUnlockedCmd,
+    PortVisibleCmd,
+    NodeInputConnectedCmd,
+    NodeInputDisconnectedCmd
+)
+from NodeGraphQt.base.model import PortModel
+from NodeGraphQt.constants import PortTypeEnum
+from NodeGraphQt.errors import PortError
+
+
+class Port(object):
+    """
+    The ``Port`` class is used for connecting one node to another.
+
+    .. inheritance-diagram:: NodeGraphQt.Port
+
+    .. image:: _images/port.png
+        :width: 50%
+
+    See Also:
+        For adding a ports into a node see:
+        :meth:`BaseNode.add_input`, :meth:`BaseNode.add_output`
+
+    Args:
+        node (NodeGraphQt.NodeObject): parent node.
+        port (PortItem): graphic item used for drawing.
+    """
+
+    def __init__(self, node, port):
+        self.__view = port
+        self.__model = PortModel(node)
+
+    def __repr__(self):
+        port = str(self.__class__.__name__)
+        return '<{}("{}") object at {}>'.format(
+            port, self.name(), hex(id(self)))
+
+    @property
+    def view(self):
+        """
+        Returns the :class:`QtWidgets.QGraphicsItem` used in the scene.
+
+        Returns:
+            NodeGraphQt.qgraphics.port.PortItem: port item.
+        """
+        return self.__view
+
+    @property
+    def model(self):
+        """
+        Returns the port model.
+
+        Returns:
+            NodeGraphQt.base.model.PortModel: port model.
+        """
+        return self.__model
+
+    def type_(self):
+        """
+        Returns the port type.
+
+        Port Types:
+            - :attr:`NodeGraphQt.constants.IN_PORT` for input port
+            - :attr:`NodeGraphQt.constants.OUT_PORT` for output port
+
+        Returns:
+            str: port connection type.
+        """
+        return self.model.type_
+
+    def multi_connection(self):
+        """
+        Returns if the ports is a single connection or not.
+
+        Returns:
+            bool: false if port is a single connection port
+        """
+        return self.model.multi_connection
+
+    def node(self):
+        """
+        Return the parent node.
+
+        Returns:
+            NodeGraphQt.BaseNode: parent node object.
+        """
+        return self.model.node
+
+    def name(self):
+        """
+        Returns the port name.
+
+        Returns:
+            str: port name.
+        """
+        return self.model.name
+
+    def visible(self):
+        """
+        Port visible in the node graph.
+
+        Returns:
+            bool: true if visible.
+        """
+        return self.model.visible
+
+    def set_visible(self, visible=True, push_undo=True):
+        """
+        Sets weather the port should be visible or not.
+
+        Args:
+            visible (bool): true if visible.
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        undo_cmd = PortVisibleCmd(self, visible)
+        if push_undo:
+            undo_stack = self.node().graph.undo_stack()
+            undo_stack.push(undo_cmd)
+        else:
+            undo_cmd.redo()
+
+    def locked(self):
+        """
+        Returns the locked state.
+
+        If ports are locked then new pipe connections can't be connected
+        and current connected pipes can't be disconnected.
+
+        Returns:
+            bool: true if locked.
+        """
+        return self.model.locked
+
+    def lock(self):
+        """
+        Lock the port so new pipe connections can't be connected and
+        current connected pipes can't be disconnected.
+
+        This is the same as calling :meth:`Port.set_locked` with the arg
+        set to ``True``
+        """
+        self.set_locked(True, connected_ports=True)
+
+    def unlock(self):
+        """
+        Unlock the port so new pipe connections can be connected and
+        existing connected pipes can be disconnected.
+
+        This is the same as calling :meth:`Port.set_locked` with the arg
+        set to ``False``
+        """
+        self.set_locked(False, connected_ports=True)
+
+    def set_locked(self, state=False, connected_ports=True, push_undo=True):
+        """
+        Sets the port locked state. When locked pipe connections can't be
+        connected or disconnected from this port.
+
+        Args:
+            state (Bool): port lock state.
+            connected_ports (Bool): apply to lock state to connected ports.
+            push_undo (bool): register the command to the undo stack. (default: True)
+
+        """
+        graph = self.node().graph
+        undo_stack = graph.undo_stack()
+        if state:
+            undo_cmd = PortLockedCmd(self)
+        else:
+            undo_cmd = PortUnlockedCmd(self)
+        if push_undo:
+            undo_stack.push(undo_cmd)
+        else:
+            undo_cmd.redo()
+        if connected_ports:
+            for port in self.connected_ports():
+                port.set_locked(state,
+                                connected_ports=False,
+                                push_undo=push_undo)
+
+    def connected_ports(self):
+        """
+        Returns all connected ports.
+
+        Returns:
+            list[NodeGraphQt.Port]: list of connected ports.
+        """
+        ports = []
+        graph = self.node().graph
+        for node_id, port_names in self.model.connected_ports.items():
+            for port_name in port_names:
+                node = graph.get_node_by_id(node_id)
+                if self.type_() == PortTypeEnum.IN.value:
+                    ports.append(node.outputs()[port_name])
+                elif self.type_() == PortTypeEnum.OUT.value:
+                    ports.append(node.inputs()[port_name])
+        return ports
+
+    def connect_to(self, port=None, push_undo=True):
+        """
+        Create connection to the specified port and emits the
+        :attr:`NodeGraph.port_connected` signal from the parent node graph.
+
+        Args:
+            port (NodeGraphQt.Port): port object.
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        if not port:
+            return
+
+        if self in port.connected_ports():
+            return
+
+        if self.locked() or port.locked():
+            name = [p.name() for p in [self, port] if p.locked()][0]
+            raise PortError(
+                'Can\'t connect port because "{}" is locked.'.format(name))
+
+        # validate accept connection.
+        node_type = self.node().type_
+        accepted_types = port.accepted_port_types().get(node_type)
+        if accepted_types:
+            accepted_pnames = accepted_types.get(self.type_()) or set([])
+            if self.name() not in accepted_pnames:
+                return
+        node_type = port.node().type_
+        accepted_types = self.accepted_port_types().get(node_type)
+        if accepted_types:
+            accepted_pnames = accepted_types.get(port.type_()) or set([])
+            if port.name() not in accepted_pnames:
+                return
+
+        # validate reject connection.
+        node_type = self.node().type_
+        rejected_types = port.rejected_port_types().get(node_type)
+        if rejected_types:
+            rejected_pnames = rejected_types.get(self.type_()) or set([])
+            if self.name() in rejected_pnames:
+                return
+        node_type = port.node().type_
+        rejected_types = self.rejected_port_types().get(node_type)
+        if rejected_types:
+            rejected_pnames = rejected_types.get(port.type_()) or set([])
+            if port.name() in rejected_pnames:
+                return
+
+        # make the connection from here.
+        graph = self.node().graph
+        viewer = graph.viewer()
+
+        if push_undo:
+            undo_stack = graph.undo_stack()
+            undo_stack.beginMacro('connect port')
+
+        pre_conn_port = None
+        src_conn_ports = self.connected_ports()
+        if not self.multi_connection() and src_conn_ports:
+            pre_conn_port = src_conn_ports[0]
+
+        if not port:
+            if pre_conn_port:
+                if push_undo:
+                    undo_stack.push(PortDisconnectedCmd(self, port))
+                    undo_stack.push(NodeInputDisconnectedCmd(self, port))
+                    undo_stack.endMacro()
+                else:
+                    PortDisconnectedCmd(self, port).redo()
+                    NodeInputDisconnectedCmd(self, port).redo()
+            return
+
+        if graph.acyclic() and viewer.acyclic_check(self.view, port.view):
+            if pre_conn_port:
+                if push_undo:
+                    undo_stack.push(PortDisconnectedCmd(self, pre_conn_port))
+                    undo_stack.push(NodeInputDisconnectedCmd(
+                        self, pre_conn_port))
+                    undo_stack.endMacro()
+                else:
+                    PortDisconnectedCmd(self, pre_conn_port).redo()
+                    NodeInputDisconnectedCmd(self, pre_conn_port).redo()
+                return
+
+        trg_conn_ports = port.connected_ports()
+        if not port.multi_connection() and trg_conn_ports:
+            dettached_port = trg_conn_ports[0]
+            if push_undo:
+                undo_stack.push(PortDisconnectedCmd(port, dettached_port))
+                undo_stack.push(NodeInputDisconnectedCmd(port, dettached_port))
+            else:
+                PortDisconnectedCmd(port, dettached_port).redo()
+                NodeInputDisconnectedCmd(port, dettached_port).redo()
+        if pre_conn_port:
+            if push_undo:
+                undo_stack.push(PortDisconnectedCmd(self, pre_conn_port))
+                undo_stack.push(NodeInputDisconnectedCmd(self, pre_conn_port))
+            else:
+                PortDisconnectedCmd(self, pre_conn_port).redo()
+                NodeInputDisconnectedCmd(self, pre_conn_port).redo()
+
+        if push_undo:
+            undo_stack.push(PortConnectedCmd(self, port))
+            undo_stack.push(NodeInputConnectedCmd(self, port))
+            undo_stack.endMacro()
+        else:
+            PortConnectedCmd(self, port).redo()
+            NodeInputConnectedCmd(self, port).redo()
+
+        # emit "port_connected" signal from the parent graph.
+        ports = {p.type_(): p for p in [self, port]}
+        graph.port_connected.emit(ports[PortTypeEnum.IN.value],
+                                  ports[PortTypeEnum.OUT.value])
+
+    def disconnect_from(self, port=None, push_undo=True):
+        """
+        Disconnect from the specified port and emits the
+        :attr:`NodeGraph.port_disconnected` signal from the parent node graph.
+
+        Args:
+            port (NodeGraphQt.Port): port object.
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        if not port:
+            return
+
+        if self.locked() or port.locked():
+            name = [p.name() for p in [self, port] if p.locked()][0]
+            raise PortError(
+                'Can\'t disconnect port because "{}" is locked.'.format(name))
+
+        graph = self.node().graph
+        if push_undo:
+            graph.undo_stack().beginMacro('disconnect port')
+            graph.undo_stack().push(PortDisconnectedCmd(self, port))
+            graph.undo_stack().push(NodeInputDisconnectedCmd(self, port))
+            graph.undo_stack().endMacro()
+        else:
+            PortDisconnectedCmd(self, port).redo()
+            NodeInputDisconnectedCmd(self, port).redo()
+
+        # emit "port_disconnected" signal from the parent graph.
+        ports = {p.type_(): p for p in [self, port]}
+        graph.port_disconnected.emit(ports[PortTypeEnum.IN.value],
+                                     ports[PortTypeEnum.OUT.value])
+
+    def clear_connections(self, push_undo=True):
+        """
+        Disconnect from all port connections and emit the
+        :attr:`NodeGraph.port_disconnected` signals from the node graph.
+
+        See Also:
+            :meth:`Port.disconnect_from`,
+            :meth:`Port.connect_to`,
+            :meth:`Port.connected_ports`
+
+        Args:
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        if self.locked():
+            err = 'Can\'t clear connections because port "{}" is locked.'
+            raise PortError(err.format(self.name()))
+
+        if not self.connected_ports():
+            return
+
+        if push_undo:
+            graph = self.node().graph
+            undo_stack = graph.undo_stack()
+            undo_stack.beginMacro('"{}" clear connections')
+            for cp in self.connected_ports():
+                self.disconnect_from(cp)
+            undo_stack.endMacro()
+        else:
+            for cp in self.connected_ports():
+                self.disconnect_from(cp, push_undo=False)
+
+    def add_accept_port_type(self, port_name, port_type, node_type):
+        """
+        Add a constrain to "accept" a pipe connection.
+
+        Once a constrain has been added only ports of that type specified will
+        be allowed a pipe connection.
+
+        `Implemented in` ``v0.6.0``
+
+        See Also:
+            :meth:`NodeGraphQt.Port.add_reject_ports_type`,
+            :meth:`NodeGraphQt.BaseNode.add_accept_port_type`
+
+        Args:
+            port_name (str): name of the port.
+            port_type (str): port type.
+            node_type (str): port node type.
+        """
+        # storing the connection constrain at the graph level instead of the
+        # port level so we don't serialize the same data for every port
+        # instance.
+        self.node().add_accept_port_type(
+            port=self,
+            port_type_data={
+                'port_name': port_name,
+                'port_type': port_type,
+                'node_type': node_type,
+            }
+        )
+
+    def accepted_port_types(self):
+        """
+        Returns a dictionary of connection constrains of the port types
+        that allow for a pipe connection to this node.
+
+        See Also:
+            :meth:`NodeGraphQt.BaseNode.accepted_port_types`
+
+        Returns:
+            dict: {<node_type>: {<port_type>: [<port_name>]}}
+        """
+        return self.node().accepted_port_types(self)
+
+    def add_reject_port_type(self, port_name, port_type, node_type):
+        """
+        Add a constrain to "reject" a pipe connection.
+
+        Once a constrain has been added only ports of that type specified will
+        be rejected a pipe connection.
+
+        `Implemented in` ``v0.6.0``
+
+        See Also:
+            :meth:`NodeGraphQt.Port.add_accept_ports_type`,
+            :meth:`NodeGraphQt.BaseNode.add_reject_port_type`
+
+        Args:
+            port_name (str): name of the port.
+            port_type (str): port type.
+            node_type (str): port node type.
+        """
+        # storing the connection constrain at the graph level instead of the
+        # port level so we don't serialize the same data for every port
+        # instance.
+        self.node().add_reject_port_type(
+            port=self,
+            port_type_data={
+                'port_name': port_name,
+                'port_type': port_type,
+                'node_type': node_type,
+            }
+        )
+
+    def rejected_port_types(self):
+        """
+        Returns a dictionary of connection constrains of the port types
+        that are NOT allowed for a pipe connection to this node.
+
+        See Also:
+            :meth:`NodeGraphQt.BaseNode.rejected_port_types`
+
+        Returns:
+            dict: {<node_type>: {<port_type>: [<port_name>]}}
+        """
+        return self.node().rejected_port_types(self)
+
+    @property
+    def color(self):
+        return self.__view.color
+
+    @color.setter
+    def color(self, color=(0, 0, 0, 255)):
+        self.__view.color = color
+
+    @property
+    def border_color(self):
+        return self.__view.border_color
+
+    @border_color.setter
+    def border_color(self, color=(0, 0, 0, 255)):
+        self.__view.border_color = color
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/constants.py` & `NodeGraphQt-0.6.3/NodeGraphQt/constants.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,252 +1,252 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-import os
-
-from Qt import QtWidgets
-from enum import Enum
-
-from .pkg_info import __version__ as _v
-
-__doc__ = """
-| The :py:mod:`NodeGraphQt.constants` namespace contains variables and enums 
- used throughout the NodeGraphQt library.
-"""
-
-# ================================== PRIVATE ===================================
-
-URI_SCHEME = 'nodegraphqt://'
-URN_SCHEME = 'nodegraphqt::'
-
-# PATHS
-BASE_PATH = os.path.dirname(os.path.abspath(__file__))
-ICON_PATH = os.path.join(BASE_PATH, 'widgets', 'icons')
-ICON_DOWN_ARROW = os.path.join(ICON_PATH, 'down_arrow.png')
-ICON_NODE_BASE = os.path.join(ICON_PATH, 'node_base.png')
-
-# DRAW STACK ORDER
-Z_VAL_PIPE = -1
-Z_VAL_NODE = 1
-Z_VAL_PORT = 2
-Z_VAL_NODE_WIDGET = 3
-
-# ITEM CACHE MODE
-# QGraphicsItem.NoCache
-# QGraphicsItem.DeviceCoordinateCache
-# QGraphicsItem.ItemCoordinateCache
-ITEM_CACHE_MODE = QtWidgets.QGraphicsItem.DeviceCoordinateCache
-
-# =================================== GLOBAL ===================================
-
-
-class VersionEnum(Enum):
-    """
-    Current framework version.
-    :py:mod:`NodeGraphQt.constants.VersionEnum`
-    """
-    #: current version string.
-    VERSION = _v
-    #: version major int.
-    MAJOR = int(_v.split('.')[0])
-    #: version minor int.
-    MINOR = int(_v.split('.')[1])
-    #: version patch int.
-    PATCH = int(_v.split('.')[2])
-
-
-class LayoutDirectionEnum(Enum):
-    """
-    Node graph nodes layout direction:
-    :py:mod:`NodeGraphQt.constants.ViewerLayoutEnum`
-    """
-    #: layout nodes left to right.
-    HORIZONTAL = 0
-    #: layout nodes top to bottom.
-    VERTICAL = 1
-
-
-# =================================== VIEWER ===================================
-
-
-class ViewerEnum(Enum):
-    """
-    Node graph viewer styling layout:
-    :py:mod:`NodeGraphQt.constants.ViewerEnum`
-    """
-    #: default background color for the node graph.
-    BACKGROUND_COLOR = (35, 35, 35)
-    #: style node graph background with no grid or dots.
-    GRID_DISPLAY_NONE = 0
-    #: style node graph background with dots.
-    GRID_DISPLAY_DOTS = 1
-    #: style node graph background with grid lines.
-    GRID_DISPLAY_LINES = 2
-    #: grid size when styled with grid lines.
-    GRID_SIZE = 50
-    #: grid line color.
-    GRID_COLOR = (45, 45, 45)
-
-
-class ViewerNavEnum(Enum):
-    """
-    Node graph viewer navigation styling layout:
-    :py:mod:`NodeGraphQt.constants.ViewerNavEnum`
-    """
-    #: default background color.
-    BACKGROUND_COLOR = (25, 25, 25)
-    #: default item color.
-    ITEM_COLOR = (35, 35, 35)
-
-# ==================================== NODE ====================================
-
-
-class NodeEnum(Enum):
-    """
-    Node styling layout:
-    :py:mod:`NodeGraphQt.constants.NodeEnum`
-    """
-    #: default node width.
-    WIDTH = 160
-    #: default node height.
-    HEIGHT = 60
-    #: default node icon size (WxH).
-    ICON_SIZE = 18
-    #: default node overlay color when selected.
-    SELECTED_COLOR = (255, 255, 255, 30)
-    #: default node border color when selected.
-    SELECTED_BORDER_COLOR = (254, 207, 42, 255)
-
-# ==================================== PORT ====================================
-
-
-class PortEnum(Enum):
-    """
-    Port styling layout:
-    :py:mod:`NodeGraphQt.constants.PortEnum`
-    """
-    #: default port size.
-    SIZE = 22.0
-    #: default port color. (r, g, b, a)
-    COLOR = (49, 115, 100, 255)
-    #: default port border color.
-    BORDER_COLOR = (29, 202, 151, 255)
-    #: port color when selected.
-    ACTIVE_COLOR = (14, 45, 59, 255)
-    #: port border color when selected.
-    ACTIVE_BORDER_COLOR = (107, 166, 193, 255)
-    #: port color on mouse over.
-    HOVER_COLOR = (17, 43, 82, 255)
-    #: port border color on mouse over.
-    HOVER_BORDER_COLOR = (136, 255, 35, 255)
-    #: threshold for selecting a port.
-    CLICK_FALLOFF = 15.0
-
-
-class PortTypeEnum(Enum):
-    """
-    Port connection types:
-    :py:mod:`NodeGraphQt.constants.PortTypeEnum`
-    """
-    #: Connection type for input ports.
-    IN = 'in'
-    #: Connection type for output ports.
-    OUT = 'out'
-
-# ==================================== PIPE ====================================
-
-
-class PipeEnum(Enum):
-    """
-    Pipe styling layout:
-    :py:mod:`NodeGraphQt.constants.PipeEnum`
-    """
-    #: default width.
-    WIDTH = 1.2
-    #: default color.
-    COLOR = (175, 95, 30, 255)
-    #: pipe color to a node when it's disabled.
-    DISABLED_COLOR = (200, 60, 60, 255)
-    #: pipe color when selected or mouse over.
-    ACTIVE_COLOR = (70, 255, 220, 255)
-    #: pipe color to a node when it's selected.
-    HIGHLIGHT_COLOR = (232, 184, 13, 255)
-    #: draw connection as a line.
-    DRAW_TYPE_DEFAULT = 0
-    #: draw connection as dashed lines.
-    DRAW_TYPE_DASHED = 1
-    #: draw connection as a dotted line.
-    DRAW_TYPE_DOTTED = 2
-
-
-class PipeSlicerEnum(Enum):
-    """
-    Slicer Pipe styling layout:
-    :py:mod:`NodeGraphQt.constants.PipeSlicerEnum`
-    """
-    #: default width.
-    WIDTH = 1.5
-    #: default color.
-    COLOR = (255, 50, 75)
-
-
-class PipeLayoutEnum(Enum):
-    """
-    Pipe connection drawing layout:
-    :py:mod:`NodeGraphQt.constants.PipeLayoutEnum`
-    """
-    #: draw straight lines for pipe connections.
-    STRAIGHT = 0
-    #: draw curved lines for pipe connections.
-    CURVED = 1
-    #: draw angled lines for pipe connections.
-    ANGLE = 2
-
-
-# === PROPERTY BIN WIDGET ===
-
-class NodePropWidgetEnum(Enum):
-    """
-    Mapping used for the :class:`NodeGraphQt.PropertiesBinWidget` to display a
-    node property in the specified widget type.
-
-    :py:mod:`NodeGraphQt.constants.NodePropWidgetEnum`
-    """
-    #: Node property will be hidden in the ``PropertiesBinWidget`` (default).
-    HIDDEN = 0
-    #: Node property represented with a ``QLabel`` widget.
-    QLABEL = 2
-    #: Node property represented with a ``QLineEdit`` widget.
-    QLINE_EDIT = 3
-    #: Node property represented with a ``QTextEdit`` widget.
-    QTEXT_EDIT = 4
-    #: Node property represented with a ``QComboBox`` widget.
-    QCOMBO_BOX = 5
-    #: Node property represented with a ``QCheckBox`` widget.
-    QCHECK_BOX = 6
-    #: Node property represented with a ``QSpinBox`` widget.
-    QSPIN_BOX = 7
-    #: Node property represented with a ``QDoubleSpinBox`` widget.
-    QDOUBLESPIN_BOX = 8
-    #: Node property represented with a ColorPicker widget.
-    COLOR_PICKER = 9
-    #: Node property represented with a ColorPicker (RGBA) widget.
-    COLOR4_PICKER = 10
-    #: Node property represented with an (Int) Slider widget.
-    SLIDER = 11
-    #: Node property represented with a (Dobule) Slider widget.
-    DOUBLE_SLIDER = 12
-    #: Node property represented with a file selector widget.
-    FILE_OPEN = 13
-    #: Node property represented with a file save widget.
-    FILE_SAVE = 14
-    #: Node property represented with a vector2 widget.
-    VECTOR2 = 15
-    #: Node property represented with vector3 widget.
-    VECTOR3 = 16
-    #: Node property represented with vector4 widget.
-    VECTOR4 = 17
-    #: Node property represented with float line edit widget.
-    FLOAT = 18
-    #: Node property represented with int line edit widget.
-    INT = 19
-    #: Node property represented with button widget.
-    BUTTON = 20
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+import os
+
+from Qt import QtWidgets
+from enum import Enum
+
+from .pkg_info import __version__ as _v
+
+__doc__ = """
+| The :py:mod:`NodeGraphQt.constants` namespace contains variables and enums 
+ used throughout the NodeGraphQt library.
+"""
+
+# ================================== PRIVATE ===================================
+
+URI_SCHEME = 'nodegraphqt://'
+URN_SCHEME = 'nodegraphqt::'
+
+# PATHS
+BASE_PATH = os.path.dirname(os.path.abspath(__file__))
+ICON_PATH = os.path.join(BASE_PATH, 'widgets', 'icons')
+ICON_DOWN_ARROW = os.path.join(ICON_PATH, 'down_arrow.png')
+ICON_NODE_BASE = os.path.join(ICON_PATH, 'node_base.png')
+
+# DRAW STACK ORDER
+Z_VAL_PIPE = -1
+Z_VAL_NODE = 1
+Z_VAL_PORT = 2
+Z_VAL_NODE_WIDGET = 3
+
+# ITEM CACHE MODE
+# QGraphicsItem.NoCache
+# QGraphicsItem.DeviceCoordinateCache
+# QGraphicsItem.ItemCoordinateCache
+ITEM_CACHE_MODE = QtWidgets.QGraphicsItem.DeviceCoordinateCache
+
+# =================================== GLOBAL ===================================
+
+
+class VersionEnum(Enum):
+    """
+    Current framework version.
+    :py:mod:`NodeGraphQt.constants.VersionEnum`
+    """
+    #: current version string.
+    VERSION = _v
+    #: version major int.
+    MAJOR = int(_v.split('.')[0])
+    #: version minor int.
+    MINOR = int(_v.split('.')[1])
+    #: version patch int.
+    PATCH = int(_v.split('.')[2])
+
+
+class LayoutDirectionEnum(Enum):
+    """
+    Node graph nodes layout direction:
+    :py:mod:`NodeGraphQt.constants.ViewerLayoutEnum`
+    """
+    #: layout nodes left to right.
+    HORIZONTAL = 0
+    #: layout nodes top to bottom.
+    VERTICAL = 1
+
+
+# =================================== VIEWER ===================================
+
+
+class ViewerEnum(Enum):
+    """
+    Node graph viewer styling layout:
+    :py:mod:`NodeGraphQt.constants.ViewerEnum`
+    """
+    #: default background color for the node graph.
+    BACKGROUND_COLOR = (35, 35, 35)
+    #: style node graph background with no grid or dots.
+    GRID_DISPLAY_NONE = 0
+    #: style node graph background with dots.
+    GRID_DISPLAY_DOTS = 1
+    #: style node graph background with grid lines.
+    GRID_DISPLAY_LINES = 2
+    #: grid size when styled with grid lines.
+    GRID_SIZE = 50
+    #: grid line color.
+    GRID_COLOR = (45, 45, 45)
+
+
+class ViewerNavEnum(Enum):
+    """
+    Node graph viewer navigation styling layout:
+    :py:mod:`NodeGraphQt.constants.ViewerNavEnum`
+    """
+    #: default background color.
+    BACKGROUND_COLOR = (25, 25, 25)
+    #: default item color.
+    ITEM_COLOR = (35, 35, 35)
+
+# ==================================== NODE ====================================
+
+
+class NodeEnum(Enum):
+    """
+    Node styling layout:
+    :py:mod:`NodeGraphQt.constants.NodeEnum`
+    """
+    #: default node width.
+    WIDTH = 160
+    #: default node height.
+    HEIGHT = 60
+    #: default node icon size (WxH).
+    ICON_SIZE = 18
+    #: default node overlay color when selected.
+    SELECTED_COLOR = (255, 255, 255, 30)
+    #: default node border color when selected.
+    SELECTED_BORDER_COLOR = (254, 207, 42, 255)
+
+# ==================================== PORT ====================================
+
+
+class PortEnum(Enum):
+    """
+    Port styling layout:
+    :py:mod:`NodeGraphQt.constants.PortEnum`
+    """
+    #: default port size.
+    SIZE = 22.0
+    #: default port color. (r, g, b, a)
+    COLOR = (49, 115, 100, 255)
+    #: default port border color.
+    BORDER_COLOR = (29, 202, 151, 255)
+    #: port color when selected.
+    ACTIVE_COLOR = (14, 45, 59, 255)
+    #: port border color when selected.
+    ACTIVE_BORDER_COLOR = (107, 166, 193, 255)
+    #: port color on mouse over.
+    HOVER_COLOR = (17, 43, 82, 255)
+    #: port border color on mouse over.
+    HOVER_BORDER_COLOR = (136, 255, 35, 255)
+    #: threshold for selecting a port.
+    CLICK_FALLOFF = 15.0
+
+
+class PortTypeEnum(Enum):
+    """
+    Port connection types:
+    :py:mod:`NodeGraphQt.constants.PortTypeEnum`
+    """
+    #: Connection type for input ports.
+    IN = 'in'
+    #: Connection type for output ports.
+    OUT = 'out'
+
+# ==================================== PIPE ====================================
+
+
+class PipeEnum(Enum):
+    """
+    Pipe styling layout:
+    :py:mod:`NodeGraphQt.constants.PipeEnum`
+    """
+    #: default width.
+    WIDTH = 1.2
+    #: default color.
+    COLOR = (175, 95, 30, 255)
+    #: pipe color to a node when it's disabled.
+    DISABLED_COLOR = (200, 60, 60, 255)
+    #: pipe color when selected or mouse over.
+    ACTIVE_COLOR = (70, 255, 220, 255)
+    #: pipe color to a node when it's selected.
+    HIGHLIGHT_COLOR = (232, 184, 13, 255)
+    #: draw connection as a line.
+    DRAW_TYPE_DEFAULT = 0
+    #: draw connection as dashed lines.
+    DRAW_TYPE_DASHED = 1
+    #: draw connection as a dotted line.
+    DRAW_TYPE_DOTTED = 2
+
+
+class PipeSlicerEnum(Enum):
+    """
+    Slicer Pipe styling layout:
+    :py:mod:`NodeGraphQt.constants.PipeSlicerEnum`
+    """
+    #: default width.
+    WIDTH = 1.5
+    #: default color.
+    COLOR = (255, 50, 75)
+
+
+class PipeLayoutEnum(Enum):
+    """
+    Pipe connection drawing layout:
+    :py:mod:`NodeGraphQt.constants.PipeLayoutEnum`
+    """
+    #: draw straight lines for pipe connections.
+    STRAIGHT = 0
+    #: draw curved lines for pipe connections.
+    CURVED = 1
+    #: draw angled lines for pipe connections.
+    ANGLE = 2
+
+
+# === PROPERTY BIN WIDGET ===
+
+class NodePropWidgetEnum(Enum):
+    """
+    Mapping used for the :class:`NodeGraphQt.PropertiesBinWidget` to display a
+    node property in the specified widget type.
+
+    :py:mod:`NodeGraphQt.constants.NodePropWidgetEnum`
+    """
+    #: Node property will be hidden in the ``PropertiesBinWidget`` (default).
+    HIDDEN = 0
+    #: Node property represented with a ``QLabel`` widget.
+    QLABEL = 2
+    #: Node property represented with a ``QLineEdit`` widget.
+    QLINE_EDIT = 3
+    #: Node property represented with a ``QTextEdit`` widget.
+    QTEXT_EDIT = 4
+    #: Node property represented with a ``QComboBox`` widget.
+    QCOMBO_BOX = 5
+    #: Node property represented with a ``QCheckBox`` widget.
+    QCHECK_BOX = 6
+    #: Node property represented with a ``QSpinBox`` widget.
+    QSPIN_BOX = 7
+    #: Node property represented with a ``QDoubleSpinBox`` widget.
+    QDOUBLESPIN_BOX = 8
+    #: Node property represented with a ColorPicker widget.
+    COLOR_PICKER = 9
+    #: Node property represented with a ColorPicker (RGBA) widget.
+    COLOR4_PICKER = 10
+    #: Node property represented with an (Int) Slider widget.
+    SLIDER = 11
+    #: Node property represented with a (Dobule) Slider widget.
+    DOUBLE_SLIDER = 12
+    #: Node property represented with a file selector widget.
+    FILE_OPEN = 13
+    #: Node property represented with a file save widget.
+    FILE_SAVE = 14
+    #: Node property represented with a vector2 widget.
+    VECTOR2 = 15
+    #: Node property represented with vector3 widget.
+    VECTOR3 = 16
+    #: Node property represented with vector4 widget.
+    VECTOR4 = 17
+    #: Node property represented with float line edit widget.
+    FLOAT = 18
+    #: Node property represented with int line edit widget.
+    INT = 19
+    #: Node property represented with button widget.
+    BUTTON = 20
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/nodes_tree.py` & `NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/nodes_tree.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,143 +1,143 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-from Qt import QtWidgets, QtCore, QtGui
-
-from NodeGraphQt.constants import URN_SCHEME
-
-TYPE_NODE = QtWidgets.QTreeWidgetItem.UserType + 1
-TYPE_CATEGORY = QtWidgets.QTreeWidgetItem.UserType + 2
-
-
-class BaseNodeTreeItem(QtWidgets.QTreeWidgetItem):
-
-    def __eq__(self, other):
-        """
-        Workaround fix for QTreeWidgetItem "operator not implemented error".
-        see link: https://bugreports.qt.io/browse/PYSIDE-74
-        """
-        return id(self) == id(other)
-
-
-class NodesTreeWidget(QtWidgets.QTreeWidget):
-    """
-    The :class:`NodeGraphQt.NodesTreeWidget` is a widget for displaying all
-    registered nodes from the node graph with this widget a user can create
-    nodes by dragging and dropping.
-
-    .. inheritance-diagram:: NodeGraphQt.NodesTreeWidget
-        :parts: 1
-        :top-classes: PySide2.QtWidgets.QWidget
-
-    .. image:: _images/nodes_tree.png
-        :width: 300px
-
-    .. code-block:: python
-        :linenos:
-
-        from NodeGraphQt import NodeGraph, NodesTreeWidget
-
-        # create node graph.
-        graph = NodeGraph()
-
-        # create node tree widget.
-        nodes_tree = NodesTreeWidget(parent=None, node_graph=graph)
-        nodes_tree.show()
-
-    Args:
-        parent (QtWidgets.QWidget): parent of the new widget.
-        node_graph (NodeGraphQt.NodeGraph): node graph.
-    """
-
-    def __init__(self, parent=None, node_graph=None):
-        super(NodesTreeWidget, self).__init__(parent)
-        self.setDragDropMode(QtWidgets.QAbstractItemView.DragOnly)
-        self.setSelectionMode(self.ExtendedSelection)
-        self.setHeaderHidden(True)
-        self.setWindowTitle('Nodes')
-
-        self._factory = node_graph.node_factory if node_graph else None
-        self._custom_labels = {}
-        self._category_items = {}
-
-        self._build_tree()
-
-    def __repr__(self):
-        return '<{} object at {}>'.format(
-            self.__class__.__name__, hex(id(self))
-        )
-
-    def mimeData(self, items):
-        node_ids = ['node:{}'.format(i.toolTip(0)) for i in items]
-        node_urn = URN_SCHEME + ';'.join(node_ids)
-        mime_data = super(NodesTreeWidget, self).mimeData(items)
-        mime_data.setUrls([node_urn])
-        return mime_data
-
-    def _build_tree(self):
-        """
-        Populate the node tree.
-        """
-        self.clear()
-        palette = QtGui.QPalette()
-        categories = set()
-        node_types = {}
-        for name, node_ids in self._factory.names.items():
-            for nid in node_ids:
-                categories.add('.'.join(nid.split('.')[:-1]))
-                node_types[nid] = name
-
-        self._category_items = {}
-        for category in sorted(categories):
-            if category in self._custom_labels.keys():
-                label = self._custom_labels[category]
-            else:
-                label = '{}'.format(category)
-            cat_item = BaseNodeTreeItem(self, [label], type=TYPE_CATEGORY)
-            cat_item.setFirstColumnSpanned(True)
-            cat_item.setFlags(QtCore.Qt.ItemIsEnabled)
-            cat_item.setBackground(0, QtGui.QBrush(palette.midlight().color()))
-            cat_item.setSizeHint(0, QtCore.QSize(100, 26))
-            self.addTopLevelItem(cat_item)
-            cat_item.setExpanded(True)
-            self._category_items[category] = cat_item
-
-        for node_id, node_name in node_types.items():
-            category = '.'.join(node_id.split('.')[:-1])
-            category_item = self._category_items[category]
-
-            item = BaseNodeTreeItem(category_item, [node_name], type=TYPE_NODE)
-            item.setToolTip(0, node_id)
-            item.setSizeHint(0, QtCore.QSize(100, 26))
-
-            category_item.addChild(item)
-
-    def _set_node_factory(self, factory):
-        """
-        Set current node factory.
-
-        Args:
-            factory (NodeFactory): node factory.
-        """
-        self._factory = factory
-
-    def set_category_label(self, category, label):
-        """
-        Override the label for a node category root item.
-
-        .. image:: _images/nodes_tree_category_label.png
-            :width: 70%
-
-        Args:
-            category (str): node identifier category eg. ``"nodes.widgets"``
-            label (str): custom display label. eg. ``"Node Widgets"``
-        """
-        self._custom_labels[category] = label
-        if category in self._category_items:
-            item = self._category_items[category]
-            item.setText(0, label)
-
-    def update(self):
-        """
-        Update and refresh the node tree widget.
-        """
-        self._build_tree()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+from Qt import QtWidgets, QtCore, QtGui
+
+from NodeGraphQt.constants import URN_SCHEME
+
+TYPE_NODE = QtWidgets.QTreeWidgetItem.UserType + 1
+TYPE_CATEGORY = QtWidgets.QTreeWidgetItem.UserType + 2
+
+
+class BaseNodeTreeItem(QtWidgets.QTreeWidgetItem):
+
+    def __eq__(self, other):
+        """
+        Workaround fix for QTreeWidgetItem "operator not implemented error".
+        see link: https://bugreports.qt.io/browse/PYSIDE-74
+        """
+        return id(self) == id(other)
+
+
+class NodesTreeWidget(QtWidgets.QTreeWidget):
+    """
+    The :class:`NodeGraphQt.NodesTreeWidget` is a widget for displaying all
+    registered nodes from the node graph with this widget a user can create
+    nodes by dragging and dropping.
+
+    .. inheritance-diagram:: NodeGraphQt.NodesTreeWidget
+        :parts: 1
+        :top-classes: PySide2.QtWidgets.QWidget
+
+    .. image:: _images/nodes_tree.png
+        :width: 300px
+
+    .. code-block:: python
+        :linenos:
+
+        from NodeGraphQt import NodeGraph, NodesTreeWidget
+
+        # create node graph.
+        graph = NodeGraph()
+
+        # create node tree widget.
+        nodes_tree = NodesTreeWidget(parent=None, node_graph=graph)
+        nodes_tree.show()
+
+    Args:
+        parent (QtWidgets.QWidget): parent of the new widget.
+        node_graph (NodeGraphQt.NodeGraph): node graph.
+    """
+
+    def __init__(self, parent=None, node_graph=None):
+        super(NodesTreeWidget, self).__init__(parent)
+        self.setDragDropMode(QtWidgets.QAbstractItemView.DragOnly)
+        self.setSelectionMode(self.ExtendedSelection)
+        self.setHeaderHidden(True)
+        self.setWindowTitle('Nodes')
+
+        self._factory = node_graph.node_factory if node_graph else None
+        self._custom_labels = {}
+        self._category_items = {}
+
+        self._build_tree()
+
+    def __repr__(self):
+        return '<{} object at {}>'.format(
+            self.__class__.__name__, hex(id(self))
+        )
+
+    def mimeData(self, items):
+        node_ids = ['node:{}'.format(i.toolTip(0)) for i in items]
+        node_urn = URN_SCHEME + ';'.join(node_ids)
+        mime_data = super(NodesTreeWidget, self).mimeData(items)
+        mime_data.setUrls([node_urn])
+        return mime_data
+
+    def _build_tree(self):
+        """
+        Populate the node tree.
+        """
+        self.clear()
+        palette = QtGui.QPalette()
+        categories = set()
+        node_types = {}
+        for name, node_ids in self._factory.names.items():
+            for nid in node_ids:
+                categories.add('.'.join(nid.split('.')[:-1]))
+                node_types[nid] = name
+
+        self._category_items = {}
+        for category in sorted(categories):
+            if category in self._custom_labels.keys():
+                label = self._custom_labels[category]
+            else:
+                label = '{}'.format(category)
+            cat_item = BaseNodeTreeItem(self, [label], type=TYPE_CATEGORY)
+            cat_item.setFirstColumnSpanned(True)
+            cat_item.setFlags(QtCore.Qt.ItemIsEnabled)
+            cat_item.setBackground(0, QtGui.QBrush(palette.midlight().color()))
+            cat_item.setSizeHint(0, QtCore.QSize(100, 26))
+            self.addTopLevelItem(cat_item)
+            cat_item.setExpanded(True)
+            self._category_items[category] = cat_item
+
+        for node_id, node_name in node_types.items():
+            category = '.'.join(node_id.split('.')[:-1])
+            category_item = self._category_items[category]
+
+            item = BaseNodeTreeItem(category_item, [node_name], type=TYPE_NODE)
+            item.setToolTip(0, node_id)
+            item.setSizeHint(0, QtCore.QSize(100, 26))
+
+            category_item.addChild(item)
+
+    def _set_node_factory(self, factory):
+        """
+        Set current node factory.
+
+        Args:
+            factory (NodeFactory): node factory.
+        """
+        self._factory = factory
+
+    def set_category_label(self, category, label):
+        """
+        Override the label for a node category root item.
+
+        .. image:: _images/nodes_tree_category_label.png
+            :width: 70%
+
+        Args:
+            category (str): node identifier category eg. ``"nodes.widgets"``
+            label (str): custom display label. eg. ``"Node Widgets"``
+        """
+        self._custom_labels[category] = label
+        if category in self._category_items:
+            item = self._category_items[category]
+            item.setText(0, label)
+
+    def update(self):
+        """
+        Update and refresh the node tree widget.
+        """
+        self._build_tree()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/custom_widget_file_paths.py` & `NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/custom_widget_file_paths.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,76 +1,76 @@
-#!/usr/bin/python
-from Qt import QtWidgets, QtCore
-
-from NodeGraphQt.widgets.dialogs import FileDialog
-from .prop_widgets_abstract import BaseProperty
-
-
-class PropFilePath(BaseProperty):
-    """
-    Displays a node property as a "QFileDialog" open widget in the
-    PropertiesBin.
-    """
-
-    def __init__(self, parent=None):
-        super(PropFilePath, self).__init__(parent)
-        self._ledit = QtWidgets.QLineEdit()
-        self._ledit.setAlignment(QtCore.Qt.AlignLeft)
-        self._ledit.editingFinished.connect(self._on_value_change)
-        self._ledit.clearFocus()
-
-        icon = self.style().standardIcon(QtWidgets.QStyle.StandardPixmap(21))
-        _button = QtWidgets.QPushButton()
-        _button.setIcon(icon)
-        _button.clicked.connect(self._on_select_file)
-
-        hbox = QtWidgets.QHBoxLayout(self)
-        hbox.setContentsMargins(0, 0, 0, 0)
-        hbox.addWidget(self._ledit)
-        hbox.addWidget(_button)
-
-        self._ext = '*'
-        self._file_directory = None
-
-    def _on_select_file(self):
-        file_path = FileDialog.getOpenFileName(self,
-                                               file_dir=self._file_directory,
-                                               ext_filter=self._ext)
-        file = file_path[0] or None
-        if file:
-            self.set_value(file)
-
-    def _on_value_change(self, value=None):
-        if value is None:
-            value = self._ledit.text()
-        self.set_file_directory(value)
-        self.value_changed.emit(self.toolTip(), value)
-
-    def set_file_ext(self, ext=None):
-        self._ext = ext or '*'
-
-    def set_file_directory(self, directory):
-        self._file_directory = directory
-
-    def get_value(self):
-        return self._ledit.text()
-
-    def set_value(self, value):
-        _value = str(value)
-        if _value != self.get_value():
-            self._ledit.setText(_value)
-            self._on_value_change(_value)
-
-
-class PropFileSavePath(PropFilePath):
-    """
-    Displays a node property as a "QFileDialog" save widget in the
-    PropertiesBin.
-    """
-
-    def _on_select_file(self):
-        file_path = FileDialog.getSaveFileName(self,
-                                               file_dir=self._file_directory,
-                                               ext_filter=self._ext)
-        file = file_path[0] or None
-        if file:
-            self.set_value(file)
+#!/usr/bin/python
+from Qt import QtWidgets, QtCore
+
+from NodeGraphQt.widgets.dialogs import FileDialog
+from .prop_widgets_abstract import BaseProperty
+
+
+class PropFilePath(BaseProperty):
+    """
+    Displays a node property as a "QFileDialog" open widget in the
+    PropertiesBin.
+    """
+
+    def __init__(self, parent=None):
+        super(PropFilePath, self).__init__(parent)
+        self._ledit = QtWidgets.QLineEdit()
+        self._ledit.setAlignment(QtCore.Qt.AlignLeft)
+        self._ledit.editingFinished.connect(self._on_value_change)
+        self._ledit.clearFocus()
+
+        icon = self.style().standardIcon(QtWidgets.QStyle.StandardPixmap(21))
+        _button = QtWidgets.QPushButton()
+        _button.setIcon(icon)
+        _button.clicked.connect(self._on_select_file)
+
+        hbox = QtWidgets.QHBoxLayout(self)
+        hbox.setContentsMargins(0, 0, 0, 0)
+        hbox.addWidget(self._ledit)
+        hbox.addWidget(_button)
+
+        self._ext = '*'
+        self._file_directory = None
+
+    def _on_select_file(self):
+        file_path = FileDialog.getOpenFileName(self,
+                                               file_dir=self._file_directory,
+                                               ext_filter=self._ext)
+        file = file_path[0] or None
+        if file:
+            self.set_value(file)
+
+    def _on_value_change(self, value=None):
+        if value is None:
+            value = self._ledit.text()
+        self.set_file_directory(value)
+        self.value_changed.emit(self.toolTip(), value)
+
+    def set_file_ext(self, ext=None):
+        self._ext = ext or '*'
+
+    def set_file_directory(self, directory):
+        self._file_directory = directory
+
+    def get_value(self):
+        return self._ledit.text()
+
+    def set_value(self, value):
+        _value = str(value)
+        if _value != self.get_value():
+            self._ledit.setText(_value)
+            self._on_value_change(_value)
+
+
+class PropFileSavePath(PropFilePath):
+    """
+    Displays a node property as a "QFileDialog" save widget in the
+    PropertiesBin.
+    """
+
+    def _on_select_file(self):
+        file_path = FileDialog.getSaveFileName(self,
+                                               file_dir=self._file_directory,
+                                               ext_filter=self._ext)
+        file = file_path[0] or None
+        if file:
+            self.set_value(file)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/custom_widget_slider.py` & `NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/custom_widget_slider.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,132 +1,132 @@
-#!/usr/bin/python
-from Qt import QtWidgets, QtCore
-
-from .prop_widgets_abstract import BaseProperty
-
-
-class PropSlider(BaseProperty):
-    """
-    Displays a node property as a "Slider" widget in the PropertiesBin
-    widget.
-    """
-
-    def __init__(self, parent=None, disable_scroll=True, realtime_update=False):
-        super(PropSlider, self).__init__(parent)
-        self._block = False
-        self._realtime_update = realtime_update
-        self._disable_scroll = disable_scroll
-        self._slider = QtWidgets.QSlider()
-        self._spinbox = QtWidgets.QSpinBox()
-        self._init()
-        self._init_signal_connections()
-
-    def _init(self):
-        self._slider.setOrientation(QtCore.Qt.Horizontal)
-        self._slider.setTickPosition(QtWidgets.QSlider.TicksBelow)
-        self._slider.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
-                                   QtWidgets.QSizePolicy.Preferred)
-        self._spinbox.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
-        layout = QtWidgets.QHBoxLayout(self)
-        layout.setContentsMargins(0, 0, 0, 0)
-        layout.addWidget(self._spinbox)
-        layout.addWidget(self._slider)
-        # store the original press event.
-        self._slider_mouse_press_event = self._slider.mousePressEvent
-        self._slider.mousePressEvent = self._on_slider_mouse_press
-        self._slider.mouseReleaseEvent = self._on_slider_mouse_release
-
-        if self._disable_scroll:
-            self._slider.wheelEvent = lambda _: None
-            self._spinbox.wheelEvent = lambda _: None
-
-    def _init_signal_connections(self):
-        self._spinbox.valueChanged.connect(self._on_spnbox_changed)
-        self._slider.valueChanged.connect(self._on_slider_changed)
-
-    def _on_slider_mouse_press(self, event):
-        self._block = True
-        self._slider_mouse_press_event(event)
-
-    def _on_slider_mouse_release(self, event):
-        if not self._realtime_update:
-            self.value_changed.emit(self.toolTip(), self.get_value())
-        self._block = False
-
-    def _on_slider_changed(self, value):
-        self._spinbox.setValue(value)
-        if self._realtime_update:
-            self.value_changed.emit(self.toolTip(), self.get_value())
-
-    def _on_spnbox_changed(self, value):
-        if value != self._slider.value():
-            self._slider.setValue(value)
-            if not self._block:
-                self.value_changed.emit(self.toolTip(), self.get_value())
-
-    def get_value(self):
-        return self._spinbox.value()
-
-    def set_value(self, value):
-        if value != self.get_value():
-            self._block = True
-            self._spinbox.setValue(value)
-            self.value_changed.emit(self.toolTip(), value)
-            self._block = False
-
-    def set_min(self, value=0):
-        self._spinbox.setMinimum(value)
-        self._slider.setMinimum(value)
-
-    def set_max(self, value=0):
-        self._spinbox.setMaximum(value)
-        self._slider.setMaximum(value)
-
-
-class QDoubleSlider(QtWidgets.QSlider):
-    double_value_changed = QtCore.Signal(float)
-
-    def __init__(self, decimals=2, *args, **kargs):
-        super(QDoubleSlider, self).__init__(*args, **kargs)
-        self._multiplier = 10 ** decimals
-
-        self.valueChanged.connect(self._on_value_change)
-
-    def _on_value_change(self):
-        value = float(super(QDoubleSlider, self).value()) / self._multiplier
-        self.double_value_changed.emit(value)
-
-    def value(self):
-        return float(super(QDoubleSlider, self).value()) / self._multiplier
-
-    def setMinimum(self, value):
-        return super(QDoubleSlider, self).setMinimum(value * self._multiplier)
-
-    def setMaximum(self, value):
-        return super(QDoubleSlider, self).setMaximum(value * self._multiplier)
-
-    def setSingleStep(self, value):
-        return super(QDoubleSlider, self).setSingleStep(value * self._multiplier)
-
-    def singleStep(self):
-        return float(super(QDoubleSlider, self).singleStep()) / self._multiplier
-
-    def setValue(self, value):
-        super(QDoubleSlider, self).setValue(int(value * self._multiplier))
-
-
-class PropDoubleSlider(PropSlider):
-    def __init__(self, parent=None, decimals=2, disable_scroll=True, realtime_update=False):
-        # Do not initialize Propslider, just its parents
-        super(PropSlider, self).__init__(parent)
-        self._block = False
-        self._realtime_update = realtime_update
-        self._disable_scroll = disable_scroll
-        self._slider = QDoubleSlider(decimals=decimals)
-        self._spinbox = QtWidgets.QDoubleSpinBox()
-        self._init()
-        self._init_signal_connections()
-
-    def _init_signal_connections(self):
-        self._spinbox.valueChanged.connect(self._on_spnbox_changed)
-        # Connect to double_value_changed instead valueChanged
-        self._slider.double_value_changed.connect(self._on_slider_changed)
+#!/usr/bin/python
+from Qt import QtWidgets, QtCore
+
+from .prop_widgets_abstract import BaseProperty
+
+
+class PropSlider(BaseProperty):
+    """
+    Displays a node property as a "Slider" widget in the PropertiesBin
+    widget.
+    """
+
+    def __init__(self, parent=None, disable_scroll=True, realtime_update=False):
+        super(PropSlider, self).__init__(parent)
+        self._block = False
+        self._realtime_update = realtime_update
+        self._disable_scroll = disable_scroll
+        self._slider = QtWidgets.QSlider()
+        self._spinbox = QtWidgets.QSpinBox()
+        self._init()
+        self._init_signal_connections()
+
+    def _init(self):
+        self._slider.setOrientation(QtCore.Qt.Horizontal)
+        self._slider.setTickPosition(QtWidgets.QSlider.TicksBelow)
+        self._slider.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
+                                   QtWidgets.QSizePolicy.Preferred)
+        self._spinbox.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
+        layout = QtWidgets.QHBoxLayout(self)
+        layout.setContentsMargins(0, 0, 0, 0)
+        layout.addWidget(self._spinbox)
+        layout.addWidget(self._slider)
+        # store the original press event.
+        self._slider_mouse_press_event = self._slider.mousePressEvent
+        self._slider.mousePressEvent = self._on_slider_mouse_press
+        self._slider.mouseReleaseEvent = self._on_slider_mouse_release
+
+        if self._disable_scroll:
+            self._slider.wheelEvent = lambda _: None
+            self._spinbox.wheelEvent = lambda _: None
+
+    def _init_signal_connections(self):
+        self._spinbox.valueChanged.connect(self._on_spnbox_changed)
+        self._slider.valueChanged.connect(self._on_slider_changed)
+
+    def _on_slider_mouse_press(self, event):
+        self._block = True
+        self._slider_mouse_press_event(event)
+
+    def _on_slider_mouse_release(self, event):
+        if not self._realtime_update:
+            self.value_changed.emit(self.toolTip(), self.get_value())
+        self._block = False
+
+    def _on_slider_changed(self, value):
+        self._spinbox.setValue(value)
+        if self._realtime_update:
+            self.value_changed.emit(self.toolTip(), self.get_value())
+
+    def _on_spnbox_changed(self, value):
+        if value != self._slider.value():
+            self._slider.setValue(value)
+            if not self._block:
+                self.value_changed.emit(self.toolTip(), self.get_value())
+
+    def get_value(self):
+        return self._spinbox.value()
+
+    def set_value(self, value):
+        if value != self.get_value():
+            self._block = True
+            self._spinbox.setValue(value)
+            self.value_changed.emit(self.toolTip(), value)
+            self._block = False
+
+    def set_min(self, value=0):
+        self._spinbox.setMinimum(value)
+        self._slider.setMinimum(value)
+
+    def set_max(self, value=0):
+        self._spinbox.setMaximum(value)
+        self._slider.setMaximum(value)
+
+
+class QDoubleSlider(QtWidgets.QSlider):
+    double_value_changed = QtCore.Signal(float)
+
+    def __init__(self, decimals=2, *args, **kargs):
+        super(QDoubleSlider, self).__init__(*args, **kargs)
+        self._multiplier = 10 ** decimals
+
+        self.valueChanged.connect(self._on_value_change)
+
+    def _on_value_change(self):
+        value = float(super(QDoubleSlider, self).value()) / self._multiplier
+        self.double_value_changed.emit(value)
+
+    def value(self):
+        return float(super(QDoubleSlider, self).value()) / self._multiplier
+
+    def setMinimum(self, value):
+        return super(QDoubleSlider, self).setMinimum(value * self._multiplier)
+
+    def setMaximum(self, value):
+        return super(QDoubleSlider, self).setMaximum(value * self._multiplier)
+
+    def setSingleStep(self, value):
+        return super(QDoubleSlider, self).setSingleStep(value * self._multiplier)
+
+    def singleStep(self):
+        return float(super(QDoubleSlider, self).singleStep()) / self._multiplier
+
+    def setValue(self, value):
+        super(QDoubleSlider, self).setValue(int(value * self._multiplier))
+
+
+class PropDoubleSlider(PropSlider):
+    def __init__(self, parent=None, decimals=2, disable_scroll=True, realtime_update=False):
+        # Do not initialize Propslider, just its parents
+        super(PropSlider, self).__init__(parent)
+        self._block = False
+        self._realtime_update = realtime_update
+        self._disable_scroll = disable_scroll
+        self._slider = QDoubleSlider(decimals=decimals)
+        self._spinbox = QtWidgets.QDoubleSpinBox()
+        self._init()
+        self._init_signal_connections()
+
+    def _init_signal_connections(self):
+        self._spinbox.valueChanged.connect(self._on_spnbox_changed)
+        # Connect to double_value_changed instead valueChanged
+        self._slider.double_value_changed.connect(self._on_slider_changed)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/custom_widget_vectors.py` & `NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/custom_widget_vectors.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,102 +1,102 @@
-#!/usr/bin/python
-from Qt import QtWidgets
-
-from .custom_widget_value_edit import _NumberValueEdit
-from .prop_widgets_abstract import BaseProperty
-
-
-class _PropVector(BaseProperty):
-    """
-    Base widget for the PropVector widgets.
-    """
-
-    def __init__(self, parent=None, fields=0):
-        super(_PropVector, self).__init__(parent)
-        self._value = []
-        self._items = []
-        self._can_emit = True
-
-        layout = QtWidgets.QHBoxLayout(self)
-        layout.setSpacing(2)
-        layout.setContentsMargins(0, 0, 0, 0)
-        for i in range(fields):
-            self._add_item(i)
-
-    def _add_item(self, index):
-        _ledit = _NumberValueEdit()
-        _ledit.index = index
-        _ledit.valueChanged.connect(
-            lambda: self._on_value_change(_ledit.get_value(), _ledit.index)
-        )
-
-        self.layout().addWidget(_ledit)
-        self._value.append(0.0)
-        self._items.append(_ledit)
-
-    def _on_value_change(self, value=None, index=None):
-        if self._can_emit:
-            if index is not None:
-                self._value = list(self._value)
-                self._value[index] = value
-            self.value_changed.emit(self.toolTip(), self._value)
-
-    def _update_items(self):
-        if not isinstance(self._value, (list, tuple)):
-            raise TypeError('Value "{}" must be either list or tuple.'
-                            .format(self._value))
-        for index, value in enumerate(self._value):
-            if (index + 1) > len(self._items):
-                continue
-            if self._items[index].get_value() != value:
-                self._items[index].set_value(value)
-
-    def set_data_type(self, data_type):
-        for item in self._items:
-            item.set_data_type(data_type)
-
-    def get_value(self):
-        return self._value
-
-    def set_value(self, value=None):
-        if value != self.get_value():
-            self._value = value
-            self._can_emit = False
-            self._update_items()
-            self._can_emit = True
-            self._on_value_change()
-
-
-class PropVector2(_PropVector):
-    """
-    Displays a node property as a "Vector2" widget in the PropertiesBin
-    widget.
-
-    Useful for display X,Y data.
-    """
-
-    def __init__(self, parent=None):
-        super(PropVector2, self).__init__(parent, 2)
-
-
-class PropVector3(_PropVector):
-    """
-    Displays a node property as a "Vector3" widget in the PropertiesBin
-    widget.
-
-    Useful for displaying x,y,z data.
-    """
-
-    def __init__(self, parent=None):
-        super(PropVector3, self).__init__(parent, 3)
-
-
-class PropVector4(_PropVector):
-    """
-    Displays a node property as a "Vector4"  widget in the PropertiesBin
-    widget.
-
-    Useful for display r,g,b,a data.
-    """
-
-    def __init__(self, parent=None):
-        super(PropVector4, self).__init__(parent, 4)
+#!/usr/bin/python
+from Qt import QtWidgets
+
+from .custom_widget_value_edit import _NumberValueEdit
+from .prop_widgets_abstract import BaseProperty
+
+
+class _PropVector(BaseProperty):
+    """
+    Base widget for the PropVector widgets.
+    """
+
+    def __init__(self, parent=None, fields=0):
+        super(_PropVector, self).__init__(parent)
+        self._value = []
+        self._items = []
+        self._can_emit = True
+
+        layout = QtWidgets.QHBoxLayout(self)
+        layout.setSpacing(2)
+        layout.setContentsMargins(0, 0, 0, 0)
+        for i in range(fields):
+            self._add_item(i)
+
+    def _add_item(self, index):
+        _ledit = _NumberValueEdit()
+        _ledit.index = index
+        _ledit.valueChanged.connect(
+            lambda: self._on_value_change(_ledit.get_value(), _ledit.index)
+        )
+
+        self.layout().addWidget(_ledit)
+        self._value.append(0.0)
+        self._items.append(_ledit)
+
+    def _on_value_change(self, value=None, index=None):
+        if self._can_emit:
+            if index is not None:
+                self._value = list(self._value)
+                self._value[index] = value
+            self.value_changed.emit(self.toolTip(), self._value)
+
+    def _update_items(self):
+        if not isinstance(self._value, (list, tuple)):
+            raise TypeError('Value "{}" must be either list or tuple.'
+                            .format(self._value))
+        for index, value in enumerate(self._value):
+            if (index + 1) > len(self._items):
+                continue
+            if self._items[index].get_value() != value:
+                self._items[index].set_value(value)
+
+    def set_data_type(self, data_type):
+        for item in self._items:
+            item.set_data_type(data_type)
+
+    def get_value(self):
+        return self._value
+
+    def set_value(self, value=None):
+        if value != self.get_value():
+            self._value = value
+            self._can_emit = False
+            self._update_items()
+            self._can_emit = True
+            self._on_value_change()
+
+
+class PropVector2(_PropVector):
+    """
+    Displays a node property as a "Vector2" widget in the PropertiesBin
+    widget.
+
+    Useful for display X,Y data.
+    """
+
+    def __init__(self, parent=None):
+        super(PropVector2, self).__init__(parent, 2)
+
+
+class PropVector3(_PropVector):
+    """
+    Displays a node property as a "Vector3" widget in the PropertiesBin
+    widget.
+
+    Useful for displaying x,y,z data.
+    """
+
+    def __init__(self, parent=None):
+        super(PropVector3, self).__init__(parent, 3)
+
+
+class PropVector4(_PropVector):
+    """
+    Displays a node property as a "Vector4"  widget in the PropertiesBin
+    widget.
+
+    Useful for display r,g,b,a data.
+    """
+
+    def __init__(self, parent=None):
+        super(PropVector4, self).__init__(parent, 4)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/node_property_widgets.py` & `NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/node_property_widgets.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,629 +1,629 @@
-#!/usr/bin/python
-from collections import defaultdict
-
-from Qt import QtWidgets, QtCore, QtGui, QtCompat
-
-from .node_property_factory import NodePropertyWidgetFactory
-from .prop_widgets_base import PropLineEdit
-
-
-class _PropertiesDelegate(QtWidgets.QStyledItemDelegate):
-
-    def paint(self, painter, option, index):
-        """
-        Args:
-            painter (QtGui.QPainter):
-            option (QtGui.QStyleOptionViewItem):
-            index (QtCore.QModelIndex):
-        """
-        painter.save()
-        painter.setRenderHint(QtGui.QPainter.Antialiasing, False)
-        painter.setPen(QtCore.Qt.NoPen)
-
-        # draw background.
-        bg_clr = option.palette.midlight().color()
-        painter.setBrush(QtGui.QBrush(bg_clr))
-        painter.drawRect(option.rect)
-
-        # draw border.
-        border_width = 1
-        if option.state & QtWidgets.QStyle.State_Selected:
-            bdr_clr = option.palette.highlight().color()
-            painter.setPen(QtGui.QPen(bdr_clr, 1.5))
-        else:
-            bdr_clr = option.palette.alternateBase().color()
-            painter.setPen(QtGui.QPen(bdr_clr, 1))
-
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.drawRect(QtCore.QRect(
-            option.rect.x() + border_width,
-            option.rect.y() + border_width,
-            option.rect.width() - (border_width * 2),
-            option.rect.height() - (border_width * 2))
-        )
-        painter.restore()
-
-
-class _PropertiesList(QtWidgets.QTableWidget):
-
-    def __init__(self, parent=None):
-        super(_PropertiesList, self).__init__(parent)
-        self.setItemDelegate(_PropertiesDelegate())
-        self.setColumnCount(1)
-        self.setShowGrid(False)
-        self.verticalHeader().hide()
-        self.horizontalHeader().hide()
-
-        QtCompat.QHeaderView.setSectionResizeMode(
-            self.verticalHeader(), QtWidgets.QHeaderView.ResizeToContents)
-        QtCompat.QHeaderView.setSectionResizeMode(
-            self.horizontalHeader(), 0, QtWidgets.QHeaderView.Stretch)
-        self.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
-
-    def wheelEvent(self, event):
-        """
-        Args:
-            event (QtGui.QWheelEvent):
-        """
-        delta = event.angleDelta().y() * 0.2
-        self.verticalScrollBar().setValue(
-            self.verticalScrollBar().value() - delta
-        )
-
-
-class _PropertiesContainer(QtWidgets.QWidget):
-    """
-    Node properties container widget that displays nodes properties under
-    a tab in the ``NodePropWidget`` widget.
-    """
-
-    def __init__(self, parent=None):
-        super(_PropertiesContainer, self).__init__(parent)
-        self.__layout = QtWidgets.QGridLayout()
-        self.__layout.setColumnStretch(1, 1)
-        self.__layout.setSpacing(6)
-
-        layout = QtWidgets.QVBoxLayout(self)
-        layout.setAlignment(QtCore.Qt.AlignTop)
-        layout.addLayout(self.__layout)
-
-    def __repr__(self):
-        return '<{} object at {}>'.format(
-            self.__class__.__name__, hex(id(self))
-        )
-
-    def add_widget(self, name, widget, value, label=None):
-        """
-        Add a property widget to the window.
-
-        Args:
-            name (str): property name to be displayed.
-            widget (BaseProperty): property widget.
-            value (object): property value.
-            label (str): custom label to display.
-        """
-        widget.setToolTip(name)
-        widget.set_value(value)
-        if label is None:
-            label = name
-        row = self.__layout.rowCount()
-        if row > 0:
-            row += 1
-
-        label_flags = QtCore.Qt.AlignCenter | QtCore.Qt.AlignRight
-        if widget.__class__.__name__ == 'PropTextEdit':
-            label_flags = label_flags | QtCore.Qt.AlignTop
-
-        self.__layout.addWidget(QtWidgets.QLabel(label), row, 0, label_flags)
-        self.__layout.addWidget(widget, row, 1)
-
-    def get_widget(self, name):
-        """
-        Returns the property widget from the name.
-
-        Args:
-            name (str): property name.
-
-        Returns:
-            QtWidgets.QWidget: property widget.
-        """
-        for row in range(self.__layout.rowCount()):
-            item = self.__layout.itemAtPosition(row, 1)
-            if item and name == item.widget().toolTip():
-                return item.widget()
-
-
-class NodePropWidget(QtWidgets.QWidget):
-    """
-    Node properties widget for display a Node object.
-
-    Args:
-        parent (QtWidgets.QWidget): parent object.
-        node (NodeGraphQt.BaseNode): node.
-    """
-
-    #: signal (node_id, prop_name, prop_value)
-    property_changed = QtCore.Signal(str, str, object)
-    property_closed = QtCore.Signal(str)
-
-    def __init__(self, parent=None, node=None):
-        super(NodePropWidget, self).__init__(parent)
-        self.__node_id = node.id
-        self.__tab_windows = {}
-        self.__tab = QtWidgets.QTabWidget()
-
-        close_btn = QtWidgets.QPushButton()
-        close_btn.setIcon(QtGui.QIcon(
-            self.style().standardPixmap(QtWidgets.QStyle.SP_DialogCancelButton)
-        ))
-        close_btn.setMaximumWidth(40)
-        close_btn.setToolTip('close property')
-        close_btn.clicked.connect(self._on_close)
-
-        self.name_wgt = PropLineEdit()
-        self.name_wgt.setToolTip('name')
-        self.name_wgt.set_value(node.name())
-        self.name_wgt.value_changed.connect(self._on_property_changed)
-
-        self.type_wgt = QtWidgets.QLabel(node.type_)
-        self.type_wgt.setAlignment(QtCore.Qt.AlignRight)
-        self.type_wgt.setToolTip('type_')
-        font = self.type_wgt.font()
-        font.setPointSize(10)
-        self.type_wgt.setFont(font)
-
-        name_layout = QtWidgets.QHBoxLayout()
-        name_layout.setContentsMargins(0, 0, 0, 0)
-        name_layout.addWidget(QtWidgets.QLabel('name'))
-        name_layout.addWidget(self.name_wgt)
-        name_layout.addWidget(close_btn)
-        layout = QtWidgets.QVBoxLayout(self)
-        layout.setSpacing(4)
-        layout.addLayout(name_layout)
-        layout.addWidget(self.__tab)
-        layout.addWidget(self.type_wgt)
-        self._read_node(node)
-
-    def __repr__(self):
-        return '<{} object at {}>'.format(
-            self.__class__.__name__, hex(id(self))
-        )
-
-    def _on_close(self):
-        """
-        called by the close button.
-        """
-        self.property_closed.emit(self.__node_id)
-
-    def _on_property_changed(self, name, value):
-        """
-        slot function called when a property widget has changed.
-
-        Args:
-            name (str): property name.
-            value (object): new value.
-        """
-        self.property_changed.emit(self.__node_id, name, value)
-
-    def _read_node(self, node):
-        """
-        Populate widget from a node.
-
-        Args:
-            node (NodeGraphQt.BaseNode): node class.
-        """
-        model = node.model
-        graph_model = node.graph.model
-
-        common_props = graph_model.get_node_common_properties(node.type_)
-
-        # sort tabs and properties.
-        tab_mapping = defaultdict(list)
-        for prop_name, prop_val in model.custom_properties.items():
-            tab_name = model.get_tab_name(prop_name)
-            tab_mapping[tab_name].append((prop_name, prop_val))
-
-        # add tabs.
-        for tab in sorted(tab_mapping.keys()):
-            if tab != 'Node':
-                self.add_tab(tab)
-
-        # property widget factory.
-        widget_factory = NodePropertyWidgetFactory()
-
-        # populate tab properties.
-        for tab in sorted(tab_mapping.keys()):
-            prop_window = self.__tab_windows[tab]
-            for prop_name, value in tab_mapping[tab]:
-                wid_type = model.get_widget_type(prop_name)
-                if wid_type == 0:
-                    continue
-
-                widget = widget_factory.get_widget(wid_type)
-                if prop_name in common_props.keys():
-                    if 'items' in common_props[prop_name].keys():
-                        widget.set_items(common_props[prop_name]['items'])
-                    if 'range' in common_props[prop_name].keys():
-                        prop_range = common_props[prop_name]['range']
-                        widget.set_min(prop_range[0])
-                        widget.set_max(prop_range[1])
-
-                prop_window.add_widget(prop_name, widget, value,
-                                       prop_name.replace('_', ' '))
-                widget.value_changed.connect(self._on_property_changed)
-
-        # add "Node" tab properties.
-        self.add_tab('Node')
-        default_props = ['color', 'text_color', 'disabled', 'id']
-        prop_window = self.__tab_windows['Node']
-        for prop_name in default_props:
-            wid_type = model.get_widget_type(prop_name)
-            widget = widget_factory.get_widget(wid_type)
-            prop_window.add_widget(prop_name,
-                                   widget,
-                                   model.get_property(prop_name),
-                                   prop_name.replace('_', ' '))
-
-            widget.value_changed.connect(self._on_property_changed)
-
-        self.type_wgt.setText(model.get_property('type_'))
-
-    def node_id(self):
-        """
-        Returns the node id linked to the widget.
-
-        Returns:
-            str: node id
-        """
-        return self.__node_id
-
-    def add_widget(self, name, widget, tab='Properties'):
-        """
-        add new node property widget.
-
-        Args:
-            name (str): property name.
-            widget (BaseProperty): property widget.
-            tab (str): tab name.
-        """
-        if tab not in self._widgets.keys():
-            tab = 'Properties'
-        window = self.__tab_windows[tab]
-        window.add_widget(name, widget)
-        widget.value_changed.connect(self._on_property_changed)
-
-    def add_tab(self, name):
-        """
-        add a new tab.
-
-        Args:
-            name (str): tab name.
-
-        Returns:
-            PropListWidget: tab child widget.
-        """
-        if name in self.__tab_windows.keys():
-            raise AssertionError('Tab name {} already taken!'.format(name))
-        self.__tab_windows[name] = _PropertiesContainer(self)
-        self.__tab.addTab(self.__tab_windows[name], name)
-        return self.__tab_windows[name]
-
-    def get_widget(self, name):
-        """
-        get property widget.
-
-        Args:
-            name (str): property name.
-
-        Returns:
-            QtWidgets.QWidget: property widget.
-        """
-        if name == 'name':
-            return self.name_wgt
-        for tab_name, prop_win in self.__tab_windows.items():
-            widget = prop_win.get_widget(name)
-            if widget:
-                return widget
-
-
-class PropertiesBinWidget(QtWidgets.QWidget):
-    """
-    The :class:`NodeGraphQt.PropertiesBinWidget` is a list widget for displaying
-    and editing a nodes properties.
-
-    .. inheritance-diagram:: NodeGraphQt.PropertiesBinWidget
-        :parts: 1
-
-    .. image:: _images/prop_bin.png
-        :width: 950px
-
-    .. code-block:: python
-        :linenos:
-
-        from NodeGraphQt import NodeGraph, PropertiesBinWidget
-
-        # create node graph.
-        graph = NodeGraph()
-
-        # create properties bin widget.
-        properties_bin = PropertiesBinWidget(parent=None, node_graph=graph)
-        properties_bin.show()
-
-    See Also:
-            :meth:`NodeGraphQt.BaseNode.add_custom_widget`,
-            :meth:`NodeGraphQt.NodeObject.create_property`,
-            :attr:`NodeGraphQt.constants.NodePropWidgetEnum`
-
-    Args:
-        parent (QtWidgets.QWidget): parent of the new widget.
-        node_graph (NodeGraphQt.NodeGraph): node graph.
-    """
-
-    #: Signal emitted (node_id, prop_name, prop_value)
-    property_changed = QtCore.Signal(str, str, object)
-
-    def __init__(self, parent=None, node_graph=None):
-        super(PropertiesBinWidget, self).__init__(parent)
-        self.setWindowTitle('Properties Bin')
-        self._prop_list = _PropertiesList()
-        self._limit = QtWidgets.QSpinBox()
-        self._limit.setToolTip('Set display nodes limit.')
-        self._limit.setMaximum(10)
-        self._limit.setMinimum(0)
-        self._limit.setValue(2)
-        self._limit.valueChanged.connect(self.__on_limit_changed)
-        self.resize(450, 400)
-
-        self._block_signal = False
-
-        self._lock = False
-        self.btn_lock = QtWidgets.QPushButton('Lock')
-        self.btn_lock.setToolTip(
-            'Lock the properties bin prevent nodes from being loaded.')
-        self.btn_lock.clicked.connect(self.lock_bin)
-
-        btn_clr = QtWidgets.QPushButton('Clear')
-        btn_clr.setToolTip('Clear the properties bin.')
-        btn_clr.clicked.connect(self.clear_bin)
-
-        top_layout = QtWidgets.QHBoxLayout()
-        top_layout.setSpacing(2)
-        top_layout.addWidget(self._limit)
-        top_layout.addStretch(1)
-        top_layout.addWidget(self.btn_lock)
-        top_layout.addWidget(btn_clr)
-
-        layout = QtWidgets.QVBoxLayout(self)
-        layout.addLayout(top_layout)
-        layout.addWidget(self._prop_list, 1)
-
-        # wire up node graph.
-        node_graph.add_properties_bin(self)
-        node_graph.node_double_clicked.connect(self.add_node)
-        node_graph.nodes_deleted.connect(self.__on_nodes_deleted)
-        node_graph.property_changed.connect(self.__on_graph_property_changed)
-
-    def __repr__(self):
-        return '<{} object at {}>'.format(self.__class__.__name__, hex(id(self)))
-
-    def __on_prop_close(self, node_id):
-        items = self._prop_list.findItems(node_id, QtCore.Qt.MatchExactly)
-        [self._prop_list.removeRow(i.row()) for i in items]
-
-    def __on_limit_changed(self, value):
-        rows = self._prop_list.rowCount()
-        if rows > value:
-            self._prop_list.removeRow(rows - 1)
-
-    def __on_nodes_deleted(self, nodes):
-        """
-        Slot function when a node has been deleted.
-
-        Args:
-            nodes (list[str]): list of node ids.
-        """
-        [self.__on_prop_close(n) for n in nodes]
-
-    def __on_graph_property_changed(self, node, prop_name, prop_value):
-        """
-        Slot function that updates the property bin from the node graph signal.
-
-        Args:
-            node (NodeGraphQt.NodeObject):
-            prop_name (str): node property name.
-            prop_value (object): node property value.
-        """
-        properties_widget = self.prop_widget(node)
-        if not properties_widget:
-            return
-
-        property_window = properties_widget.get_widget(prop_name)
-
-        if property_window and prop_value != property_window.get_value():
-            self._block_signal = True
-            property_window.set_value(prop_value)
-            self._block_signal = False
-
-    def __on_property_widget_changed(self, node_id, prop_name, prop_value):
-        """
-        Slot function triggered when a property widget value has changed.
-
-        Args:
-            node_id (str): node id.
-            prop_name (str): node property name.
-            prop_value (object): node property value.
-        """
-        if not self._block_signal:
-            self.property_changed.emit(node_id, prop_name, prop_value)
-
-    def limit(self):
-        """
-        Returns the limit for how many nodes can be loaded into the bin.
-
-        Returns:
-            int: node limit.
-        """
-        return int(self._limit.value())
-
-    def set_limit(self, limit):
-        """
-        Set limit of nodes to display.
-
-        Args:
-            limit (int): node limit.
-        """
-        self._limit.setValue(limit)
-
-    def add_node(self, node):
-        """
-        Add node to the properties bin.
-
-        Args:
-            node (NodeGraphQt.NodeObject): node object.
-        """
-        if self.limit() == 0 or self._lock:
-            return
-
-        rows = self._prop_list.rowCount()
-        if rows >= self.limit():
-            self._prop_list.removeRow(rows - 1)
-
-        itm_find = self._prop_list.findItems(node.id, QtCore.Qt.MatchExactly)
-        if itm_find:
-            self._prop_list.removeRow(itm_find[0].row())
-
-        self._prop_list.insertRow(0)
-        prop_widget = NodePropWidget(node=node)
-        prop_widget.property_changed.connect(self.__on_property_widget_changed)
-        prop_widget.property_closed.connect(self.__on_prop_close)
-        self._prop_list.setCellWidget(0, 0, prop_widget)
-
-        item = QtWidgets.QTableWidgetItem(node.id)
-        self._prop_list.setItem(0, 0, item)
-        self._prop_list.selectRow(0)
-
-    def remove_node(self, node):
-        """
-        Remove node from the properties bin.
-
-        Args:
-            node (str or NodeGraphQt.BaseNode): node id or node object.
-        """
-        node_id = node if isinstance(node, str) else node.id
-        self.__on_prop_close(node_id)
-
-    def lock_bin(self):
-        """
-        Lock/UnLock the properties bin.
-        """
-        self._lock = not self._lock
-        if self._lock:
-            self.btn_lock.setText('UnLock')
-        else:
-            self.btn_lock.setText('Lock')
-
-    def clear_bin(self):
-        """
-        Clear the properties bin.
-        """
-        self._prop_list.setRowCount(0)
-
-    def prop_widget(self, node):
-        """
-        Returns the node property widget.
-
-        Args:
-            node (str or NodeGraphQt.NodeObject): node id or node object.
-
-        Returns:
-            NodePropWidget: node property widget.
-        """
-        node_id = node if isinstance(node, str) else node.id
-        itm_find = self._prop_list.findItems(node_id, QtCore.Qt.MatchExactly)
-        if itm_find:
-            item = itm_find[0]
-            return self._prop_list.cellWidget(item.row(), 0)
-
-
-if __name__ == '__main__':
-    import sys
-    from NodeGraphQt import BaseNode, NodeGraph
-    from NodeGraphQt.constants import NodePropWidgetEnum
-
-
-    class _TestNode(BaseNode):
-
-        __identifier__ = 'property.test'
-        NODE_NAME = 'test node'
-
-        def __init__(self):
-            super(_TestNode, self).__init__()
-            self.create_property(
-                'label_test',
-                value='foo bar',
-                widget_type=NodePropWidgetEnum.QLABEL.value
-            )
-            self.create_property(
-                'text_edit',
-                value='text edit test',
-                widget_type=NodePropWidgetEnum.QLABEL.value
-            )
-            self.create_property(
-                "file",
-                value="",
-                widget_type=NodePropWidgetEnum.FILE_OPEN.value
-            )
-            self.create_property(
-                'color_picker',
-                value=(0, 0, 255),
-                widget_type=NodePropWidgetEnum.COLOR_PICKER.value
-            )
-            self.create_property(
-                'integer',
-                value=10,
-                widget_type=NodePropWidgetEnum.QSPIN_BOX.value
-            )
-            self.create_property(
-                'list',
-                value='itm2',
-                items=['itm1', 'itm2', 'itm3'],
-                widget_type=NodePropWidgetEnum.QCOMBO_BOX.value
-            )
-            self.create_property(
-                'range',
-                value=50,
-                range=(45, 55),
-                widget_type=NodePropWidgetEnum.SLIDER.value
-            )
-            self.create_property(
-                'float_range',
-                value=150.5,
-                range=(50.5, 200),
-                widget_type=NodePropWidgetEnum.DOUBLE_SLIDER.value
-            )
-            self.create_property(
-                'color4_picker',
-                value=(255, 0, 0, 122),
-                widget_type=NodePropWidgetEnum.COLOR4_PICKER.value
-            )
-
-    def _prop_changed(node_id, prop_name, prop_value):
-        print('-'*100)
-        print(node_id, prop_name, prop_value)
-
-
-    app = QtWidgets.QApplication(sys.argv)
-
-    graph = NodeGraph()
-    graph.register_node(_TestNode)
-
-    prop_bin = PropertiesBinWidget(node_graph=graph)
-    prop_bin.resize(800, 600)
-    prop_bin.property_changed.connect(_prop_changed)
-
-    node = graph.create_node('property.test._TestNode')
-
-    prop_bin.add_node(node)
-    prop_bin.show()
-
-    app.exec_()
+#!/usr/bin/python
+from collections import defaultdict
+
+from Qt import QtWidgets, QtCore, QtGui, QtCompat
+
+from .node_property_factory import NodePropertyWidgetFactory
+from .prop_widgets_base import PropLineEdit
+
+
+class _PropertiesDelegate(QtWidgets.QStyledItemDelegate):
+
+    def paint(self, painter, option, index):
+        """
+        Args:
+            painter (QtGui.QPainter):
+            option (QtGui.QStyleOptionViewItem):
+            index (QtCore.QModelIndex):
+        """
+        painter.save()
+        painter.setRenderHint(QtGui.QPainter.Antialiasing, False)
+        painter.setPen(QtCore.Qt.NoPen)
+
+        # draw background.
+        bg_clr = option.palette.midlight().color()
+        painter.setBrush(QtGui.QBrush(bg_clr))
+        painter.drawRect(option.rect)
+
+        # draw border.
+        border_width = 1
+        if option.state & QtWidgets.QStyle.State_Selected:
+            bdr_clr = option.palette.highlight().color()
+            painter.setPen(QtGui.QPen(bdr_clr, 1.5))
+        else:
+            bdr_clr = option.palette.alternateBase().color()
+            painter.setPen(QtGui.QPen(bdr_clr, 1))
+
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.drawRect(QtCore.QRect(
+            option.rect.x() + border_width,
+            option.rect.y() + border_width,
+            option.rect.width() - (border_width * 2),
+            option.rect.height() - (border_width * 2))
+        )
+        painter.restore()
+
+
+class _PropertiesList(QtWidgets.QTableWidget):
+
+    def __init__(self, parent=None):
+        super(_PropertiesList, self).__init__(parent)
+        self.setItemDelegate(_PropertiesDelegate())
+        self.setColumnCount(1)
+        self.setShowGrid(False)
+        self.verticalHeader().hide()
+        self.horizontalHeader().hide()
+
+        QtCompat.QHeaderView.setSectionResizeMode(
+            self.verticalHeader(), QtWidgets.QHeaderView.ResizeToContents)
+        QtCompat.QHeaderView.setSectionResizeMode(
+            self.horizontalHeader(), 0, QtWidgets.QHeaderView.Stretch)
+        self.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
+
+    def wheelEvent(self, event):
+        """
+        Args:
+            event (QtGui.QWheelEvent):
+        """
+        delta = event.angleDelta().y() * 0.2
+        self.verticalScrollBar().setValue(
+            self.verticalScrollBar().value() - delta
+        )
+
+
+class _PropertiesContainer(QtWidgets.QWidget):
+    """
+    Node properties container widget that displays nodes properties under
+    a tab in the ``NodePropWidget`` widget.
+    """
+
+    def __init__(self, parent=None):
+        super(_PropertiesContainer, self).__init__(parent)
+        self.__layout = QtWidgets.QGridLayout()
+        self.__layout.setColumnStretch(1, 1)
+        self.__layout.setSpacing(6)
+
+        layout = QtWidgets.QVBoxLayout(self)
+        layout.setAlignment(QtCore.Qt.AlignTop)
+        layout.addLayout(self.__layout)
+
+    def __repr__(self):
+        return '<{} object at {}>'.format(
+            self.__class__.__name__, hex(id(self))
+        )
+
+    def add_widget(self, name, widget, value, label=None):
+        """
+        Add a property widget to the window.
+
+        Args:
+            name (str): property name to be displayed.
+            widget (BaseProperty): property widget.
+            value (object): property value.
+            label (str): custom label to display.
+        """
+        widget.setToolTip(name)
+        widget.set_value(value)
+        if label is None:
+            label = name
+        row = self.__layout.rowCount()
+        if row > 0:
+            row += 1
+
+        label_flags = QtCore.Qt.AlignCenter | QtCore.Qt.AlignRight
+        if widget.__class__.__name__ == 'PropTextEdit':
+            label_flags = label_flags | QtCore.Qt.AlignTop
+
+        self.__layout.addWidget(QtWidgets.QLabel(label), row, 0, label_flags)
+        self.__layout.addWidget(widget, row, 1)
+
+    def get_widget(self, name):
+        """
+        Returns the property widget from the name.
+
+        Args:
+            name (str): property name.
+
+        Returns:
+            QtWidgets.QWidget: property widget.
+        """
+        for row in range(self.__layout.rowCount()):
+            item = self.__layout.itemAtPosition(row, 1)
+            if item and name == item.widget().toolTip():
+                return item.widget()
+
+
+class NodePropWidget(QtWidgets.QWidget):
+    """
+    Node properties widget for display a Node object.
+
+    Args:
+        parent (QtWidgets.QWidget): parent object.
+        node (NodeGraphQt.BaseNode): node.
+    """
+
+    #: signal (node_id, prop_name, prop_value)
+    property_changed = QtCore.Signal(str, str, object)
+    property_closed = QtCore.Signal(str)
+
+    def __init__(self, parent=None, node=None):
+        super(NodePropWidget, self).__init__(parent)
+        self.__node_id = node.id
+        self.__tab_windows = {}
+        self.__tab = QtWidgets.QTabWidget()
+
+        close_btn = QtWidgets.QPushButton()
+        close_btn.setIcon(QtGui.QIcon(
+            self.style().standardPixmap(QtWidgets.QStyle.SP_DialogCancelButton)
+        ))
+        close_btn.setMaximumWidth(40)
+        close_btn.setToolTip('close property')
+        close_btn.clicked.connect(self._on_close)
+
+        self.name_wgt = PropLineEdit()
+        self.name_wgt.setToolTip('name')
+        self.name_wgt.set_value(node.name())
+        self.name_wgt.value_changed.connect(self._on_property_changed)
+
+        self.type_wgt = QtWidgets.QLabel(node.type_)
+        self.type_wgt.setAlignment(QtCore.Qt.AlignRight)
+        self.type_wgt.setToolTip('type_')
+        font = self.type_wgt.font()
+        font.setPointSize(10)
+        self.type_wgt.setFont(font)
+
+        name_layout = QtWidgets.QHBoxLayout()
+        name_layout.setContentsMargins(0, 0, 0, 0)
+        name_layout.addWidget(QtWidgets.QLabel('name'))
+        name_layout.addWidget(self.name_wgt)
+        name_layout.addWidget(close_btn)
+        layout = QtWidgets.QVBoxLayout(self)
+        layout.setSpacing(4)
+        layout.addLayout(name_layout)
+        layout.addWidget(self.__tab)
+        layout.addWidget(self.type_wgt)
+        self._read_node(node)
+
+    def __repr__(self):
+        return '<{} object at {}>'.format(
+            self.__class__.__name__, hex(id(self))
+        )
+
+    def _on_close(self):
+        """
+        called by the close button.
+        """
+        self.property_closed.emit(self.__node_id)
+
+    def _on_property_changed(self, name, value):
+        """
+        slot function called when a property widget has changed.
+
+        Args:
+            name (str): property name.
+            value (object): new value.
+        """
+        self.property_changed.emit(self.__node_id, name, value)
+
+    def _read_node(self, node):
+        """
+        Populate widget from a node.
+
+        Args:
+            node (NodeGraphQt.BaseNode): node class.
+        """
+        model = node.model
+        graph_model = node.graph.model
+
+        common_props = graph_model.get_node_common_properties(node.type_)
+
+        # sort tabs and properties.
+        tab_mapping = defaultdict(list)
+        for prop_name, prop_val in model.custom_properties.items():
+            tab_name = model.get_tab_name(prop_name)
+            tab_mapping[tab_name].append((prop_name, prop_val))
+
+        # add tabs.
+        for tab in sorted(tab_mapping.keys()):
+            if tab != 'Node':
+                self.add_tab(tab)
+
+        # property widget factory.
+        widget_factory = NodePropertyWidgetFactory()
+
+        # populate tab properties.
+        for tab in sorted(tab_mapping.keys()):
+            prop_window = self.__tab_windows[tab]
+            for prop_name, value in tab_mapping[tab]:
+                wid_type = model.get_widget_type(prop_name)
+                if wid_type == 0:
+                    continue
+
+                widget = widget_factory.get_widget(wid_type)
+                if prop_name in common_props.keys():
+                    if 'items' in common_props[prop_name].keys():
+                        widget.set_items(common_props[prop_name]['items'])
+                    if 'range' in common_props[prop_name].keys():
+                        prop_range = common_props[prop_name]['range']
+                        widget.set_min(prop_range[0])
+                        widget.set_max(prop_range[1])
+
+                prop_window.add_widget(prop_name, widget, value,
+                                       prop_name.replace('_', ' '))
+                widget.value_changed.connect(self._on_property_changed)
+
+        # add "Node" tab properties.
+        self.add_tab('Node')
+        default_props = ['color', 'text_color', 'disabled', 'id']
+        prop_window = self.__tab_windows['Node']
+        for prop_name in default_props:
+            wid_type = model.get_widget_type(prop_name)
+            widget = widget_factory.get_widget(wid_type)
+            prop_window.add_widget(prop_name,
+                                   widget,
+                                   model.get_property(prop_name),
+                                   prop_name.replace('_', ' '))
+
+            widget.value_changed.connect(self._on_property_changed)
+
+        self.type_wgt.setText(model.get_property('type_'))
+
+    def node_id(self):
+        """
+        Returns the node id linked to the widget.
+
+        Returns:
+            str: node id
+        """
+        return self.__node_id
+
+    def add_widget(self, name, widget, tab='Properties'):
+        """
+        add new node property widget.
+
+        Args:
+            name (str): property name.
+            widget (BaseProperty): property widget.
+            tab (str): tab name.
+        """
+        if tab not in self._widgets.keys():
+            tab = 'Properties'
+        window = self.__tab_windows[tab]
+        window.add_widget(name, widget)
+        widget.value_changed.connect(self._on_property_changed)
+
+    def add_tab(self, name):
+        """
+        add a new tab.
+
+        Args:
+            name (str): tab name.
+
+        Returns:
+            PropListWidget: tab child widget.
+        """
+        if name in self.__tab_windows.keys():
+            raise AssertionError('Tab name {} already taken!'.format(name))
+        self.__tab_windows[name] = _PropertiesContainer(self)
+        self.__tab.addTab(self.__tab_windows[name], name)
+        return self.__tab_windows[name]
+
+    def get_widget(self, name):
+        """
+        get property widget.
+
+        Args:
+            name (str): property name.
+
+        Returns:
+            QtWidgets.QWidget: property widget.
+        """
+        if name == 'name':
+            return self.name_wgt
+        for tab_name, prop_win in self.__tab_windows.items():
+            widget = prop_win.get_widget(name)
+            if widget:
+                return widget
+
+
+class PropertiesBinWidget(QtWidgets.QWidget):
+    """
+    The :class:`NodeGraphQt.PropertiesBinWidget` is a list widget for displaying
+    and editing a nodes properties.
+
+    .. inheritance-diagram:: NodeGraphQt.PropertiesBinWidget
+        :parts: 1
+
+    .. image:: _images/prop_bin.png
+        :width: 950px
+
+    .. code-block:: python
+        :linenos:
+
+        from NodeGraphQt import NodeGraph, PropertiesBinWidget
+
+        # create node graph.
+        graph = NodeGraph()
+
+        # create properties bin widget.
+        properties_bin = PropertiesBinWidget(parent=None, node_graph=graph)
+        properties_bin.show()
+
+    See Also:
+            :meth:`NodeGraphQt.BaseNode.add_custom_widget`,
+            :meth:`NodeGraphQt.NodeObject.create_property`,
+            :attr:`NodeGraphQt.constants.NodePropWidgetEnum`
+
+    Args:
+        parent (QtWidgets.QWidget): parent of the new widget.
+        node_graph (NodeGraphQt.NodeGraph): node graph.
+    """
+
+    #: Signal emitted (node_id, prop_name, prop_value)
+    property_changed = QtCore.Signal(str, str, object)
+
+    def __init__(self, parent=None, node_graph=None):
+        super(PropertiesBinWidget, self).__init__(parent)
+        self.setWindowTitle('Properties Bin')
+        self._prop_list = _PropertiesList()
+        self._limit = QtWidgets.QSpinBox()
+        self._limit.setToolTip('Set display nodes limit.')
+        self._limit.setMaximum(10)
+        self._limit.setMinimum(0)
+        self._limit.setValue(2)
+        self._limit.valueChanged.connect(self.__on_limit_changed)
+        self.resize(450, 400)
+
+        self._block_signal = False
+
+        self._lock = False
+        self.btn_lock = QtWidgets.QPushButton('Lock')
+        self.btn_lock.setToolTip(
+            'Lock the properties bin prevent nodes from being loaded.')
+        self.btn_lock.clicked.connect(self.lock_bin)
+
+        btn_clr = QtWidgets.QPushButton('Clear')
+        btn_clr.setToolTip('Clear the properties bin.')
+        btn_clr.clicked.connect(self.clear_bin)
+
+        top_layout = QtWidgets.QHBoxLayout()
+        top_layout.setSpacing(2)
+        top_layout.addWidget(self._limit)
+        top_layout.addStretch(1)
+        top_layout.addWidget(self.btn_lock)
+        top_layout.addWidget(btn_clr)
+
+        layout = QtWidgets.QVBoxLayout(self)
+        layout.addLayout(top_layout)
+        layout.addWidget(self._prop_list, 1)
+
+        # wire up node graph.
+        node_graph.add_properties_bin(self)
+        node_graph.node_double_clicked.connect(self.add_node)
+        node_graph.nodes_deleted.connect(self.__on_nodes_deleted)
+        node_graph.property_changed.connect(self.__on_graph_property_changed)
+
+    def __repr__(self):
+        return '<{} object at {}>'.format(self.__class__.__name__, hex(id(self)))
+
+    def __on_prop_close(self, node_id):
+        items = self._prop_list.findItems(node_id, QtCore.Qt.MatchExactly)
+        [self._prop_list.removeRow(i.row()) for i in items]
+
+    def __on_limit_changed(self, value):
+        rows = self._prop_list.rowCount()
+        if rows > value:
+            self._prop_list.removeRow(rows - 1)
+
+    def __on_nodes_deleted(self, nodes):
+        """
+        Slot function when a node has been deleted.
+
+        Args:
+            nodes (list[str]): list of node ids.
+        """
+        [self.__on_prop_close(n) for n in nodes]
+
+    def __on_graph_property_changed(self, node, prop_name, prop_value):
+        """
+        Slot function that updates the property bin from the node graph signal.
+
+        Args:
+            node (NodeGraphQt.NodeObject):
+            prop_name (str): node property name.
+            prop_value (object): node property value.
+        """
+        properties_widget = self.prop_widget(node)
+        if not properties_widget:
+            return
+
+        property_window = properties_widget.get_widget(prop_name)
+
+        if property_window and prop_value != property_window.get_value():
+            self._block_signal = True
+            property_window.set_value(prop_value)
+            self._block_signal = False
+
+    def __on_property_widget_changed(self, node_id, prop_name, prop_value):
+        """
+        Slot function triggered when a property widget value has changed.
+
+        Args:
+            node_id (str): node id.
+            prop_name (str): node property name.
+            prop_value (object): node property value.
+        """
+        if not self._block_signal:
+            self.property_changed.emit(node_id, prop_name, prop_value)
+
+    def limit(self):
+        """
+        Returns the limit for how many nodes can be loaded into the bin.
+
+        Returns:
+            int: node limit.
+        """
+        return int(self._limit.value())
+
+    def set_limit(self, limit):
+        """
+        Set limit of nodes to display.
+
+        Args:
+            limit (int): node limit.
+        """
+        self._limit.setValue(limit)
+
+    def add_node(self, node):
+        """
+        Add node to the properties bin.
+
+        Args:
+            node (NodeGraphQt.NodeObject): node object.
+        """
+        if self.limit() == 0 or self._lock:
+            return
+
+        rows = self._prop_list.rowCount()
+        if rows >= self.limit():
+            self._prop_list.removeRow(rows - 1)
+
+        itm_find = self._prop_list.findItems(node.id, QtCore.Qt.MatchExactly)
+        if itm_find:
+            self._prop_list.removeRow(itm_find[0].row())
+
+        self._prop_list.insertRow(0)
+        prop_widget = NodePropWidget(node=node)
+        prop_widget.property_changed.connect(self.__on_property_widget_changed)
+        prop_widget.property_closed.connect(self.__on_prop_close)
+        self._prop_list.setCellWidget(0, 0, prop_widget)
+
+        item = QtWidgets.QTableWidgetItem(node.id)
+        self._prop_list.setItem(0, 0, item)
+        self._prop_list.selectRow(0)
+
+    def remove_node(self, node):
+        """
+        Remove node from the properties bin.
+
+        Args:
+            node (str or NodeGraphQt.BaseNode): node id or node object.
+        """
+        node_id = node if isinstance(node, str) else node.id
+        self.__on_prop_close(node_id)
+
+    def lock_bin(self):
+        """
+        Lock/UnLock the properties bin.
+        """
+        self._lock = not self._lock
+        if self._lock:
+            self.btn_lock.setText('UnLock')
+        else:
+            self.btn_lock.setText('Lock')
+
+    def clear_bin(self):
+        """
+        Clear the properties bin.
+        """
+        self._prop_list.setRowCount(0)
+
+    def prop_widget(self, node):
+        """
+        Returns the node property widget.
+
+        Args:
+            node (str or NodeGraphQt.NodeObject): node id or node object.
+
+        Returns:
+            NodePropWidget: node property widget.
+        """
+        node_id = node if isinstance(node, str) else node.id
+        itm_find = self._prop_list.findItems(node_id, QtCore.Qt.MatchExactly)
+        if itm_find:
+            item = itm_find[0]
+            return self._prop_list.cellWidget(item.row(), 0)
+
+
+if __name__ == '__main__':
+    import sys
+    from NodeGraphQt import BaseNode, NodeGraph
+    from NodeGraphQt.constants import NodePropWidgetEnum
+
+
+    class _TestNode(BaseNode):
+
+        __identifier__ = 'property.test'
+        NODE_NAME = 'test node'
+
+        def __init__(self):
+            super(_TestNode, self).__init__()
+            self.create_property(
+                'label_test',
+                value='foo bar',
+                widget_type=NodePropWidgetEnum.QLABEL.value
+            )
+            self.create_property(
+                'text_edit',
+                value='text edit test',
+                widget_type=NodePropWidgetEnum.QLABEL.value
+            )
+            self.create_property(
+                "file",
+                value="",
+                widget_type=NodePropWidgetEnum.FILE_OPEN.value
+            )
+            self.create_property(
+                'color_picker',
+                value=(0, 0, 255),
+                widget_type=NodePropWidgetEnum.COLOR_PICKER.value
+            )
+            self.create_property(
+                'integer',
+                value=10,
+                widget_type=NodePropWidgetEnum.QSPIN_BOX.value
+            )
+            self.create_property(
+                'list',
+                value='itm2',
+                items=['itm1', 'itm2', 'itm3'],
+                widget_type=NodePropWidgetEnum.QCOMBO_BOX.value
+            )
+            self.create_property(
+                'range',
+                value=50,
+                range=(45, 55),
+                widget_type=NodePropWidgetEnum.SLIDER.value
+            )
+            self.create_property(
+                'float_range',
+                value=150.5,
+                range=(50.5, 200),
+                widget_type=NodePropWidgetEnum.DOUBLE_SLIDER.value
+            )
+            self.create_property(
+                'color4_picker',
+                value=(255, 0, 0, 122),
+                widget_type=NodePropWidgetEnum.COLOR4_PICKER.value
+            )
+
+    def _prop_changed(node_id, prop_name, prop_value):
+        print('-'*100)
+        print(node_id, prop_name, prop_value)
+
+
+    app = QtWidgets.QApplication(sys.argv)
+
+    graph = NodeGraph()
+    graph.register_node(_TestNode)
+
+    prop_bin = PropertiesBinWidget(node_graph=graph)
+    prop_bin.resize(800, 600)
+    prop_bin.property_changed.connect(_prop_changed)
+
+    node = graph.create_node('property.test._TestNode')
+
+    prop_bin.add_node(node)
+    prop_bin.show()
+
+    app.exec_()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/custom_widgets/properties_bin/prop_widgets_base.py` & `NodeGraphQt-0.6.3/NodeGraphQt/custom_widgets/properties_bin/prop_widgets_base.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,252 +1,252 @@
-#!/usr/bin/python
-from Qt import QtWidgets, QtCore
-
-
-class PropLabel(QtWidgets.QLabel):
-    """
-    Displays a node property as a "QLabel" widget in the PropertiesBin widget.
-    """
-
-    value_changed = QtCore.Signal(str, object)
-
-    def __repr__(self):
-        return '<{}() object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def get_value(self):
-        return self.text()
-
-    def set_value(self, value):
-        if value != self.get_value():
-            self.setText(str(value))
-            self.value_changed.emit(self.toolTip(), value)
-
-
-class PropLineEdit(QtWidgets.QLineEdit):
-    """
-    Displays a node property as a "QLineEdit" widget in the PropertiesBin
-    widget.
-    """
-
-    value_changed = QtCore.Signal(str, object)
-
-    def __init__(self, parent=None):
-        super(PropLineEdit, self).__init__(parent)
-        self.editingFinished.connect(self._on_editing_finished)
-
-    def __repr__(self):
-        return '<{}() object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def _on_editing_finished(self):
-        self.value_changed.emit(self.toolTip(), self.text())
-
-    def get_value(self):
-        return self.text()
-
-    def set_value(self, value):
-        _value = str(value)
-        if _value != self.get_value():
-            self.setText(_value)
-            self.value_changed.emit(self.toolTip(), _value)
-
-
-class PropTextEdit(QtWidgets.QTextEdit):
-    """
-    Displays a node property as a "QTextEdit" widget in the PropertiesBin
-    widget.
-    """
-
-    value_changed = QtCore.Signal(str, object)
-
-    def __init__(self, parent=None):
-        super(PropTextEdit, self).__init__(parent)
-        self._prev_text = ''
-
-    def __repr__(self):
-        return '<{}() object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def focusInEvent(self, event):
-        super(PropTextEdit, self).focusInEvent(event)
-        self._prev_text = self.toPlainText()
-
-    def focusOutEvent(self, event):
-        super(PropTextEdit, self).focusOutEvent(event)
-        if self._prev_text != self.toPlainText():
-            self.value_changed.emit(self.toolTip(), self.toPlainText())
-        self._prev_text = ''
-
-    def get_value(self):
-        return self.toPlainText()
-
-    def set_value(self, value):
-        _value = str(value)
-        if _value != self.get_value():
-            self.setPlainText(_value)
-            self.value_changed.emit(self.toolTip(), _value)
-
-
-class PropComboBox(QtWidgets.QComboBox):
-    """
-    Displays a node property as a "QComboBox" widget in the PropertiesBin
-    widget.
-    """
-
-    value_changed = QtCore.Signal(str, object)
-
-    def __init__(self, parent=None):
-        super(PropComboBox, self).__init__(parent)
-        self.currentIndexChanged.connect(self._on_index_changed)
-
-    def __repr__(self):
-        return '<{}() object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def _on_index_changed(self):
-        self.value_changed.emit(self.toolTip(), self.get_value())
-
-    def items(self):
-        """
-        Returns items from the combobox.
-
-        Returns:
-            list[str]: list of strings.
-        """
-        return [self.itemText(i) for i in range(self.count())]
-
-    def set_items(self, items):
-        """
-        Set items on the combobox.
-
-        Args:
-            items (list[str]): list of strings.
-        """
-        self.clear()
-        self.addItems(items)
-
-    def get_value(self):
-        return self.currentText()
-
-    def set_value(self, value):
-        if value != self.get_value():
-            idx = self.findText(value, QtCore.Qt.MatchExactly)
-            self.setCurrentIndex(idx)
-            if idx >= 0:
-                self.value_changed.emit(self.toolTip(), value)
-
-
-class PropCheckBox(QtWidgets.QCheckBox):
-    """
-    Displays a node property as a "QCheckBox" widget in the PropertiesBin
-    widget.
-    """
-
-    value_changed = QtCore.Signal(str, object)
-
-    def __init__(self, parent=None):
-        super(PropCheckBox, self).__init__(parent)
-        self.clicked.connect(self._on_clicked)
-
-    def __repr__(self):
-        return '<{}() object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def _on_clicked(self):
-        self.value_changed.emit(self.toolTip(), self.get_value())
-
-    def get_value(self):
-        return self.isChecked()
-
-    def set_value(self, value):
-        _value = bool(value)
-        if _value != self.get_value():
-            self.setChecked(_value)
-            self.value_changed.emit(self.toolTip(), _value)
-
-
-class PropSpinBox(QtWidgets.QSpinBox):
-    """
-    Displays a node property as a "QSpinBox" widget in the PropertiesBin widget.
-    """
-
-    value_changed = QtCore.Signal(str, object)
-
-    def __init__(self, parent=None):
-        super(PropSpinBox, self).__init__(parent)
-        self.setButtonSymbols(self.NoButtons)
-        self.valueChanged.connect(self._on_value_change)
-
-    def __repr__(self):
-        return '<{}() object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def _on_value_change(self, value):
-        self.value_changed.emit(self.toolTip(), value)
-
-    def get_value(self):
-        return self.value()
-
-    def set_value(self, value):
-        if value != self.get_value():
-            self.setValue(value)
-
-
-class PropDoubleSpinBox(QtWidgets.QDoubleSpinBox):
-    """
-    Displays a node property as a "QDoubleSpinBox" widget in the PropertiesBin
-    widget.
-    """
-
-    value_changed = QtCore.Signal(str, object)
-
-    def __init__(self, parent=None):
-        super(PropDoubleSpinBox, self).__init__(parent)
-        self.setButtonSymbols(self.NoButtons)
-        self.valueChanged.connect(self._on_value_change)
-
-    def __repr__(self):
-        return '<{}() object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def _on_value_change(self, value):
-        self.value_changed.emit(self.toolTip(), value)
-
-    def get_value(self):
-        return self.value()
-
-    def set_value(self, value):
-        if value != self.get_value():
-            self.setValue(value)
-
-
-# class PropPushButton(QtWidgets.QPushButton):
-#     """
-#     Displays a node property as a "QPushButton" widget in the PropertiesBin
-#     widget.
-#     """
-#
-#     value_changed = QtCore.Signal(str, object)
-#     button_clicked = QtCore.Signal(str, object)
-#
-#     def __init__(self, parent=None):
-#         super(PropPushButton, self).__init__(parent)
-#         self.clicked.connect(self.button_clicked.emit)
-#
-#     def set_on_click_func(self, func, node):
-#         """
-#         Sets slot function for the PropPushButton widget.
-#
-#         Args:
-#             func (function): property slot function.
-#             node (NodeGraphQt.NodeObject): node object.
-#         """
-#         if not callable(func):
-#             raise TypeError('var func is not a function.')
-#         self.clicked.connect(lambda: func(node))
-#
-#     def get_value(self):
-#         return
-#
-#     def set_value(self, value):
-#         return
+#!/usr/bin/python
+from Qt import QtWidgets, QtCore
+
+
+class PropLabel(QtWidgets.QLabel):
+    """
+    Displays a node property as a "QLabel" widget in the PropertiesBin widget.
+    """
+
+    value_changed = QtCore.Signal(str, object)
+
+    def __repr__(self):
+        return '<{}() object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def get_value(self):
+        return self.text()
+
+    def set_value(self, value):
+        if value != self.get_value():
+            self.setText(str(value))
+            self.value_changed.emit(self.toolTip(), value)
+
+
+class PropLineEdit(QtWidgets.QLineEdit):
+    """
+    Displays a node property as a "QLineEdit" widget in the PropertiesBin
+    widget.
+    """
+
+    value_changed = QtCore.Signal(str, object)
+
+    def __init__(self, parent=None):
+        super(PropLineEdit, self).__init__(parent)
+        self.editingFinished.connect(self._on_editing_finished)
+
+    def __repr__(self):
+        return '<{}() object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def _on_editing_finished(self):
+        self.value_changed.emit(self.toolTip(), self.text())
+
+    def get_value(self):
+        return self.text()
+
+    def set_value(self, value):
+        _value = str(value)
+        if _value != self.get_value():
+            self.setText(_value)
+            self.value_changed.emit(self.toolTip(), _value)
+
+
+class PropTextEdit(QtWidgets.QTextEdit):
+    """
+    Displays a node property as a "QTextEdit" widget in the PropertiesBin
+    widget.
+    """
+
+    value_changed = QtCore.Signal(str, object)
+
+    def __init__(self, parent=None):
+        super(PropTextEdit, self).__init__(parent)
+        self._prev_text = ''
+
+    def __repr__(self):
+        return '<{}() object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def focusInEvent(self, event):
+        super(PropTextEdit, self).focusInEvent(event)
+        self._prev_text = self.toPlainText()
+
+    def focusOutEvent(self, event):
+        super(PropTextEdit, self).focusOutEvent(event)
+        if self._prev_text != self.toPlainText():
+            self.value_changed.emit(self.toolTip(), self.toPlainText())
+        self._prev_text = ''
+
+    def get_value(self):
+        return self.toPlainText()
+
+    def set_value(self, value):
+        _value = str(value)
+        if _value != self.get_value():
+            self.setPlainText(_value)
+            self.value_changed.emit(self.toolTip(), _value)
+
+
+class PropComboBox(QtWidgets.QComboBox):
+    """
+    Displays a node property as a "QComboBox" widget in the PropertiesBin
+    widget.
+    """
+
+    value_changed = QtCore.Signal(str, object)
+
+    def __init__(self, parent=None):
+        super(PropComboBox, self).__init__(parent)
+        self.currentIndexChanged.connect(self._on_index_changed)
+
+    def __repr__(self):
+        return '<{}() object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def _on_index_changed(self):
+        self.value_changed.emit(self.toolTip(), self.get_value())
+
+    def items(self):
+        """
+        Returns items from the combobox.
+
+        Returns:
+            list[str]: list of strings.
+        """
+        return [self.itemText(i) for i in range(self.count())]
+
+    def set_items(self, items):
+        """
+        Set items on the combobox.
+
+        Args:
+            items (list[str]): list of strings.
+        """
+        self.clear()
+        self.addItems(items)
+
+    def get_value(self):
+        return self.currentText()
+
+    def set_value(self, value):
+        if value != self.get_value():
+            idx = self.findText(value, QtCore.Qt.MatchExactly)
+            self.setCurrentIndex(idx)
+            if idx >= 0:
+                self.value_changed.emit(self.toolTip(), value)
+
+
+class PropCheckBox(QtWidgets.QCheckBox):
+    """
+    Displays a node property as a "QCheckBox" widget in the PropertiesBin
+    widget.
+    """
+
+    value_changed = QtCore.Signal(str, object)
+
+    def __init__(self, parent=None):
+        super(PropCheckBox, self).__init__(parent)
+        self.clicked.connect(self._on_clicked)
+
+    def __repr__(self):
+        return '<{}() object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def _on_clicked(self):
+        self.value_changed.emit(self.toolTip(), self.get_value())
+
+    def get_value(self):
+        return self.isChecked()
+
+    def set_value(self, value):
+        _value = bool(value)
+        if _value != self.get_value():
+            self.setChecked(_value)
+            self.value_changed.emit(self.toolTip(), _value)
+
+
+class PropSpinBox(QtWidgets.QSpinBox):
+    """
+    Displays a node property as a "QSpinBox" widget in the PropertiesBin widget.
+    """
+
+    value_changed = QtCore.Signal(str, object)
+
+    def __init__(self, parent=None):
+        super(PropSpinBox, self).__init__(parent)
+        self.setButtonSymbols(self.NoButtons)
+        self.valueChanged.connect(self._on_value_change)
+
+    def __repr__(self):
+        return '<{}() object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def _on_value_change(self, value):
+        self.value_changed.emit(self.toolTip(), value)
+
+    def get_value(self):
+        return self.value()
+
+    def set_value(self, value):
+        if value != self.get_value():
+            self.setValue(value)
+
+
+class PropDoubleSpinBox(QtWidgets.QDoubleSpinBox):
+    """
+    Displays a node property as a "QDoubleSpinBox" widget in the PropertiesBin
+    widget.
+    """
+
+    value_changed = QtCore.Signal(str, object)
+
+    def __init__(self, parent=None):
+        super(PropDoubleSpinBox, self).__init__(parent)
+        self.setButtonSymbols(self.NoButtons)
+        self.valueChanged.connect(self._on_value_change)
+
+    def __repr__(self):
+        return '<{}() object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def _on_value_change(self, value):
+        self.value_changed.emit(self.toolTip(), value)
+
+    def get_value(self):
+        return self.value()
+
+    def set_value(self, value):
+        if value != self.get_value():
+            self.setValue(value)
+
+
+# class PropPushButton(QtWidgets.QPushButton):
+#     """
+#     Displays a node property as a "QPushButton" widget in the PropertiesBin
+#     widget.
+#     """
+#
+#     value_changed = QtCore.Signal(str, object)
+#     button_clicked = QtCore.Signal(str, object)
+#
+#     def __init__(self, parent=None):
+#         super(PropPushButton, self).__init__(parent)
+#         self.clicked.connect(self.button_clicked.emit)
+#
+#     def set_on_click_func(self, func, node):
+#         """
+#         Sets slot function for the PropPushButton widget.
+#
+#         Args:
+#             func (function): property slot function.
+#             node (NodeGraphQt.NodeObject): node object.
+#         """
+#         if not callable(func):
+#             raise TypeError('var func is not a function.')
+#         self.clicked.connect(lambda: func(node))
+#
+#     def get_value(self):
+#         return
+#
+#     def set_value(self, value):
+#         return
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/nodes/base_node.py` & `NodeGraphQt-0.6.3/NodeGraphQt/nodes/base_node.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,813 +1,813 @@
-#!/usr/bin/python
-from collections import OrderedDict
-
-from NodeGraphQt.base.commands import NodeVisibleCmd
-from NodeGraphQt.base.node import NodeObject
-from NodeGraphQt.base.port import Port
-from NodeGraphQt.constants import NodePropWidgetEnum, PortTypeEnum
-from NodeGraphQt.errors import (PortError,
-                                PortRegistrationError,
-                                NodeWidgetError)
-from NodeGraphQt.qgraphics.node_base import NodeItem
-from NodeGraphQt.widgets.node_widgets import (NodeBaseWidget,
-                                              NodeComboBox,
-                                              NodeLineEdit,
-                                              NodeCheckBox)
-
-
-class BaseNode(NodeObject):
-    """
-    The ``NodeGraphQt.BaseNode`` class is the base class for nodes that allows
-    port connections from one node to another.
-
-    .. inheritance-diagram:: NodeGraphQt.BaseNode
-
-    .. image:: ../_images/node.png
-        :width: 250px
-
-    example snippet:
-
-    .. code-block:: python
-        :linenos:
-
-        from NodeGraphQt import BaseNode
-
-        class ExampleNode(BaseNode):
-
-            # unique node identifier domain.
-            __identifier__ = 'io.jchanvfx.github'
-
-            # initial default node name.
-            NODE_NAME = 'My Node'
-
-            def __init__(self):
-                super(ExampleNode, self).__init__()
-
-                # create an input port.
-                self.add_input('in')
-
-                # create an output port.
-                self.add_output('out')
-    """
-
-    NODE_NAME = 'Node'
-
-    def __init__(self, qgraphics_item=None):
-        super(BaseNode, self).__init__(qgraphics_item or NodeItem)
-        self._inputs = []
-        self._outputs = []
-
-    def update_model(self):
-        """
-        Update the node model from view.
-        """
-        for name, val in self.view.properties.items():
-            if name in ['inputs', 'outputs']:
-                continue
-            self.model.set_property(name, val)
-
-        for name, widget in self.view.widgets.items():
-            self.model.set_property(name, widget.get_value())
-
-    def set_property(self, name, value, push_undo=True):
-        """
-        Set the value on the node custom property.
-
-        Args:
-            name (str): name of the property.
-            value (object): property data (python built in types).
-            push_undo (bool): register the command to the undo stack. (default: True)
-        """
-        # prevent signals from causing a infinite loop.
-        if self.get_property(name) == value:
-            return
-
-        if name == 'visible':
-            if self.graph:
-                undo_cmd = NodeVisibleCmd(self, value)
-                if push_undo:
-                    self.graph.undo_stack().push(undo_cmd)
-                else:
-                    undo_cmd.redo()
-                return
-        elif name == 'disabled':
-            # redraw the connected pipes in the scene.
-            ports = self.view.inputs + self.view.outputs
-            for port in ports:
-                for pipe in port.connected_pipes:
-                    pipe.update()
-        super(BaseNode, self).set_property(name, value, push_undo)
-
-    def set_layout_direction(self, value=0):
-        """
-        Sets the node layout direction to either horizontal or vertical on
-        the current node only.
-
-        `Implemented in` ``v0.3.0``
-
-        See Also:
-            :meth:`NodeGraph.set_layout_direction`,
-            :meth:`NodeObject.layout_direction`
-
-
-        Warnings:
-            This function does not register to the undo stack.
-
-        Args:
-            value (int): layout direction mode.
-        """
-        # base logic to update the model and view attributes only.
-        super(BaseNode, self).set_layout_direction(value)
-        # redraw the node.
-        self._view.draw_node()
-
-    def set_icon(self, icon=None):
-        """
-        Set the node icon.
-
-        Args:
-            icon (str): path to the icon image.
-        """
-        self.set_property('icon', icon)
-
-    def icon(self):
-        """
-        Node icon path.
-
-        Returns:
-            str: icon image file path.
-        """
-        return self.model.icon
-
-    def widgets(self):
-        """
-        Returns all embedded widgets from this node.
-
-        See Also:
-            :meth:`BaseNode.get_widget`
-
-        Returns:
-            dict: embedded node widgets. {``property_name``: ``node_widget``}
-        """
-        return self.view.widgets
-
-    def get_widget(self, name):
-        """
-        Returns the embedded widget associated with the property name.
-
-        See Also:
-            :meth:`BaseNode.add_combo_menu`,
-            :meth:`BaseNode.add_text_input`,
-            :meth:`BaseNode.add_checkbox`,
-
-        Args:
-            name (str): node property name.
-
-        Returns:
-            NodeBaseWidget: embedded node widget.
-        """
-        return self.view.widgets.get(name)
-
-    def add_custom_widget(self, widget, widget_type=None, tab=None):
-        """
-        Add a custom node widget into the node.
-
-        see example :ref:`Embedding Custom Widgets`.
-
-        Note:
-            The ``value_changed`` signal from the added node widget is wired
-            up to the :meth:`NodeObject.set_property` function.
-
-        Args:
-            widget (NodeBaseWidget): node widget class object.
-            widget_type: widget flag to display in the
-                :class:`NodeGraphQt.PropertiesBinWidget`
-                (default: :attr:`NodeGraphQt.constants.NodePropWidgetEnum.HIDDEN`).
-            tab (str): name of the widget tab to display in.
-        """
-        if not isinstance(widget, NodeBaseWidget):
-            raise NodeWidgetError(
-                '\'widget\' must be an instance of a NodeBaseWidget')
-
-        widget_type = widget_type or NodePropWidgetEnum.HIDDEN.value
-        self.create_property(widget.get_name(),
-                             widget.get_value(),
-                             widget_type=widget_type,
-                             tab=tab)
-        widget.value_changed.connect(lambda k, v: self.set_property(k, v))
-        widget._node = self
-        self.view.add_widget(widget)
-        #: redraw node to address calls outside the "__init__" func.
-        self.view.draw_node()
-
-    def add_combo_menu(self, name, label='', items=None, tab=None):
-        """
-        Creates a custom property with the :meth:`NodeObject.create_property`
-        function and embeds a :class:`PySide2.QtWidgets.QComboBox` widget
-        into the node.
-
-        Note:
-            The ``value_changed`` signal from the added node widget is wired
-            up to the :meth:`NodeObject.set_property` function.
-
-        Args:
-            name (str): name for the custom property.
-            label (str): label to be displayed.
-            items (list[str]): items to be added into the menu.
-            tab (str): name of the widget tab to display in.
-        """
-        self.create_property(
-            name,
-            value=items[0] if items else None,
-            items=items or [],
-            widget_type=NodePropWidgetEnum.QCOMBO_BOX.value,
-            tab=tab
-        )
-        widget = NodeComboBox(self.view, name, label, items)
-        widget.value_changed.connect(lambda k, v: self.set_property(k, v))
-        self.view.add_widget(widget)
-        #: redraw node to address calls outside the "__init__" func.
-        self.view.draw_node()
-
-    def add_text_input(self, name, label='', text='', tab=None):
-        """
-        Creates a custom property with the :meth:`NodeObject.create_property`
-        function and embeds a :class:`PySide2.QtWidgets.QLineEdit` widget
-        into the node.
-
-        Note:
-            The ``value_changed`` signal from the added node widget is wired
-            up to the :meth:`NodeObject.set_property` function.
-
-        Args:
-            name (str): name for the custom property.
-            label (str): label to be displayed.
-            text (str): pre filled text.
-            tab (str): name of the widget tab to display in.
-        """
-        self.create_property(
-            name,
-            value=text,
-            widget_type=NodePropWidgetEnum.QLINE_EDIT.value,
-            tab=tab
-        )
-        widget = NodeLineEdit(self.view, name, label, text)
-        widget.value_changed.connect(lambda k, v: self.set_property(k, v))
-        self.view.add_widget(widget)
-        #: redraw node to address calls outside the "__init__" func.
-        self.view.draw_node()
-
-    def add_checkbox(self, name, label='', text='', state=False, tab=None):
-        """
-        Creates a custom property with the :meth:`NodeObject.create_property`
-        function and embeds a :class:`PySide2.QtWidgets.QCheckBox` widget
-        into the node.
-
-        Note:
-            The ``value_changed`` signal from the added node widget is wired
-            up to the :meth:`NodeObject.set_property` function.
-
-        Args:
-            name (str): name for the custom property.
-            label (str): label to be displayed.
-            text (str): checkbox text.
-            state (bool): pre-check.
-            tab (str): name of the widget tab to display in.
-        """
-        self.create_property(
-            name,
-            value=state,
-            widget_type=NodePropWidgetEnum.QCHECK_BOX.value,
-            tab=tab
-        )
-        widget = NodeCheckBox(self.view, name, label, text, state)
-        widget.value_changed.connect(lambda k, v: self.set_property(k, v))
-        self.view.add_widget(widget)
-        #: redraw node to address calls outside the "__init__" func.
-        self.view.draw_node()
-
-    def add_input(self, name='input', multi_input=False, display_name=True,
-                  color=None, locked=False, painter_func=None):
-        """
-        Add input :class:`Port` to node.
-
-        Warnings:
-            Undo is NOT supported for this function.
-
-        Args:
-            name (str): name for the input port.
-            multi_input (bool): allow port to have more than one connection.
-            display_name (bool): display the port name on the node.
-            color (tuple): initial port color (r, g, b) ``0-255``.
-            locked (bool): locked state see :meth:`Port.set_locked`
-            painter_func (function or None): custom function to override the drawing
-                of the port shape see example: :ref:`Creating Custom Shapes`
-
-        Returns:
-            NodeGraphQt.Port: the created port object.
-        """
-        if name in self.inputs().keys():
-            raise PortRegistrationError(
-                'port name "{}" already registered.'.format(name))
-
-        port_args = [name, multi_input, display_name, locked]
-        if painter_func and callable(painter_func):
-            port_args.append(painter_func)
-        view = self.view.add_input(*port_args)
-
-        if color:
-            view.color = color
-            view.border_color = [min([255, max([0, i + 80])]) for i in color]
-
-        port = Port(self, view)
-        port.model.type_ = PortTypeEnum.IN.value
-        port.model.name = name
-        port.model.display_name = display_name
-        port.model.multi_connection = multi_input
-        port.model.locked = locked
-        self._inputs.append(port)
-        self.model.inputs[port.name()] = port.model
-        return port
-
-    def add_output(self, name='output', multi_output=True, display_name=True,
-                   color=None, locked=False, painter_func=None):
-        """
-        Add output :class:`Port` to node.
-
-        Warnings:
-            Undo is NOT supported for this function.
-
-        Args:
-            name (str): name for the output port.
-            multi_output (bool): allow port to have more than one connection.
-            display_name (bool): display the port name on the node.
-            color (tuple): initial port color (r, g, b) ``0-255``.
-            locked (bool): locked state see :meth:`Port.set_locked`
-            painter_func (function or None): custom function to override the drawing
-                of the port shape see example: :ref:`Creating Custom Shapes`
-
-        Returns:
-            NodeGraphQt.Port: the created port object.
-        """
-        if name in self.outputs().keys():
-            raise PortRegistrationError(
-                'port name "{}" already registered.'.format(name))
-
-        port_args = [name, multi_output, display_name, locked]
-        if painter_func and callable(painter_func):
-            port_args.append(painter_func)
-        view = self.view.add_output(*port_args)
-
-        if color:
-            view.color = color
-            view.border_color = [min([255, max([0, i + 80])]) for i in color]
-        port = Port(self, view)
-        port.model.type_ = PortTypeEnum.OUT.value
-        port.model.name = name
-        port.model.display_name = display_name
-        port.model.multi_connection = multi_output
-        port.model.locked = locked
-        self._outputs.append(port)
-        self.model.outputs[port.name()] = port.model
-        return port
-
-    def get_input(self, port):
-        """
-        Get input port by the name or index.
-
-        Args:
-            port (str or int): port name or index.
-
-        Returns:
-            NodeGraphQt.Port: node port.
-        """
-        if type(port) is int:
-            if port < len(self._inputs):
-                return self._inputs[port]
-        elif type(port) is str:
-            return self.inputs().get(port, None)
-
-    def get_output(self, port):
-        """
-        Get output port by the name or index.
-
-        Args:
-            port (str or int): port name or index.
-
-        Returns:
-            NodeGraphQt.Port: node port.
-        """
-        if type(port) is int:
-            if port < len(self._outputs):
-                return self._outputs[port]
-        elif type(port) is str:
-            return self.outputs().get(port, None)
-
-    def delete_input(self, port):
-        """
-        Delete input port.
-
-        Warnings:
-            Undo is NOT supported for this function.
-
-            You can only delete ports if :meth:`BaseNode.port_deletion_allowed`
-            returns ``True`` otherwise a port error is raised see also
-            :meth:`BaseNode.set_port_deletion_allowed`.
-
-        Args:
-            port (str or int): port name or index.
-        """
-        if type(port) in [int, str]:
-            port = self.get_input(port)
-            if port is None:
-                return
-        if not self.port_deletion_allowed():
-            raise PortError(
-                'Port "{}" can\'t be deleted on this node because '
-                '"ports_removable" is not enabled.'.format(port.name()))
-        if port.locked():
-            raise PortError('Error: Can\'t delete a port that is locked!')
-        self._inputs.remove(port)
-        self._model.inputs.pop(port.name())
-        self._view.delete_input(port.view)
-        port.model.node = None
-        self._view.draw_node()
-
-    def delete_output(self, port):
-        """
-        Delete output port.
-
-        Warnings:
-            Undo is NOT supported for this function.
-
-            You can only delete ports if :meth:`BaseNode.port_deletion_allowed`
-            returns ``True`` otherwise a port error is raised see also
-            :meth:`BaseNode.set_port_deletion_allowed`.
-
-        Args:
-            port (str or int): port name or index.
-        """
-        if type(port) in [int, str]:
-            port = self.get_output(port)
-            if port is None:
-                return
-        if not self.port_deletion_allowed():
-            raise PortError(
-                'Port "{}" can\'t be deleted on this node because '
-                '"ports_removable" is not enabled.'.format(port.name()))
-        if port.locked():
-            raise PortError('Error: Can\'t delete a port that is locked!')
-        self._outputs.remove(port)
-        self._model.outputs.pop(port.name())
-        self._view.delete_output(port.view)
-        port.model.node = None
-        self._view.draw_node()
-
-    def set_port_deletion_allowed(self, mode=False):
-        """
-        Allow ports to be removable on this node.
-
-        See Also:
-            :meth:`BaseNode.port_deletion_allowed` and
-            :meth:`BaseNode.set_ports`
-
-        Args:
-            mode (bool): true to allow.
-        """
-        self.model.port_deletion_allowed = mode
-
-    def port_deletion_allowed(self):
-        """
-        Return true if ports can be deleted on this node.
-
-        See Also:
-            :meth:`BaseNode.set_port_deletion_allowed`
-
-        Returns:
-            bool: true if ports can be deleted.
-        """
-        return self.model.port_deletion_allowed
-
-    def set_ports(self, port_data):
-        """
-        Create node input and output ports from serialized port data.
-
-        Warnings:
-            You can only use this function if the node has
-            :meth:`BaseNode.port_deletion_allowed` is `True`
-            see :meth:`BaseNode.set_port_deletion_allowed`
-
-        Hint:
-            example snippet of port data.
-
-            .. highlight:: python
-            .. code-block:: python
-
-                {
-                    'input_ports':
-                        [{
-                            'name': 'input',
-                            'multi_connection': True,
-                            'display_name': 'Input',
-                            'locked': False
-                        }],
-                    'output_ports':
-                        [{
-                            'name': 'output',
-                            'multi_connection': True,
-                            'display_name': 'Output',
-                            'locked': False
-                        }]
-                }
-
-        Args:
-            port_data(dict): port data.
-        """
-        if not self.port_deletion_allowed():
-            raise PortError(
-                'Ports cannot be set on this node because '
-                '"set_port_deletion_allowed" is not enabled on this node.')
-
-        for port in self._inputs:
-            self._view.delete_input(port.view)
-            port.model.node = None
-        for port in self._outputs:
-            self._view.delete_output(port.view)
-            port.model.node = None
-        self._inputs = []
-        self._outputs = []
-        self._model.outputs = {}
-        self._model.inputs = {}
-
-        [self.add_input(name=port['name'],
-                        multi_input=port['multi_connection'],
-                        display_name=port['display_name'],
-                        locked=port.get('locked') or False)
-         for port in port_data['input_ports']]
-        [self.add_output(name=port['name'],
-                         multi_output=port['multi_connection'],
-                         display_name=port['display_name'],
-                         locked=port.get('locked') or False)
-         for port in port_data['output_ports']]
-        self._view.draw_node()
-
-    def inputs(self):
-        """
-        Returns all the input ports from the node.
-
-        Returns:
-            dict: {<port_name>: <port_object>}
-        """
-        return {p.name(): p for p in self._inputs}
-
-    def input_ports(self):
-        """
-        Return all input ports.
-
-        Returns:
-            list[NodeGraphQt.Port]: node input ports.
-        """
-        return self._inputs
-
-    def outputs(self):
-        """
-        Returns all the output ports from the node.
-
-        Returns:
-            dict: {<port_name>: <port_object>}
-        """
-        return {p.name(): p for p in self._outputs}
-
-    def output_ports(self):
-        """
-        Return all output ports.
-
-        Returns:
-            list[NodeGraphQt.Port]: node output ports.
-        """
-        return self._outputs
-
-    def input(self, index):
-        """
-        Return the input port with the matching index.
-
-        Args:
-            index (int): index of the input port.
-
-        Returns:
-            NodeGraphQt.Port: port object.
-        """
-        return self._inputs[index]
-
-    def set_input(self, index, port):
-        """
-        Creates a connection pipe to the targeted output :class:`Port`.
-
-        Args:
-            index (int): index of the port.
-            port (NodeGraphQt.Port): port object.
-        """
-        src_port = self.input(index)
-        src_port.connect_to(port)
-
-    def output(self, index):
-        """
-        Return the output port with the matching index.
-
-        Args:
-            index (int): index of the output port.
-
-        Returns:
-            NodeGraphQt.Port: port object.
-        """
-        return self._outputs[index]
-
-    def set_output(self, index, port):
-        """
-        Creates a connection pipe to the targeted input :class:`Port`.
-
-        Args:
-            index (int): index of the port.
-            port (NodeGraphQt.Port): port object.
-        """
-        src_port = self.output(index)
-        src_port.connect_to(port)
-
-    def connected_input_nodes(self):
-        """
-        Returns all nodes connected from the input ports.
-
-        Returns:
-            dict: {<input_port>: <node_list>}
-        """
-        nodes = OrderedDict()
-        for p in self.input_ports():
-            nodes[p] = [cp.node() for cp in p.connected_ports()]
-        return nodes
-
-    def connected_output_nodes(self):
-        """
-        Returns all nodes connected from the output ports.
-
-        Returns:
-            dict: {<output_port>: <node_list>}
-        """
-        nodes = OrderedDict()
-        for p in self.output_ports():
-            nodes[p] = [cp.node() for cp in p.connected_ports()]
-        return nodes
-
-    def add_accept_port_type(self, port, port_type_data):
-        """
-        Add a accept constrain to a specified node port.
-
-        Once a constrain has been added only ports of that type specified will
-        be allowed a pipe connection.
-
-        port type data example
-
-        .. highlight:: python
-        .. code-block:: python
-
-            {
-                'port_name': 'foo'
-                'port_type': PortTypeEnum.IN.value
-                'node_type': 'io.github.jchanvfx.NodeClass'
-            }
-
-        See Also:
-            :meth:`NodeGraphQt.BaseNode.accepted_port_types`
-
-        Args:
-            port (NodeGraphQt.Port): port to assign constrain to.
-            port_type_data (dict): port type data to accept a connection
-        """
-        node_ports = self._inputs + self._outputs
-        if port not in node_ports:
-            raise PortError('Node does not contain port: "{}"'.format(port))
-
-        self._model.add_port_accept_connection_type(
-            port_name=port.name(),
-            port_type=port.type_(),
-            node_type=self.type_,
-            accept_pname=port_type_data['port_name'],
-            accept_ptype=port_type_data['port_type'],
-            accept_ntype=port_type_data['node_type']
-        )
-
-    def accepted_port_types(self, port):
-        """
-        Returns a dictionary of connection constrains of the port types
-        that allow for a pipe connection to this node.
-
-        Args:
-            port (NodeGraphQt.Port): port object.
-
-        Returns:
-            dict: {<node_type>: {<port_type>: [<port_name>]}}
-        """
-        ports = self._inputs + self._outputs
-        if port not in ports:
-            raise PortError('Node does not contain port "{}"'.format(port))
-
-        accepted_types = self.graph.model.port_accept_connection_types(
-            node_type=self.type_,
-            port_type=port.type_(),
-            port_name=port.name()
-        )
-        return accepted_types
-
-    def add_reject_port_type(self, port, port_type_data):
-        """
-        Add a reject constrain to a specified node port.
-
-        Once a constrain has been added only ports of that type specified will
-        NOT be allowed a pipe connection.
-
-        port type data example
-
-        .. highlight:: python
-        .. code-block:: python
-
-            {
-                'port_name': 'foo'
-                'port_type': PortTypeEnum.IN.value
-                'node_type': 'io.github.jchanvfx.NodeClass'
-            }
-
-        See Also:
-            :meth:`NodeGraphQt.Port.rejected_port_types`
-
-        Args:
-            port (NodeGraphQt.Port): port to assign constrain to.
-            port_type_data (dict): port type data to reject a connection
-        """
-        node_ports = self._inputs + self._outputs
-        if port not in node_ports:
-            raise PortError('Node does not contain port: "{}"'.format(port))
-
-        self._model.add_port_reject_connection_type(
-            port_name=port.name(),
-            port_type=port.type_(),
-            node_type=self.type_,
-            reject_pname=port_type_data['port_name'],
-            reject_ptype=port_type_data['port_type'],
-            reject_ntype=port_type_data['node_type']
-        )
-
-    def rejected_port_types(self, port):
-        """
-        Returns a dictionary of connection constrains of the port types
-        that are NOT allowed for a pipe connection to this node.
-
-        Args:
-            port (NodeGraphQt.Port): port object.
-
-        Returns:
-            dict: {<node_type>: {<port_type>: [<port_name>]}}
-        """
-        ports = self._inputs + self._outputs
-        if port not in ports:
-            raise PortError('Node does not contain port "{}"'.format(port))
-
-        rejected_types = self.graph.model.port_reject_connection_types(
-            node_type=self.type_,
-            port_type=port.type_(),
-            port_name=port.name()
-        )
-        return rejected_types
-
-    def on_input_connected(self, in_port, out_port):
-        """
-        Callback triggered when a new pipe connection is made.
-
-        *The default of this function does nothing re-implement if you require
-        logic to run for this event.*
-
-        Note:
-            to work with undo & redo for this method re-implement
-            :meth:`BaseNode.on_input_disconnected` with the reverse logic.
-
-        Args:
-            in_port (NodeGraphQt.Port): source input port from this node.
-            out_port (NodeGraphQt.Port): output port that connected to this node.
-        """
-        return
-
-    def on_input_disconnected(self, in_port, out_port):
-        """
-        Callback triggered when a pipe connection has been disconnected
-        from a INPUT port.
-
-        *The default of this function does nothing re-implement if you require
-        logic to run for this event.*
-
-        Note:
-            to work with undo & redo for this method re-implement
-            :meth:`BaseNode.on_input_connected` with the reverse logic.
-
-        Args:
-            in_port (NodeGraphQt.Port): source input port from this node.
-            out_port (NodeGraphQt.Port): output port that was disconnected.
-        """
-        return
+#!/usr/bin/python
+from collections import OrderedDict
+
+from NodeGraphQt.base.commands import NodeVisibleCmd
+from NodeGraphQt.base.node import NodeObject
+from NodeGraphQt.base.port import Port
+from NodeGraphQt.constants import NodePropWidgetEnum, PortTypeEnum
+from NodeGraphQt.errors import (PortError,
+                                PortRegistrationError,
+                                NodeWidgetError)
+from NodeGraphQt.qgraphics.node_base import NodeItem
+from NodeGraphQt.widgets.node_widgets import (NodeBaseWidget,
+                                              NodeComboBox,
+                                              NodeLineEdit,
+                                              NodeCheckBox)
+
+
+class BaseNode(NodeObject):
+    """
+    The ``NodeGraphQt.BaseNode`` class is the base class for nodes that allows
+    port connections from one node to another.
+
+    .. inheritance-diagram:: NodeGraphQt.BaseNode
+
+    .. image:: ../_images/node.png
+        :width: 250px
+
+    example snippet:
+
+    .. code-block:: python
+        :linenos:
+
+        from NodeGraphQt import BaseNode
+
+        class ExampleNode(BaseNode):
+
+            # unique node identifier domain.
+            __identifier__ = 'io.jchanvfx.github'
+
+            # initial default node name.
+            NODE_NAME = 'My Node'
+
+            def __init__(self):
+                super(ExampleNode, self).__init__()
+
+                # create an input port.
+                self.add_input('in')
+
+                # create an output port.
+                self.add_output('out')
+    """
+
+    NODE_NAME = 'Node'
+
+    def __init__(self, qgraphics_item=None):
+        super(BaseNode, self).__init__(qgraphics_item or NodeItem)
+        self._inputs = []
+        self._outputs = []
+
+    def update_model(self):
+        """
+        Update the node model from view.
+        """
+        for name, val in self.view.properties.items():
+            if name in ['inputs', 'outputs']:
+                continue
+            self.model.set_property(name, val)
+
+        for name, widget in self.view.widgets.items():
+            self.model.set_property(name, widget.get_value())
+
+    def set_property(self, name, value, push_undo=True):
+        """
+        Set the value on the node custom property.
+
+        Args:
+            name (str): name of the property.
+            value (object): property data (python built in types).
+            push_undo (bool): register the command to the undo stack. (default: True)
+        """
+        # prevent signals from causing a infinite loop.
+        if self.get_property(name) == value:
+            return
+
+        if name == 'visible':
+            if self.graph:
+                undo_cmd = NodeVisibleCmd(self, value)
+                if push_undo:
+                    self.graph.undo_stack().push(undo_cmd)
+                else:
+                    undo_cmd.redo()
+                return
+        elif name == 'disabled':
+            # redraw the connected pipes in the scene.
+            ports = self.view.inputs + self.view.outputs
+            for port in ports:
+                for pipe in port.connected_pipes:
+                    pipe.update()
+        super(BaseNode, self).set_property(name, value, push_undo)
+
+    def set_layout_direction(self, value=0):
+        """
+        Sets the node layout direction to either horizontal or vertical on
+        the current node only.
+
+        `Implemented in` ``v0.3.0``
+
+        See Also:
+            :meth:`NodeGraph.set_layout_direction`,
+            :meth:`NodeObject.layout_direction`
+
+
+        Warnings:
+            This function does not register to the undo stack.
+
+        Args:
+            value (int): layout direction mode.
+        """
+        # base logic to update the model and view attributes only.
+        super(BaseNode, self).set_layout_direction(value)
+        # redraw the node.
+        self._view.draw_node()
+
+    def set_icon(self, icon=None):
+        """
+        Set the node icon.
+
+        Args:
+            icon (str): path to the icon image.
+        """
+        self.set_property('icon', icon)
+
+    def icon(self):
+        """
+        Node icon path.
+
+        Returns:
+            str: icon image file path.
+        """
+        return self.model.icon
+
+    def widgets(self):
+        """
+        Returns all embedded widgets from this node.
+
+        See Also:
+            :meth:`BaseNode.get_widget`
+
+        Returns:
+            dict: embedded node widgets. {``property_name``: ``node_widget``}
+        """
+        return self.view.widgets
+
+    def get_widget(self, name):
+        """
+        Returns the embedded widget associated with the property name.
+
+        See Also:
+            :meth:`BaseNode.add_combo_menu`,
+            :meth:`BaseNode.add_text_input`,
+            :meth:`BaseNode.add_checkbox`,
+
+        Args:
+            name (str): node property name.
+
+        Returns:
+            NodeBaseWidget: embedded node widget.
+        """
+        return self.view.widgets.get(name)
+
+    def add_custom_widget(self, widget, widget_type=None, tab=None):
+        """
+        Add a custom node widget into the node.
+
+        see example :ref:`Embedding Custom Widgets`.
+
+        Note:
+            The ``value_changed`` signal from the added node widget is wired
+            up to the :meth:`NodeObject.set_property` function.
+
+        Args:
+            widget (NodeBaseWidget): node widget class object.
+            widget_type: widget flag to display in the
+                :class:`NodeGraphQt.PropertiesBinWidget`
+                (default: :attr:`NodeGraphQt.constants.NodePropWidgetEnum.HIDDEN`).
+            tab (str): name of the widget tab to display in.
+        """
+        if not isinstance(widget, NodeBaseWidget):
+            raise NodeWidgetError(
+                '\'widget\' must be an instance of a NodeBaseWidget')
+
+        widget_type = widget_type or NodePropWidgetEnum.HIDDEN.value
+        self.create_property(widget.get_name(),
+                             widget.get_value(),
+                             widget_type=widget_type,
+                             tab=tab)
+        widget.value_changed.connect(lambda k, v: self.set_property(k, v))
+        widget._node = self
+        self.view.add_widget(widget)
+        #: redraw node to address calls outside the "__init__" func.
+        self.view.draw_node()
+
+    def add_combo_menu(self, name, label='', items=None, tab=None):
+        """
+        Creates a custom property with the :meth:`NodeObject.create_property`
+        function and embeds a :class:`PySide2.QtWidgets.QComboBox` widget
+        into the node.
+
+        Note:
+            The ``value_changed`` signal from the added node widget is wired
+            up to the :meth:`NodeObject.set_property` function.
+
+        Args:
+            name (str): name for the custom property.
+            label (str): label to be displayed.
+            items (list[str]): items to be added into the menu.
+            tab (str): name of the widget tab to display in.
+        """
+        self.create_property(
+            name,
+            value=items[0] if items else None,
+            items=items or [],
+            widget_type=NodePropWidgetEnum.QCOMBO_BOX.value,
+            tab=tab
+        )
+        widget = NodeComboBox(self.view, name, label, items)
+        widget.value_changed.connect(lambda k, v: self.set_property(k, v))
+        self.view.add_widget(widget)
+        #: redraw node to address calls outside the "__init__" func.
+        self.view.draw_node()
+
+    def add_text_input(self, name, label='', text='', tab=None):
+        """
+        Creates a custom property with the :meth:`NodeObject.create_property`
+        function and embeds a :class:`PySide2.QtWidgets.QLineEdit` widget
+        into the node.
+
+        Note:
+            The ``value_changed`` signal from the added node widget is wired
+            up to the :meth:`NodeObject.set_property` function.
+
+        Args:
+            name (str): name for the custom property.
+            label (str): label to be displayed.
+            text (str): pre filled text.
+            tab (str): name of the widget tab to display in.
+        """
+        self.create_property(
+            name,
+            value=text,
+            widget_type=NodePropWidgetEnum.QLINE_EDIT.value,
+            tab=tab
+        )
+        widget = NodeLineEdit(self.view, name, label, text)
+        widget.value_changed.connect(lambda k, v: self.set_property(k, v))
+        self.view.add_widget(widget)
+        #: redraw node to address calls outside the "__init__" func.
+        self.view.draw_node()
+
+    def add_checkbox(self, name, label='', text='', state=False, tab=None):
+        """
+        Creates a custom property with the :meth:`NodeObject.create_property`
+        function and embeds a :class:`PySide2.QtWidgets.QCheckBox` widget
+        into the node.
+
+        Note:
+            The ``value_changed`` signal from the added node widget is wired
+            up to the :meth:`NodeObject.set_property` function.
+
+        Args:
+            name (str): name for the custom property.
+            label (str): label to be displayed.
+            text (str): checkbox text.
+            state (bool): pre-check.
+            tab (str): name of the widget tab to display in.
+        """
+        self.create_property(
+            name,
+            value=state,
+            widget_type=NodePropWidgetEnum.QCHECK_BOX.value,
+            tab=tab
+        )
+        widget = NodeCheckBox(self.view, name, label, text, state)
+        widget.value_changed.connect(lambda k, v: self.set_property(k, v))
+        self.view.add_widget(widget)
+        #: redraw node to address calls outside the "__init__" func.
+        self.view.draw_node()
+
+    def add_input(self, name='input', multi_input=False, display_name=True,
+                  color=None, locked=False, painter_func=None):
+        """
+        Add input :class:`Port` to node.
+
+        Warnings:
+            Undo is NOT supported for this function.
+
+        Args:
+            name (str): name for the input port.
+            multi_input (bool): allow port to have more than one connection.
+            display_name (bool): display the port name on the node.
+            color (tuple): initial port color (r, g, b) ``0-255``.
+            locked (bool): locked state see :meth:`Port.set_locked`
+            painter_func (function or None): custom function to override the drawing
+                of the port shape see example: :ref:`Creating Custom Shapes`
+
+        Returns:
+            NodeGraphQt.Port: the created port object.
+        """
+        if name in self.inputs().keys():
+            raise PortRegistrationError(
+                'port name "{}" already registered.'.format(name))
+
+        port_args = [name, multi_input, display_name, locked]
+        if painter_func and callable(painter_func):
+            port_args.append(painter_func)
+        view = self.view.add_input(*port_args)
+
+        if color:
+            view.color = color
+            view.border_color = [min([255, max([0, i + 80])]) for i in color]
+
+        port = Port(self, view)
+        port.model.type_ = PortTypeEnum.IN.value
+        port.model.name = name
+        port.model.display_name = display_name
+        port.model.multi_connection = multi_input
+        port.model.locked = locked
+        self._inputs.append(port)
+        self.model.inputs[port.name()] = port.model
+        return port
+
+    def add_output(self, name='output', multi_output=True, display_name=True,
+                   color=None, locked=False, painter_func=None):
+        """
+        Add output :class:`Port` to node.
+
+        Warnings:
+            Undo is NOT supported for this function.
+
+        Args:
+            name (str): name for the output port.
+            multi_output (bool): allow port to have more than one connection.
+            display_name (bool): display the port name on the node.
+            color (tuple): initial port color (r, g, b) ``0-255``.
+            locked (bool): locked state see :meth:`Port.set_locked`
+            painter_func (function or None): custom function to override the drawing
+                of the port shape see example: :ref:`Creating Custom Shapes`
+
+        Returns:
+            NodeGraphQt.Port: the created port object.
+        """
+        if name in self.outputs().keys():
+            raise PortRegistrationError(
+                'port name "{}" already registered.'.format(name))
+
+        port_args = [name, multi_output, display_name, locked]
+        if painter_func and callable(painter_func):
+            port_args.append(painter_func)
+        view = self.view.add_output(*port_args)
+
+        if color:
+            view.color = color
+            view.border_color = [min([255, max([0, i + 80])]) for i in color]
+        port = Port(self, view)
+        port.model.type_ = PortTypeEnum.OUT.value
+        port.model.name = name
+        port.model.display_name = display_name
+        port.model.multi_connection = multi_output
+        port.model.locked = locked
+        self._outputs.append(port)
+        self.model.outputs[port.name()] = port.model
+        return port
+
+    def get_input(self, port):
+        """
+        Get input port by the name or index.
+
+        Args:
+            port (str or int): port name or index.
+
+        Returns:
+            NodeGraphQt.Port: node port.
+        """
+        if type(port) is int:
+            if port < len(self._inputs):
+                return self._inputs[port]
+        elif type(port) is str:
+            return self.inputs().get(port, None)
+
+    def get_output(self, port):
+        """
+        Get output port by the name or index.
+
+        Args:
+            port (str or int): port name or index.
+
+        Returns:
+            NodeGraphQt.Port: node port.
+        """
+        if type(port) is int:
+            if port < len(self._outputs):
+                return self._outputs[port]
+        elif type(port) is str:
+            return self.outputs().get(port, None)
+
+    def delete_input(self, port):
+        """
+        Delete input port.
+
+        Warnings:
+            Undo is NOT supported for this function.
+
+            You can only delete ports if :meth:`BaseNode.port_deletion_allowed`
+            returns ``True`` otherwise a port error is raised see also
+            :meth:`BaseNode.set_port_deletion_allowed`.
+
+        Args:
+            port (str or int): port name or index.
+        """
+        if type(port) in [int, str]:
+            port = self.get_input(port)
+            if port is None:
+                return
+        if not self.port_deletion_allowed():
+            raise PortError(
+                'Port "{}" can\'t be deleted on this node because '
+                '"ports_removable" is not enabled.'.format(port.name()))
+        if port.locked():
+            raise PortError('Error: Can\'t delete a port that is locked!')
+        self._inputs.remove(port)
+        self._model.inputs.pop(port.name())
+        self._view.delete_input(port.view)
+        port.model.node = None
+        self._view.draw_node()
+
+    def delete_output(self, port):
+        """
+        Delete output port.
+
+        Warnings:
+            Undo is NOT supported for this function.
+
+            You can only delete ports if :meth:`BaseNode.port_deletion_allowed`
+            returns ``True`` otherwise a port error is raised see also
+            :meth:`BaseNode.set_port_deletion_allowed`.
+
+        Args:
+            port (str or int): port name or index.
+        """
+        if type(port) in [int, str]:
+            port = self.get_output(port)
+            if port is None:
+                return
+        if not self.port_deletion_allowed():
+            raise PortError(
+                'Port "{}" can\'t be deleted on this node because '
+                '"ports_removable" is not enabled.'.format(port.name()))
+        if port.locked():
+            raise PortError('Error: Can\'t delete a port that is locked!')
+        self._outputs.remove(port)
+        self._model.outputs.pop(port.name())
+        self._view.delete_output(port.view)
+        port.model.node = None
+        self._view.draw_node()
+
+    def set_port_deletion_allowed(self, mode=False):
+        """
+        Allow ports to be removable on this node.
+
+        See Also:
+            :meth:`BaseNode.port_deletion_allowed` and
+            :meth:`BaseNode.set_ports`
+
+        Args:
+            mode (bool): true to allow.
+        """
+        self.model.port_deletion_allowed = mode
+
+    def port_deletion_allowed(self):
+        """
+        Return true if ports can be deleted on this node.
+
+        See Also:
+            :meth:`BaseNode.set_port_deletion_allowed`
+
+        Returns:
+            bool: true if ports can be deleted.
+        """
+        return self.model.port_deletion_allowed
+
+    def set_ports(self, port_data):
+        """
+        Create node input and output ports from serialized port data.
+
+        Warnings:
+            You can only use this function if the node has
+            :meth:`BaseNode.port_deletion_allowed` is `True`
+            see :meth:`BaseNode.set_port_deletion_allowed`
+
+        Hint:
+            example snippet of port data.
+
+            .. highlight:: python
+            .. code-block:: python
+
+                {
+                    'input_ports':
+                        [{
+                            'name': 'input',
+                            'multi_connection': True,
+                            'display_name': 'Input',
+                            'locked': False
+                        }],
+                    'output_ports':
+                        [{
+                            'name': 'output',
+                            'multi_connection': True,
+                            'display_name': 'Output',
+                            'locked': False
+                        }]
+                }
+
+        Args:
+            port_data(dict): port data.
+        """
+        if not self.port_deletion_allowed():
+            raise PortError(
+                'Ports cannot be set on this node because '
+                '"set_port_deletion_allowed" is not enabled on this node.')
+
+        for port in self._inputs:
+            self._view.delete_input(port.view)
+            port.model.node = None
+        for port in self._outputs:
+            self._view.delete_output(port.view)
+            port.model.node = None
+        self._inputs = []
+        self._outputs = []
+        self._model.outputs = {}
+        self._model.inputs = {}
+
+        [self.add_input(name=port['name'],
+                        multi_input=port['multi_connection'],
+                        display_name=port['display_name'],
+                        locked=port.get('locked') or False)
+         for port in port_data['input_ports']]
+        [self.add_output(name=port['name'],
+                         multi_output=port['multi_connection'],
+                         display_name=port['display_name'],
+                         locked=port.get('locked') or False)
+         for port in port_data['output_ports']]
+        self._view.draw_node()
+
+    def inputs(self):
+        """
+        Returns all the input ports from the node.
+
+        Returns:
+            dict: {<port_name>: <port_object>}
+        """
+        return {p.name(): p for p in self._inputs}
+
+    def input_ports(self):
+        """
+        Return all input ports.
+
+        Returns:
+            list[NodeGraphQt.Port]: node input ports.
+        """
+        return self._inputs
+
+    def outputs(self):
+        """
+        Returns all the output ports from the node.
+
+        Returns:
+            dict: {<port_name>: <port_object>}
+        """
+        return {p.name(): p for p in self._outputs}
+
+    def output_ports(self):
+        """
+        Return all output ports.
+
+        Returns:
+            list[NodeGraphQt.Port]: node output ports.
+        """
+        return self._outputs
+
+    def input(self, index):
+        """
+        Return the input port with the matching index.
+
+        Args:
+            index (int): index of the input port.
+
+        Returns:
+            NodeGraphQt.Port: port object.
+        """
+        return self._inputs[index]
+
+    def set_input(self, index, port):
+        """
+        Creates a connection pipe to the targeted output :class:`Port`.
+
+        Args:
+            index (int): index of the port.
+            port (NodeGraphQt.Port): port object.
+        """
+        src_port = self.input(index)
+        src_port.connect_to(port)
+
+    def output(self, index):
+        """
+        Return the output port with the matching index.
+
+        Args:
+            index (int): index of the output port.
+
+        Returns:
+            NodeGraphQt.Port: port object.
+        """
+        return self._outputs[index]
+
+    def set_output(self, index, port):
+        """
+        Creates a connection pipe to the targeted input :class:`Port`.
+
+        Args:
+            index (int): index of the port.
+            port (NodeGraphQt.Port): port object.
+        """
+        src_port = self.output(index)
+        src_port.connect_to(port)
+
+    def connected_input_nodes(self):
+        """
+        Returns all nodes connected from the input ports.
+
+        Returns:
+            dict: {<input_port>: <node_list>}
+        """
+        nodes = OrderedDict()
+        for p in self.input_ports():
+            nodes[p] = [cp.node() for cp in p.connected_ports()]
+        return nodes
+
+    def connected_output_nodes(self):
+        """
+        Returns all nodes connected from the output ports.
+
+        Returns:
+            dict: {<output_port>: <node_list>}
+        """
+        nodes = OrderedDict()
+        for p in self.output_ports():
+            nodes[p] = [cp.node() for cp in p.connected_ports()]
+        return nodes
+
+    def add_accept_port_type(self, port, port_type_data):
+        """
+        Add a accept constrain to a specified node port.
+
+        Once a constrain has been added only ports of that type specified will
+        be allowed a pipe connection.
+
+        port type data example
+
+        .. highlight:: python
+        .. code-block:: python
+
+            {
+                'port_name': 'foo'
+                'port_type': PortTypeEnum.IN.value
+                'node_type': 'io.github.jchanvfx.NodeClass'
+            }
+
+        See Also:
+            :meth:`NodeGraphQt.BaseNode.accepted_port_types`
+
+        Args:
+            port (NodeGraphQt.Port): port to assign constrain to.
+            port_type_data (dict): port type data to accept a connection
+        """
+        node_ports = self._inputs + self._outputs
+        if port not in node_ports:
+            raise PortError('Node does not contain port: "{}"'.format(port))
+
+        self._model.add_port_accept_connection_type(
+            port_name=port.name(),
+            port_type=port.type_(),
+            node_type=self.type_,
+            accept_pname=port_type_data['port_name'],
+            accept_ptype=port_type_data['port_type'],
+            accept_ntype=port_type_data['node_type']
+        )
+
+    def accepted_port_types(self, port):
+        """
+        Returns a dictionary of connection constrains of the port types
+        that allow for a pipe connection to this node.
+
+        Args:
+            port (NodeGraphQt.Port): port object.
+
+        Returns:
+            dict: {<node_type>: {<port_type>: [<port_name>]}}
+        """
+        ports = self._inputs + self._outputs
+        if port not in ports:
+            raise PortError('Node does not contain port "{}"'.format(port))
+
+        accepted_types = self.graph.model.port_accept_connection_types(
+            node_type=self.type_,
+            port_type=port.type_(),
+            port_name=port.name()
+        )
+        return accepted_types
+
+    def add_reject_port_type(self, port, port_type_data):
+        """
+        Add a reject constrain to a specified node port.
+
+        Once a constrain has been added only ports of that type specified will
+        NOT be allowed a pipe connection.
+
+        port type data example
+
+        .. highlight:: python
+        .. code-block:: python
+
+            {
+                'port_name': 'foo'
+                'port_type': PortTypeEnum.IN.value
+                'node_type': 'io.github.jchanvfx.NodeClass'
+            }
+
+        See Also:
+            :meth:`NodeGraphQt.Port.rejected_port_types`
+
+        Args:
+            port (NodeGraphQt.Port): port to assign constrain to.
+            port_type_data (dict): port type data to reject a connection
+        """
+        node_ports = self._inputs + self._outputs
+        if port not in node_ports:
+            raise PortError('Node does not contain port: "{}"'.format(port))
+
+        self._model.add_port_reject_connection_type(
+            port_name=port.name(),
+            port_type=port.type_(),
+            node_type=self.type_,
+            reject_pname=port_type_data['port_name'],
+            reject_ptype=port_type_data['port_type'],
+            reject_ntype=port_type_data['node_type']
+        )
+
+    def rejected_port_types(self, port):
+        """
+        Returns a dictionary of connection constrains of the port types
+        that are NOT allowed for a pipe connection to this node.
+
+        Args:
+            port (NodeGraphQt.Port): port object.
+
+        Returns:
+            dict: {<node_type>: {<port_type>: [<port_name>]}}
+        """
+        ports = self._inputs + self._outputs
+        if port not in ports:
+            raise PortError('Node does not contain port "{}"'.format(port))
+
+        rejected_types = self.graph.model.port_reject_connection_types(
+            node_type=self.type_,
+            port_type=port.type_(),
+            port_name=port.name()
+        )
+        return rejected_types
+
+    def on_input_connected(self, in_port, out_port):
+        """
+        Callback triggered when a new pipe connection is made.
+
+        *The default of this function does nothing re-implement if you require
+        logic to run for this event.*
+
+        Note:
+            to work with undo & redo for this method re-implement
+            :meth:`BaseNode.on_input_disconnected` with the reverse logic.
+
+        Args:
+            in_port (NodeGraphQt.Port): source input port from this node.
+            out_port (NodeGraphQt.Port): output port that connected to this node.
+        """
+        return
+
+    def on_input_disconnected(self, in_port, out_port):
+        """
+        Callback triggered when a pipe connection has been disconnected
+        from a INPUT port.
+
+        *The default of this function does nothing re-implement if you require
+        logic to run for this event.*
+
+        Note:
+            to work with undo & redo for this method re-implement
+            :meth:`BaseNode.on_input_connected` with the reverse logic.
+
+        Args:
+            in_port (NodeGraphQt.Port): source input port from this node.
+            out_port (NodeGraphQt.Port): output port that was disconnected.
+        """
+        return
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/nodes/group_node.py` & `NodeGraphQt-0.6.3/NodeGraphQt/nodes/group_node.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,176 +1,176 @@
-#!/usr/bin/python
-from NodeGraphQt.nodes.base_node import BaseNode
-from NodeGraphQt.nodes.port_node import PortInputNode, PortOutputNode
-from NodeGraphQt.qgraphics.node_group import GroupNodeItem
-
-
-class GroupNode(BaseNode):
-    """
-    `Implemented in` ``v0.2.0``
-
-    The ``NodeGraphQt.GroupNode`` class extends from the :class:`NodeGraphQt.BaseNode`
-    class with the ability to nest other nodes inside of it.
-
-    .. inheritance-diagram:: NodeGraphQt.GroupNode
-
-    .. image:: ../_images/group_node.png
-        :width: 250px
-
-    -
-    """
-
-    NODE_NAME = 'Group'
-
-    def __init__(self, qgraphics_item=None):
-        super(GroupNode, self).__init__(qgraphics_item or GroupNodeItem)
-        self._input_port_nodes = {}
-        self._output_port_nodes = {}
-
-    @property
-    def is_expanded(self):
-        """
-        Returns if the group node is expanded or collapsed.
-
-        Returns:
-            bool: true if the node is expanded.
-        """
-        if not self.graph:
-            return False
-        return bool(self.id in self.graph.sub_graphs)
-
-    def get_sub_graph(self):
-        """
-        Returns the sub graph controller to the group node if initialized
-        or returns None.
-
-        Returns:
-            SubGraph: sub graph controller.
-        """
-        return self.graph.sub_graphs.get(self.id)
-
-    def get_sub_graph_session(self):
-        """
-        Returns the serialized sub graph session.
-
-        Returns:
-            dict: serialized sub graph session.
-        """
-        return self.model.subgraph_session
-
-    def set_sub_graph_session(self, serialized_session):
-        """
-        Sets the sub graph session data to the group node.
-
-        Args:
-            serialized_session (dict): serialized session.
-        """
-        serialized_session = serialized_session or {}
-        self.model.subgraph_session = serialized_session
-
-    def expand(self):
-        """
-        Expand the group node session.
-
-        See Also:
-            :meth:`NodeGraph.expand_group_node`,
-            :meth:`SubGraph.expand_group_node`.
-
-        Returns:
-            SubGraph: node graph used to manage the nodes expaneded session.
-        """
-        sub_graph = self.graph.expand_group_node(self)
-        return sub_graph
-
-    def collapse(self):
-        """
-        Collapse the group node session it's expanded child sub graphs.
-
-        See Also:
-            :meth:`NodeGraph.collapse_group_node`,
-            :meth:`SubGraph.collapse_group_node`.
-        """
-        self.graph.collapse_group_node(self)
-
-    def set_name(self, name=''):
-        super(GroupNode, self).set_name(name)
-        # update the tab bar and navigation labels.
-        sub_graph = self.get_sub_graph()
-        if sub_graph:
-            nav_widget = sub_graph.navigation_widget
-            nav_widget.update_label_item(self.name(), self.id)
-
-            if sub_graph.parent_graph.is_root:
-                root_graph = sub_graph.parent_graph
-                tab_bar = root_graph.widget.tabBar()
-                for idx in range(tab_bar.count()):
-                    if tab_bar.tabToolTip(idx) == self.id:
-                        tab_bar.setTabText(idx, self.name())
-                        break
-
-    def add_input(self, name='input', multi_input=False, display_name=True,
-                  color=None, locked=False, painter_func=None):
-        port = super(GroupNode, self).add_input(
-            name=name,
-            multi_input=multi_input,
-            display_name=display_name,
-            color=color,
-            locked=locked,
-            painter_func=painter_func
-        )
-        if self.is_expanded:
-            input_node = PortInputNode(parent_port=port)
-            input_node.NODE_NAME = port.name()
-            input_node.model.set_property('name', port.name())
-            input_node.add_output(port.name())
-            sub_graph = self.get_sub_graph()
-            sub_graph.add_node(input_node, selected=False, push_undo=False)
-
-        return port
-
-    def add_output(self, name='output', multi_output=True, display_name=True,
-                   color=None, locked=False, painter_func=None):
-        port = super(GroupNode, self).add_output(
-            name=name,
-            multi_output=multi_output,
-            display_name=display_name,
-            color=color,
-            locked=locked,
-            painter_func=painter_func
-        )
-        if self.is_expanded:
-            output_port = PortOutputNode(parent_port=port)
-            output_port.NODE_NAME = port.name()
-            output_port.model.set_property('name', port.name())
-            output_port.add_input(port.name())
-            sub_graph = self.get_sub_graph()
-            sub_graph.add_node(output_port, selected=False, push_undo=False)
-
-        return port
-
-    def delete_input(self, port):
-        if type(port) in [int, str]:
-            port = self.get_output(port)
-            if port is None:
-                return
-
-        if self.is_expanded:
-            sub_graph = self.get_sub_graph()
-            port_node = sub_graph.get_node_by_port(port)
-            if port_node:
-                sub_graph.remove_node(port_node, push_undo=False)
-
-        super(GroupNode, self).delete_input(port)
-
-    def delete_output(self, port):
-        if type(port) in [int, str]:
-            port = self.get_output(port)
-            if port is None:
-                return
-
-        if self.is_expanded:
-            sub_graph = self.get_sub_graph()
-            port_node = sub_graph.get_node_by_port(port)
-            if port_node:
-                sub_graph.remove_node(port_node, push_undo=False)
-
-        super(GroupNode, self).delete_output(port)
+#!/usr/bin/python
+from NodeGraphQt.nodes.base_node import BaseNode
+from NodeGraphQt.nodes.port_node import PortInputNode, PortOutputNode
+from NodeGraphQt.qgraphics.node_group import GroupNodeItem
+
+
+class GroupNode(BaseNode):
+    """
+    `Implemented in` ``v0.2.0``
+
+    The ``NodeGraphQt.GroupNode`` class extends from the :class:`NodeGraphQt.BaseNode`
+    class with the ability to nest other nodes inside of it.
+
+    .. inheritance-diagram:: NodeGraphQt.GroupNode
+
+    .. image:: ../_images/group_node.png
+        :width: 250px
+
+    -
+    """
+
+    NODE_NAME = 'Group'
+
+    def __init__(self, qgraphics_item=None):
+        super(GroupNode, self).__init__(qgraphics_item or GroupNodeItem)
+        self._input_port_nodes = {}
+        self._output_port_nodes = {}
+
+    @property
+    def is_expanded(self):
+        """
+        Returns if the group node is expanded or collapsed.
+
+        Returns:
+            bool: true if the node is expanded.
+        """
+        if not self.graph:
+            return False
+        return bool(self.id in self.graph.sub_graphs)
+
+    def get_sub_graph(self):
+        """
+        Returns the sub graph controller to the group node if initialized
+        or returns None.
+
+        Returns:
+            SubGraph: sub graph controller.
+        """
+        return self.graph.sub_graphs.get(self.id)
+
+    def get_sub_graph_session(self):
+        """
+        Returns the serialized sub graph session.
+
+        Returns:
+            dict: serialized sub graph session.
+        """
+        return self.model.subgraph_session
+
+    def set_sub_graph_session(self, serialized_session):
+        """
+        Sets the sub graph session data to the group node.
+
+        Args:
+            serialized_session (dict): serialized session.
+        """
+        serialized_session = serialized_session or {}
+        self.model.subgraph_session = serialized_session
+
+    def expand(self):
+        """
+        Expand the group node session.
+
+        See Also:
+            :meth:`NodeGraph.expand_group_node`,
+            :meth:`SubGraph.expand_group_node`.
+
+        Returns:
+            SubGraph: node graph used to manage the nodes expaneded session.
+        """
+        sub_graph = self.graph.expand_group_node(self)
+        return sub_graph
+
+    def collapse(self):
+        """
+        Collapse the group node session it's expanded child sub graphs.
+
+        See Also:
+            :meth:`NodeGraph.collapse_group_node`,
+            :meth:`SubGraph.collapse_group_node`.
+        """
+        self.graph.collapse_group_node(self)
+
+    def set_name(self, name=''):
+        super(GroupNode, self).set_name(name)
+        # update the tab bar and navigation labels.
+        sub_graph = self.get_sub_graph()
+        if sub_graph:
+            nav_widget = sub_graph.navigation_widget
+            nav_widget.update_label_item(self.name(), self.id)
+
+            if sub_graph.parent_graph.is_root:
+                root_graph = sub_graph.parent_graph
+                tab_bar = root_graph.widget.tabBar()
+                for idx in range(tab_bar.count()):
+                    if tab_bar.tabToolTip(idx) == self.id:
+                        tab_bar.setTabText(idx, self.name())
+                        break
+
+    def add_input(self, name='input', multi_input=False, display_name=True,
+                  color=None, locked=False, painter_func=None):
+        port = super(GroupNode, self).add_input(
+            name=name,
+            multi_input=multi_input,
+            display_name=display_name,
+            color=color,
+            locked=locked,
+            painter_func=painter_func
+        )
+        if self.is_expanded:
+            input_node = PortInputNode(parent_port=port)
+            input_node.NODE_NAME = port.name()
+            input_node.model.set_property('name', port.name())
+            input_node.add_output(port.name())
+            sub_graph = self.get_sub_graph()
+            sub_graph.add_node(input_node, selected=False, push_undo=False)
+
+        return port
+
+    def add_output(self, name='output', multi_output=True, display_name=True,
+                   color=None, locked=False, painter_func=None):
+        port = super(GroupNode, self).add_output(
+            name=name,
+            multi_output=multi_output,
+            display_name=display_name,
+            color=color,
+            locked=locked,
+            painter_func=painter_func
+        )
+        if self.is_expanded:
+            output_port = PortOutputNode(parent_port=port)
+            output_port.NODE_NAME = port.name()
+            output_port.model.set_property('name', port.name())
+            output_port.add_input(port.name())
+            sub_graph = self.get_sub_graph()
+            sub_graph.add_node(output_port, selected=False, push_undo=False)
+
+        return port
+
+    def delete_input(self, port):
+        if type(port) in [int, str]:
+            port = self.get_output(port)
+            if port is None:
+                return
+
+        if self.is_expanded:
+            sub_graph = self.get_sub_graph()
+            port_node = sub_graph.get_node_by_port(port)
+            if port_node:
+                sub_graph.remove_node(port_node, push_undo=False)
+
+        super(GroupNode, self).delete_input(port)
+
+    def delete_output(self, port):
+        if type(port) in [int, str]:
+            port = self.get_output(port)
+            if port is None:
+                return
+
+        if self.is_expanded:
+            sub_graph = self.get_sub_graph()
+            port_node = sub_graph.get_node_by_port(port)
+            if port_node:
+                sub_graph.remove_node(port_node, push_undo=False)
+
+        super(GroupNode, self).delete_output(port)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_backdrop.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_backdrop.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,304 +1,304 @@
-#!/usr/bin/python
-from Qt import QtGui, QtCore, QtWidgets
-
-from NodeGraphQt.constants import Z_VAL_PIPE, NodeEnum
-from NodeGraphQt.qgraphics.node_abstract import AbstractNodeItem
-from NodeGraphQt.qgraphics.pipe import PipeItem
-from NodeGraphQt.qgraphics.port import PortItem
-
-
-class BackdropSizer(QtWidgets.QGraphicsItem):
-    """
-    Sizer item for resizing a backdrop item.
-
-    Args:
-        parent (BackdropNodeItem): the parent node item.
-        size (float): sizer size.
-    """
-
-    def __init__(self, parent=None, size=6.0):
-        super(BackdropSizer, self).__init__(parent)
-        self.setFlag(self.ItemIsSelectable, True)
-        self.setFlag(self.ItemIsMovable, True)
-        self.setFlag(self.ItemSendsScenePositionChanges, True)
-        self.setCursor(QtGui.QCursor(QtCore.Qt.SizeFDiagCursor))
-        self.setToolTip('double-click auto resize')
-        self._size = size
-
-    @property
-    def size(self):
-        return self._size
-
-    def set_pos(self, x, y):
-        x -= self._size
-        y -= self._size
-        self.setPos(x, y)
-
-    def boundingRect(self):
-        return QtCore.QRectF(0.5, 0.5, self._size, self._size)
-
-    def itemChange(self, change, value):
-        if change == self.ItemPositionChange:
-            item = self.parentItem()
-            mx, my = item.minimum_size
-            x = mx if value.x() < mx else value.x()
-            y = my if value.y() < my else value.y()
-            value = QtCore.QPointF(x, y)
-            item.on_sizer_pos_changed(value)
-            return value
-        return super(BackdropSizer, self).itemChange(change, value)
-
-    def mouseDoubleClickEvent(self, event):
-        item = self.parentItem()
-        item.on_sizer_double_clicked()
-        super(BackdropSizer, self).mouseDoubleClickEvent(event)
-
-    def mousePressEvent(self, event):
-        self.__prev_xy = (self.pos().x(), self.pos().y())
-        super(BackdropSizer, self).mousePressEvent(event)
-
-    def mouseReleaseEvent(self, event):
-        current_xy = (self.pos().x(), self.pos().y())
-        if current_xy != self.__prev_xy:
-            item = self.parentItem()
-            item.on_sizer_pos_mouse_release()
-        del self.__prev_xy
-        super(BackdropSizer, self).mouseReleaseEvent(event)
-
-    def paint(self, painter, option, widget):
-        """
-        Draws the backdrop sizer on the bottom right corner.
-
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        painter.save()
-
-        margin = 1.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        item = self.parentItem()
-        if item and item.selected:
-            color = QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value)
-        else:
-            color = QtGui.QColor(*item.color)
-            color = color.darker(110)
-        path = QtGui.QPainterPath()
-        path.moveTo(rect.topRight())
-        path.lineTo(rect.bottomRight())
-        path.lineTo(rect.bottomLeft())
-        painter.setBrush(color)
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.fillPath(path, painter.brush())
-
-        painter.restore()
-
-
-class BackdropNodeItem(AbstractNodeItem):
-    """
-    Base Backdrop item.
-
-    Args:
-        name (str): name displayed on the node.
-        text (str): backdrop text.
-        parent (QtWidgets.QGraphicsItem): parent item.
-    """
-
-    def __init__(self, name='backdrop', text='', parent=None):
-        super(BackdropNodeItem, self).__init__(name, parent)
-        self.setZValue(Z_VAL_PIPE - 1)
-        self._properties['backdrop_text'] = text
-        self._min_size = 80, 80
-        self._sizer = BackdropSizer(self, 26.0)
-        self._sizer.set_pos(*self._min_size)
-        self._nodes = [self]
-
-    def _combined_rect(self, nodes):
-        group = self.scene().createItemGroup(nodes)
-        rect = group.boundingRect()
-        self.scene().destroyItemGroup(group)
-        return rect
-
-    def mouseDoubleClickEvent(self, event):
-        viewer = self.viewer()
-        if viewer:
-            viewer.node_double_clicked.emit(self.id)
-        super(BackdropNodeItem, self).mouseDoubleClickEvent(event)
-
-    def mousePressEvent(self, event):
-        if event.button() == QtCore.Qt.LeftButton:
-            pos = event.scenePos()
-            rect = QtCore.QRectF(pos.x() - 5, pos.y() - 5, 10, 10)
-            item = self.scene().items(rect)[0]
-
-            if isinstance(item, (PortItem, PipeItem)):
-                self.setFlag(self.ItemIsMovable, False)
-                return
-            if self.selected:
-                return
-
-            viewer = self.viewer()
-            [n.setSelected(False) for n in viewer.selected_nodes()]
-
-            self._nodes += self.get_nodes(False)
-            [n.setSelected(True) for n in self._nodes]
-
-    def mouseReleaseEvent(self, event):
-        super(BackdropNodeItem, self).mouseReleaseEvent(event)
-        self.setFlag(self.ItemIsMovable, True)
-        [n.setSelected(True) for n in self._nodes]
-        self._nodes = [self]
-
-    def on_sizer_pos_changed(self, pos):
-        self._width = pos.x() + self._sizer.size
-        self._height = pos.y() + self._sizer.size
-
-    def on_sizer_pos_mouse_release(self):
-        size = {
-            'pos': self.xy_pos,
-            'width': self._width,
-            'height': self._height}
-        self.viewer().node_backdrop_updated.emit(
-            self.id, 'sizer_mouse_release', size)
-
-    def on_sizer_double_clicked(self):
-        size = self.calc_backdrop_size()
-        self.viewer().node_backdrop_updated.emit(
-            self.id, 'sizer_double_clicked', size)
-
-    def paint(self, painter, option, widget):
-        """
-        Draws the backdrop rect.
-
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        painter.save()
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.setBrush(QtCore.Qt.NoBrush)
-
-        margin = 1.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        radius = 2.6
-        color = (self.color[0], self.color[1], self.color[2], 50)
-        painter.setBrush(QtGui.QColor(*color))
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.drawRoundedRect(rect, radius, radius)
-
-        top_rect = QtCore.QRectF(rect.x(), rect.y(), rect.width(), 26.0)
-        painter.setBrush(QtGui.QBrush(QtGui.QColor(*self.color)))
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.drawRoundedRect(top_rect, radius, radius)
-        for pos in [top_rect.left(), top_rect.right() - 5.0]:
-            painter.drawRect(
-                QtCore.QRectF(pos, top_rect.bottom() - 5.0, 5.0, 5.0))
-
-        if self.backdrop_text:
-            painter.setPen(QtGui.QColor(*self.text_color))
-            txt_rect = QtCore.QRectF(
-                top_rect.x() + 5.0, top_rect.height() + 3.0,
-                rect.width() - 5.0, rect.height())
-            painter.setPen(QtGui.QColor(*self.text_color))
-            painter.drawText(txt_rect,
-                             QtCore.Qt.AlignLeft | QtCore.Qt.TextWordWrap,
-                             self.backdrop_text)
-
-        if self.selected:
-            sel_color = [x for x in NodeEnum.SELECTED_COLOR.value]
-            sel_color[-1] = 15
-            painter.setBrush(QtGui.QColor(*sel_color))
-            painter.setPen(QtCore.Qt.NoPen)
-            painter.drawRoundedRect(rect, radius, radius)
-
-        txt_rect = QtCore.QRectF(top_rect.x(), top_rect.y(),
-                                 rect.width(), top_rect.height())
-        painter.setPen(QtGui.QColor(*self.text_color))
-        painter.drawText(txt_rect, QtCore.Qt.AlignCenter, self.name)
-
-        border = 0.8
-        border_color = self.color
-        if self.selected and NodeEnum.SELECTED_BORDER_COLOR.value:
-            border = 1.0
-            border_color = NodeEnum.SELECTED_BORDER_COLOR.value
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtGui.QPen(QtGui.QColor(*border_color), border))
-        painter.drawRoundedRect(rect, radius, radius)
-
-        painter.restore()
-
-    def get_nodes(self, inc_intersects=False):
-        mode = {True: QtCore.Qt.IntersectsItemShape,
-                False: QtCore.Qt.ContainsItemShape}
-        nodes = []
-        if self.scene():
-            polygon = self.mapToScene(self.boundingRect())
-            rect = polygon.boundingRect()
-            items = self.scene().items(rect, mode=mode[inc_intersects])
-            for item in items:
-                if item == self or item == self._sizer:
-                    continue
-                if isinstance(item, AbstractNodeItem):
-                    nodes.append(item)
-        return nodes
-
-    def calc_backdrop_size(self, nodes=None):
-        nodes = nodes or self.get_nodes(True)
-        if nodes:
-            nodes_rect = self._combined_rect(nodes)
-        else:
-            center = self.mapToScene(self.boundingRect().center())
-            nodes_rect = QtCore.QRectF(
-                center.x(), center.y(),
-                self._min_size[0], self._min_size[1]
-            )
-
-        padding = 40
-        return {
-            'pos': [
-                nodes_rect.x() - padding, nodes_rect.y() - padding
-            ],
-            'width': nodes_rect.width() + (padding * 2),
-            'height': nodes_rect.height() + (padding * 2)
-        }
-
-    @property
-    def minimum_size(self):
-        return self._min_size
-
-    @minimum_size.setter
-    def minimum_size(self, size=(50, 50)):
-        self._min_size = size
-
-    @property
-    def backdrop_text(self):
-        return self._properties['backdrop_text']
-
-    @backdrop_text.setter
-    def backdrop_text(self, text):
-        self._properties['backdrop_text'] = text
-        self.update(self.boundingRect())
-
-    @AbstractNodeItem.width.setter
-    def width(self, width=0.0):
-        AbstractNodeItem.width.fset(self, width)
-        self._sizer.set_pos(self._width, self._height)
-
-    @AbstractNodeItem.height.setter
-    def height(self, height=0.0):
-        AbstractNodeItem.height.fset(self, height)
-        self._sizer.set_pos(self._width, self._height)
+#!/usr/bin/python
+from Qt import QtGui, QtCore, QtWidgets
+
+from NodeGraphQt.constants import Z_VAL_PIPE, NodeEnum
+from NodeGraphQt.qgraphics.node_abstract import AbstractNodeItem
+from NodeGraphQt.qgraphics.pipe import PipeItem
+from NodeGraphQt.qgraphics.port import PortItem
+
+
+class BackdropSizer(QtWidgets.QGraphicsItem):
+    """
+    Sizer item for resizing a backdrop item.
+
+    Args:
+        parent (BackdropNodeItem): the parent node item.
+        size (float): sizer size.
+    """
+
+    def __init__(self, parent=None, size=6.0):
+        super(BackdropSizer, self).__init__(parent)
+        self.setFlag(self.ItemIsSelectable, True)
+        self.setFlag(self.ItemIsMovable, True)
+        self.setFlag(self.ItemSendsScenePositionChanges, True)
+        self.setCursor(QtGui.QCursor(QtCore.Qt.SizeFDiagCursor))
+        self.setToolTip('double-click auto resize')
+        self._size = size
+
+    @property
+    def size(self):
+        return self._size
+
+    def set_pos(self, x, y):
+        x -= self._size
+        y -= self._size
+        self.setPos(x, y)
+
+    def boundingRect(self):
+        return QtCore.QRectF(0.5, 0.5, self._size, self._size)
+
+    def itemChange(self, change, value):
+        if change == self.ItemPositionChange:
+            item = self.parentItem()
+            mx, my = item.minimum_size
+            x = mx if value.x() < mx else value.x()
+            y = my if value.y() < my else value.y()
+            value = QtCore.QPointF(x, y)
+            item.on_sizer_pos_changed(value)
+            return value
+        return super(BackdropSizer, self).itemChange(change, value)
+
+    def mouseDoubleClickEvent(self, event):
+        item = self.parentItem()
+        item.on_sizer_double_clicked()
+        super(BackdropSizer, self).mouseDoubleClickEvent(event)
+
+    def mousePressEvent(self, event):
+        self.__prev_xy = (self.pos().x(), self.pos().y())
+        super(BackdropSizer, self).mousePressEvent(event)
+
+    def mouseReleaseEvent(self, event):
+        current_xy = (self.pos().x(), self.pos().y())
+        if current_xy != self.__prev_xy:
+            item = self.parentItem()
+            item.on_sizer_pos_mouse_release()
+        del self.__prev_xy
+        super(BackdropSizer, self).mouseReleaseEvent(event)
+
+    def paint(self, painter, option, widget):
+        """
+        Draws the backdrop sizer on the bottom right corner.
+
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        painter.save()
+
+        margin = 1.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        item = self.parentItem()
+        if item and item.selected:
+            color = QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value)
+        else:
+            color = QtGui.QColor(*item.color)
+            color = color.darker(110)
+        path = QtGui.QPainterPath()
+        path.moveTo(rect.topRight())
+        path.lineTo(rect.bottomRight())
+        path.lineTo(rect.bottomLeft())
+        painter.setBrush(color)
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.fillPath(path, painter.brush())
+
+        painter.restore()
+
+
+class BackdropNodeItem(AbstractNodeItem):
+    """
+    Base Backdrop item.
+
+    Args:
+        name (str): name displayed on the node.
+        text (str): backdrop text.
+        parent (QtWidgets.QGraphicsItem): parent item.
+    """
+
+    def __init__(self, name='backdrop', text='', parent=None):
+        super(BackdropNodeItem, self).__init__(name, parent)
+        self.setZValue(Z_VAL_PIPE - 1)
+        self._properties['backdrop_text'] = text
+        self._min_size = 80, 80
+        self._sizer = BackdropSizer(self, 26.0)
+        self._sizer.set_pos(*self._min_size)
+        self._nodes = [self]
+
+    def _combined_rect(self, nodes):
+        group = self.scene().createItemGroup(nodes)
+        rect = group.boundingRect()
+        self.scene().destroyItemGroup(group)
+        return rect
+
+    def mouseDoubleClickEvent(self, event):
+        viewer = self.viewer()
+        if viewer:
+            viewer.node_double_clicked.emit(self.id)
+        super(BackdropNodeItem, self).mouseDoubleClickEvent(event)
+
+    def mousePressEvent(self, event):
+        if event.button() == QtCore.Qt.LeftButton:
+            pos = event.scenePos()
+            rect = QtCore.QRectF(pos.x() - 5, pos.y() - 5, 10, 10)
+            item = self.scene().items(rect)[0]
+
+            if isinstance(item, (PortItem, PipeItem)):
+                self.setFlag(self.ItemIsMovable, False)
+                return
+            if self.selected:
+                return
+
+            viewer = self.viewer()
+            [n.setSelected(False) for n in viewer.selected_nodes()]
+
+            self._nodes += self.get_nodes(False)
+            [n.setSelected(True) for n in self._nodes]
+
+    def mouseReleaseEvent(self, event):
+        super(BackdropNodeItem, self).mouseReleaseEvent(event)
+        self.setFlag(self.ItemIsMovable, True)
+        [n.setSelected(True) for n in self._nodes]
+        self._nodes = [self]
+
+    def on_sizer_pos_changed(self, pos):
+        self._width = pos.x() + self._sizer.size
+        self._height = pos.y() + self._sizer.size
+
+    def on_sizer_pos_mouse_release(self):
+        size = {
+            'pos': self.xy_pos,
+            'width': self._width,
+            'height': self._height}
+        self.viewer().node_backdrop_updated.emit(
+            self.id, 'sizer_mouse_release', size)
+
+    def on_sizer_double_clicked(self):
+        size = self.calc_backdrop_size()
+        self.viewer().node_backdrop_updated.emit(
+            self.id, 'sizer_double_clicked', size)
+
+    def paint(self, painter, option, widget):
+        """
+        Draws the backdrop rect.
+
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        painter.save()
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.setBrush(QtCore.Qt.NoBrush)
+
+        margin = 1.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        radius = 2.6
+        color = (self.color[0], self.color[1], self.color[2], 50)
+        painter.setBrush(QtGui.QColor(*color))
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.drawRoundedRect(rect, radius, radius)
+
+        top_rect = QtCore.QRectF(rect.x(), rect.y(), rect.width(), 26.0)
+        painter.setBrush(QtGui.QBrush(QtGui.QColor(*self.color)))
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.drawRoundedRect(top_rect, radius, radius)
+        for pos in [top_rect.left(), top_rect.right() - 5.0]:
+            painter.drawRect(
+                QtCore.QRectF(pos, top_rect.bottom() - 5.0, 5.0, 5.0))
+
+        if self.backdrop_text:
+            painter.setPen(QtGui.QColor(*self.text_color))
+            txt_rect = QtCore.QRectF(
+                top_rect.x() + 5.0, top_rect.height() + 3.0,
+                rect.width() - 5.0, rect.height())
+            painter.setPen(QtGui.QColor(*self.text_color))
+            painter.drawText(txt_rect,
+                             QtCore.Qt.AlignLeft | QtCore.Qt.TextWordWrap,
+                             self.backdrop_text)
+
+        if self.selected:
+            sel_color = [x for x in NodeEnum.SELECTED_COLOR.value]
+            sel_color[-1] = 15
+            painter.setBrush(QtGui.QColor(*sel_color))
+            painter.setPen(QtCore.Qt.NoPen)
+            painter.drawRoundedRect(rect, radius, radius)
+
+        txt_rect = QtCore.QRectF(top_rect.x(), top_rect.y(),
+                                 rect.width(), top_rect.height())
+        painter.setPen(QtGui.QColor(*self.text_color))
+        painter.drawText(txt_rect, QtCore.Qt.AlignCenter, self.name)
+
+        border = 0.8
+        border_color = self.color
+        if self.selected and NodeEnum.SELECTED_BORDER_COLOR.value:
+            border = 1.0
+            border_color = NodeEnum.SELECTED_BORDER_COLOR.value
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtGui.QPen(QtGui.QColor(*border_color), border))
+        painter.drawRoundedRect(rect, radius, radius)
+
+        painter.restore()
+
+    def get_nodes(self, inc_intersects=False):
+        mode = {True: QtCore.Qt.IntersectsItemShape,
+                False: QtCore.Qt.ContainsItemShape}
+        nodes = []
+        if self.scene():
+            polygon = self.mapToScene(self.boundingRect())
+            rect = polygon.boundingRect()
+            items = self.scene().items(rect, mode=mode[inc_intersects])
+            for item in items:
+                if item == self or item == self._sizer:
+                    continue
+                if isinstance(item, AbstractNodeItem):
+                    nodes.append(item)
+        return nodes
+
+    def calc_backdrop_size(self, nodes=None):
+        nodes = nodes or self.get_nodes(True)
+        if nodes:
+            nodes_rect = self._combined_rect(nodes)
+        else:
+            center = self.mapToScene(self.boundingRect().center())
+            nodes_rect = QtCore.QRectF(
+                center.x(), center.y(),
+                self._min_size[0], self._min_size[1]
+            )
+
+        padding = 40
+        return {
+            'pos': [
+                nodes_rect.x() - padding, nodes_rect.y() - padding
+            ],
+            'width': nodes_rect.width() + (padding * 2),
+            'height': nodes_rect.height() + (padding * 2)
+        }
+
+    @property
+    def minimum_size(self):
+        return self._min_size
+
+    @minimum_size.setter
+    def minimum_size(self, size=(50, 50)):
+        self._min_size = size
+
+    @property
+    def backdrop_text(self):
+        return self._properties['backdrop_text']
+
+    @backdrop_text.setter
+    def backdrop_text(self, text):
+        self._properties['backdrop_text'] = text
+        self.update(self.boundingRect())
+
+    @AbstractNodeItem.width.setter
+    def width(self, width=0.0):
+        AbstractNodeItem.width.fset(self, width)
+        self._sizer.set_pos(self._width, self._height)
+
+    @AbstractNodeItem.height.setter
+    def height(self, height=0.0):
+        AbstractNodeItem.height.fset(self, height)
+        self._sizer.set_pos(self._width, self._height)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_base.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_base.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,1037 +1,1037 @@
-#!/usr/bin/python
-from collections import OrderedDict
-
-from Qt import QtGui, QtCore, QtWidgets
-
-from NodeGraphQt.constants import (
-    ITEM_CACHE_MODE,
-    ICON_NODE_BASE,
-    LayoutDirectionEnum,
-    NodeEnum,
-    PortEnum,
-    PortTypeEnum,
-    Z_VAL_NODE
-)
-from NodeGraphQt.errors import NodeWidgetError
-from NodeGraphQt.qgraphics.node_abstract import AbstractNodeItem
-from NodeGraphQt.qgraphics.node_overlay_disabled import XDisabledItem
-from NodeGraphQt.qgraphics.node_text_item import NodeTextItem
-from NodeGraphQt.qgraphics.port import PortItem, CustomPortItem
-
-
-class NodeItem(AbstractNodeItem):
-    """
-    Base Node item.
-
-    Args:
-        name (str): name displayed on the node.
-        parent (QtWidgets.QGraphicsItem): parent item.
-    """
-
-    def __init__(self, name='node', parent=None):
-        super(NodeItem, self).__init__(name, parent)
-        pixmap = QtGui.QPixmap(ICON_NODE_BASE)
-        if pixmap.size().height() > NodeEnum.ICON_SIZE.value:
-            pixmap = pixmap.scaledToHeight(
-                NodeEnum.ICON_SIZE.value,
-                QtCore.Qt.SmoothTransformation
-            )
-        self._properties['icon'] = ICON_NODE_BASE
-        self._icon_item = QtWidgets.QGraphicsPixmapItem(pixmap, self)
-        self._icon_item.setTransformationMode(QtCore.Qt.SmoothTransformation)
-        self._text_item = NodeTextItem(self.name, self)
-        self._x_item = XDisabledItem(self, 'DISABLED')
-        self._input_items = OrderedDict()
-        self._output_items = OrderedDict()
-        self._widgets = OrderedDict()
-        self._proxy_mode = False
-        self._proxy_mode_threshold = 70
-
-    def post_init(self, viewer, pos=None):
-        """
-        Called after node has been added into the scene.
-
-        Args:
-            viewer (NodeGraphQt.widgets.viewer.NodeViewer): main viewer
-            pos (tuple): the cursor pos if node is called with tab search.
-        """
-        if self.layout_direction == LayoutDirectionEnum.VERTICAL.value:
-            font = QtGui.QFont()
-            font.setPointSize(15)
-            self.text_item.setFont(font)
-
-            # hide port text items for vertical layout.
-            if self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-                for text_item in self._input_items.values():
-                    text_item.setVisible(False)
-                for text_item in self._output_items.values():
-                    text_item.setVisible(False)
-
-    def _paint_horizontal(self, painter, option, widget):
-        painter.save()
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.setBrush(QtCore.Qt.NoBrush)
-
-        # base background.
-        margin = 1.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        radius = 4.0
-        painter.setBrush(QtGui.QColor(*self.color))
-        painter.drawRoundedRect(rect, radius, radius)
-
-        # light overlay on background when selected.
-        if self.selected:
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-            painter.drawRoundedRect(rect, radius, radius)
-
-        # node name background.
-        padding = 3.0, 2.0
-        text_rect = self._text_item.boundingRect()
-        text_rect = QtCore.QRectF(text_rect.x() + padding[0],
-                                  rect.y() + padding[1],
-                                  rect.width() - padding[0] - margin,
-                                  text_rect.height() - (padding[1] * 2))
-        if self.selected:
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
-        painter.drawRoundedRect(text_rect, 3.0, 3.0)
-
-        # node border
-        if self.selected:
-            border_width = 1.2
-            border_color = QtGui.QColor(
-                *NodeEnum.SELECTED_BORDER_COLOR.value
-            )
-        else:
-            border_width = 0.8
-            border_color = QtGui.QColor(*self.border_color)
-
-        border_rect = QtCore.QRectF(rect.left(), rect.top(),
-                                    rect.width(), rect.height())
-
-        pen = QtGui.QPen(border_color, border_width)
-        pen.setCosmetic(self.viewer().get_zoom() < 0.0)
-        path = QtGui.QPainterPath()
-        path.addRoundedRect(border_rect, radius, radius)
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(pen)
-        painter.drawPath(path)
-
-        painter.restore()
-
-    def _paint_vertical(self, painter, option, widget):
-        painter.save()
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.setBrush(QtCore.Qt.NoBrush)
-
-        # base background.
-        margin = 1.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        radius = 4.0
-        painter.setBrush(QtGui.QColor(*self.color))
-        painter.drawRoundedRect(rect, radius, radius)
-
-        # light overlay on background when selected.
-        if self.selected:
-            painter.setBrush(
-                QtGui.QColor(*NodeEnum.SELECTED_COLOR.value)
-            )
-            painter.drawRoundedRect(rect, radius, radius)
-
-        # top & bottom edge background.
-        padding = 2.0
-        height = 10
-        if self.selected:
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
-        for y in [rect.y() + padding, rect.height() - height - 1]:
-            edge_rect = QtCore.QRectF(rect.x() + padding, y,
-                                     rect.width() - (padding * 2), height)
-            painter.drawRoundedRect(edge_rect, 3.0, 3.0)
-
-        # node border
-        border_width = 0.8
-        border_color = QtGui.QColor(*self.border_color)
-        if self.selected:
-            border_width = 1.2
-            border_color = QtGui.QColor(
-                *NodeEnum.SELECTED_BORDER_COLOR.value
-            )
-        border_rect = QtCore.QRectF(rect.left(), rect.top(),
-                                    rect.width(), rect.height())
-
-        pen = QtGui.QPen(border_color, border_width)
-        pen.setCosmetic(self.viewer().get_zoom() < 0.0)
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(pen)
-        painter.drawRoundedRect(border_rect, radius, radius)
-
-        painter.restore()
-
-    def paint(self, painter, option, widget):
-        """
-        Draws the node base not the ports.
-
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        self.auto_switch_mode()
-        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-            self._paint_horizontal(painter, option, widget)
-        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            self._paint_vertical(painter, option, widget)
-        else:
-            raise RuntimeError('Node graph layout direction not valid!')
-
-    def mousePressEvent(self, event):
-        """
-        Re-implemented to ignore event if LMB is over port collision area.
-
-        Args:
-            event (QtWidgets.QGraphicsSceneMouseEvent): mouse event.
-        """
-        if event.button() == QtCore.Qt.LeftButton:
-            for p in self._input_items.keys():
-                if p.hovered:
-                    event.ignore()
-                    return
-            for p in self._output_items.keys():
-                if p.hovered:
-                    event.ignore()
-                    return
-        super(NodeItem, self).mousePressEvent(event)
-
-    def mouseReleaseEvent(self, event):
-        """
-        Re-implemented to ignore event if Alt modifier is pressed.
-
-        Args:
-            event (QtWidgets.QGraphicsSceneMouseEvent): mouse event.
-        """
-        if event.modifiers() == QtCore.Qt.AltModifier:
-            event.ignore()
-            return
-        super(NodeItem, self).mouseReleaseEvent(event)
-
-    def mouseDoubleClickEvent(self, event):
-        """
-        Re-implemented to emit "node_double_clicked" signal.
-
-        Args:
-            event (QtWidgets.QGraphicsSceneMouseEvent): mouse event.
-        """
-        if event.button() == QtCore.Qt.LeftButton:
-            if not self.disabled:
-                # enable text item edit mode.
-                items = self.scene().items(event.scenePos())
-                if self._text_item in items:
-                    self._text_item.set_editable(True)
-                    self._text_item.setFocus()
-                    event.ignore()
-                    return
-
-            viewer = self.viewer()
-            if viewer:
-                viewer.node_double_clicked.emit(self.id)
-        super(NodeItem, self).mouseDoubleClickEvent(event)
-
-    def itemChange(self, change, value):
-        """
-        Re-implemented to update pipes on selection changed.
-
-        Args:
-            change:
-            value:
-        """
-        if change == self.ItemSelectedChange and self.scene():
-            self.reset_pipes()
-            if value:
-                self.highlight_pipes()
-            self.setZValue(Z_VAL_NODE)
-            if not self.selected:
-                self.setZValue(Z_VAL_NODE + 1)
-
-        return super(NodeItem, self).itemChange(change, value)
-
-    def _tooltip_disable(self, state):
-        """
-        Updates the node tooltip when the node is enabled/disabled.
-
-        Args:
-            state (bool): node disable state.
-        """
-        tooltip = '<b>{}</b>'.format(self.name)
-        if state:
-            tooltip += ' <font color="red"><b>(DISABLED)</b></font>'
-        tooltip += '<br/>{}<br/>'.format(self.type_)
-        self.setToolTip(tooltip)
-
-    def _set_base_size(self, add_w=0.0, add_h=0.0):
-        """
-        Sets the initial base size for the node.
-
-        Args:
-            add_w (float): add additional width.
-            add_h (float): add additional height.
-        """
-        self._width, self._height = self.calc_size(add_w, add_h)
-        if self._width < NodeEnum.WIDTH.value:
-            self._width = NodeEnum.WIDTH.value
-        if self._height < NodeEnum.HEIGHT.value:
-            self._height = NodeEnum.HEIGHT.value
-
-    def _set_text_color(self, color):
-        """
-        set text color.
-
-        Args:
-            color (tuple): color value in (r, g, b, a).
-        """
-        text_color = QtGui.QColor(*color)
-        for port, text in self._input_items.items():
-            text.setDefaultTextColor(text_color)
-        for port, text in self._output_items.items():
-            text.setDefaultTextColor(text_color)
-        self._text_item.setDefaultTextColor(text_color)
-
-    def activate_pipes(self):
-        """
-        active pipe color.
-        """
-        ports = self.inputs + self.outputs
-        for port in ports:
-            for pipe in port.connected_pipes:
-                pipe.activate()
-
-    def highlight_pipes(self):
-        """
-        Highlight pipe color.
-        """
-        ports = self.inputs + self.outputs
-        for port in ports:
-            for pipe in port.connected_pipes:
-                pipe.highlight()
-
-    def reset_pipes(self):
-        """
-        Reset all the pipe colors.
-        """
-        ports = self.inputs + self.outputs
-        for port in ports:
-            for pipe in port.connected_pipes:
-                pipe.reset()
-
-    def _calc_size_horizontal(self):
-        # width, height from node name text.
-        text_w = self._text_item.boundingRect().width()
-        text_h = self._text_item.boundingRect().height()
-
-        # width, height from node ports.
-        port_width = 0.0
-        p_input_text_width = 0.0
-        p_output_text_width = 0.0
-        p_input_height = 0.0
-        p_output_height = 0.0
-        for port, text in self._input_items.items():
-            if not port.isVisible():
-                continue
-            if not port_width:
-                port_width = port.boundingRect().width()
-            t_width = text.boundingRect().width()
-            if text.isVisible() and t_width > p_input_text_width:
-                p_input_text_width = text.boundingRect().width()
-            p_input_height += port.boundingRect().height()
-        for port, text in self._output_items.items():
-            if not port.isVisible():
-                continue
-            if not port_width:
-                port_width = port.boundingRect().width()
-            t_width = text.boundingRect().width()
-            if text.isVisible() and t_width > p_output_text_width:
-                p_output_text_width = text.boundingRect().width()
-            p_output_height += port.boundingRect().height()
-
-        port_text_width = p_input_text_width + p_output_text_width
-
-        # width, height from node embedded widgets.
-        widget_width = 0.0
-        widget_height = 0.0
-        for widget in self._widgets.values():
-            w_width = widget.boundingRect().width()
-            w_height = widget.boundingRect().height()
-            if w_width > widget_width:
-                widget_width = w_width
-            widget_height += w_height
-
-        side_padding = 0.0
-        if all([widget_width, p_input_text_width, p_output_text_width]):
-            port_text_width = max([p_input_text_width, p_output_text_width])
-            port_text_width *= 2
-        elif widget_width:
-            side_padding = 10
-
-        width = port_width + max([text_w, port_text_width]) + side_padding
-        height = max([text_h, p_input_height, p_output_height, widget_height])
-        if widget_width:
-            # add additional width for node widget.
-            width += widget_width
-        if widget_height:
-            # add bottom margin for node widget.
-            height += 4.0
-        height *= 1.05
-        return width, height
-
-    def _calc_size_vertical(self):
-        p_input_width = 0.0
-        p_output_width = 0.0
-        p_input_height = 0.0
-        p_output_height = 0.0
-        for port in self._input_items.keys():
-            if port.isVisible():
-                p_input_width += port.boundingRect().width()
-                if not p_input_height:
-                    p_input_height = port.boundingRect().height()
-        for port in self._output_items.keys():
-            if port.isVisible():
-                p_output_width += port.boundingRect().width()
-                if not p_output_height:
-                    p_output_height = port.boundingRect().height()
-
-        widget_width = 0.0
-        widget_height = 0.0
-        for widget in self._widgets.values():
-            if widget.boundingRect().width() > widget_width:
-                widget_width = widget.boundingRect().width()
-            widget_height += widget.boundingRect().height()
-
-        width = max([p_input_width, p_output_width, widget_width])
-        height = p_input_height + p_output_height + widget_height
-        return width, height
-
-    def calc_size(self, add_w=0.0, add_h=0.0):
-        """
-        Calculates the minimum node size.
-
-        Args:
-            add_w (float): additional width.
-            add_h (float): additional height.
-
-        Returns:
-            tuple(float, float): width, height.
-        """
-        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-            width, height = self._calc_size_horizontal()
-        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            width, height = self._calc_size_vertical()
-        else:
-            raise RuntimeError('Node graph layout direction not valid!')
-
-        # additional width, height.
-        width += add_w
-        height += add_h
-        return width, height
-
-    def _align_icon_horizontal(self, h_offset, v_offset):
-        icon_rect = self._icon_item.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = self.boundingRect().left() + 2.0
-        y = text_rect.center().y() - (icon_rect.height() / 2)
-        self._icon_item.setPos(x + h_offset, y + v_offset)
-
-    def _align_icon_vertical(self, h_offset, v_offset):
-        center_y = self.boundingRect().center().y()
-        icon_rect = self._icon_item.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = self.boundingRect().right() + h_offset
-        y = center_y - text_rect.height() - (icon_rect.height() / 2) + v_offset
-        self._icon_item.setPos(x, y)
-
-    def align_icon(self, h_offset=0.0, v_offset=0.0):
-        """
-        Align node icon to the default top left of the node.
-
-        Args:
-            v_offset (float): additional vertical offset.
-            h_offset (float): additional horizontal offset.
-        """
-        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-            self._align_icon_horizontal(h_offset, v_offset)
-        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            self._align_icon_vertical(h_offset, v_offset)
-        else:
-            raise RuntimeError('Node graph layout direction not valid!')
-
-    def _align_label_horizontal(self, h_offset, v_offset):
-        rect = self.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = rect.center().x() - (text_rect.width() / 2)
-        self._text_item.setPos(x + h_offset, rect.y() + v_offset)
-
-    def _align_label_vertical(self, h_offset, v_offset):
-        rect = self._text_item.boundingRect()
-        x = self.boundingRect().right() + h_offset
-        y = self.boundingRect().center().y() - (rect.height() / 2) + v_offset
-        self.text_item.setPos(x, y)
-
-    def align_label(self, h_offset=0.0, v_offset=0.0):
-        """
-        Center node label text to the top of the node.
-
-        Args:
-            v_offset (float): vertical offset.
-            h_offset (float): horizontal offset.
-        """
-        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-            self._align_label_horizontal(h_offset, v_offset)
-        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            self._align_label_vertical(h_offset, v_offset)
-        else:
-            raise RuntimeError('Node graph layout direction not valid!')
-
-    def _align_widgets_horizontal(self, v_offset):
-        if not self._widgets:
-            return
-        rect = self.boundingRect()
-        y = rect.y() + v_offset
-        inputs = [p for p in self.inputs if p.isVisible()]
-        outputs = [p for p in self.outputs if p.isVisible()]
-        for widget in self._widgets.values():
-            widget_rect = widget.boundingRect()
-            if not inputs:
-                x = rect.left() + 10
-                widget.widget().setTitleAlign('left')
-            elif not outputs:
-                x = rect.right() - widget_rect.width() - 10
-                widget.widget().setTitleAlign('right')
-            else:
-                x = rect.center().x() - (widget_rect.width() / 2)
-                widget.widget().setTitleAlign('center')
-            widget.setPos(x, y)
-            y += widget_rect.height()
-
-    def _align_widgets_vertical(self, v_offset):
-        if not self._widgets:
-            return
-        rect = self.boundingRect()
-        y = rect.center().y() + v_offset
-        widget_height = 0.0
-        for widget in self._widgets.values():
-            widget_rect = widget.boundingRect()
-            widget_height += widget_rect.height()
-        y -= widget_height / 2
-
-        for widget in self._widgets.values():
-            widget_rect = widget.boundingRect()
-            x = rect.center().x() - (widget_rect.width() / 2)
-            widget.widget().setTitleAlign('center')
-            widget.setPos(x, y)
-            y += widget_rect.height()
-
-    def align_widgets(self, v_offset=0.0):
-        """
-        Align node widgets to the default center of the node.
-
-        Args:
-            v_offset (float): vertical offset.
-        """
-        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-            self._align_widgets_horizontal(v_offset)
-        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            self._align_widgets_vertical(v_offset)
-        else:
-            raise RuntimeError('Node graph layout direction not valid!')
-
-    def _align_ports_horizontal(self, v_offset):
-        width = self._width
-        txt_offset = PortEnum.CLICK_FALLOFF.value - 2
-        spacing = 1
-
-        # adjust input position
-        inputs = [p for p in self.inputs if p.isVisible()]
-        if inputs:
-            port_width = inputs[0].boundingRect().width()
-            port_height = inputs[0].boundingRect().height()
-            port_x = (port_width / 2) * -1
-            port_y = v_offset
-            for port in inputs:
-                port.setPos(port_x, port_y)
-                port_y += port_height + spacing
-        # adjust input text position
-        for port, text in self._input_items.items():
-            if port.isVisible():
-                txt_x = port.boundingRect().width() / 2 - txt_offset
-                text.setPos(txt_x, port.y() - 1.5)
-
-        # adjust output position
-        outputs = [p for p in self.outputs if p.isVisible()]
-        if outputs:
-            port_width = outputs[0].boundingRect().width()
-            port_height = outputs[0].boundingRect().height()
-            port_x = width - (port_width / 2)
-            port_y = v_offset
-            for port in outputs:
-                port.setPos(port_x, port_y)
-                port_y += port_height + spacing
-        # adjust output text position
-        for port, text in self._output_items.items():
-            if port.isVisible():
-                txt_width = text.boundingRect().width() - txt_offset
-                txt_x = port.x() - txt_width
-                text.setPos(txt_x, port.y() - 1.5)
-
-    def _align_ports_vertical(self, v_offset):
-        # adjust input position
-        inputs = [p for p in self.inputs if p.isVisible()]
-        if inputs:
-            port_width = inputs[0].boundingRect().width()
-            port_height = inputs[0].boundingRect().height()
-            half_width = port_width / 2
-            delta = self._width / (len(inputs) + 1)
-            port_x = delta
-            port_y = (port_height / 2) * -1
-            for port in inputs:
-                port.setPos(port_x - half_width, port_y)
-                port_x += delta
-
-        # adjust output position
-        outputs = [p for p in self.outputs if p.isVisible()]
-        if outputs:
-            port_width = outputs[0].boundingRect().width()
-            port_height = outputs[0].boundingRect().height()
-            half_width = port_width / 2
-            delta = self._width / (len(outputs) + 1)
-            port_x = delta
-            port_y = self._height - (port_height / 2)
-            for port in outputs:
-                port.setPos(port_x - half_width, port_y)
-                port_x += delta
-
-    def align_ports(self, v_offset=0.0):
-        """
-        Align input, output ports in the node layout.
-
-        Args:
-            v_offset (float): port vertical offset.
-        """
-        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-            self._align_ports_horizontal(v_offset)
-        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            self._align_ports_vertical(v_offset)
-        else:
-            raise RuntimeError('Node graph layout direction not valid!')
-
-    def _draw_node_horizontal(self):
-        height = self._text_item.boundingRect().height() + 4.0
-
-        # update port text items in visibility.
-        for port, text in self._input_items.items():
-            if port.isVisible():
-                text.setVisible(port.display_name)
-        for port, text in self._output_items.items():
-            if port.isVisible():
-                text.setVisible(port.display_name)
-
-        # setup initial base size.
-        self._set_base_size(add_h=height)
-        # set text color when node is initialized.
-        self._set_text_color(self.text_color)
-        # set the tooltip
-        self._tooltip_disable(self.disabled)
-
-        # --- set the initial node layout ---
-        # (do all the graphic item layout offsets here)
-
-        # align label text
-        self.align_label()
-        # align icon
-        self.align_icon(h_offset=2.0, v_offset=1.0)
-        # arrange input and output ports.
-        self.align_ports(v_offset=height)
-        # arrange node widgets
-        self.align_widgets(v_offset=height)
-
-        self.update()
-
-    def _draw_node_vertical(self):
-        # hide the port text items in vertical layout.
-        for port, text in self._input_items.items():
-            text.setVisible(False)
-        for port, text in self._output_items.items():
-            text.setVisible(False)
-
-        # setup initial base size.
-        self._set_base_size()
-        # set text color when node is initialized.
-        self._set_text_color(self.text_color)
-        # set the tooltip
-        self._tooltip_disable(self.disabled)
-
-        # --- setup node layout ---
-        # (do all the graphic item layout offsets here)
-
-        # align label text
-        self.align_label(h_offset=6)
-        # align icon
-        self.align_icon(h_offset=6, v_offset=4)
-        # arrange input and output ports.
-        self.align_ports()
-        # arrange node widgets
-        self.align_widgets()
-
-        self.update()
-
-    def draw_node(self):
-        """
-        Re-draw the node item in the scene with proper
-        calculated size and widgets aligned.
-        """
-        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
-            self._draw_node_horizontal()
-        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            self._draw_node_vertical()
-        else:
-            raise RuntimeError('Node graph layout direction not valid!')
-
-    def post_init(self, viewer=None, pos=None):
-        """
-        Called after node has been added into the scene.
-        Adjust the node layout and form after the node has been added.
-
-        Args:
-            viewer (NodeGraphQt.widgets.viewer.NodeViewer): not used
-            pos (tuple): cursor position.
-        """
-        self.draw_node()
-
-        # set initial node position.
-        if pos:
-            self.xy_pos = pos
-
-    def auto_switch_mode(self):
-        """
-        Decide whether to draw the node with proxy mode.
-        (this is called at the start in the "self.paint()" function.)
-        """
-        if ITEM_CACHE_MODE is QtWidgets.QGraphicsItem.ItemCoordinateCache:
-            return
-
-        rect = self.sceneBoundingRect()
-        l = self.viewer().mapToGlobal(
-            self.viewer().mapFromScene(rect.topLeft()))
-        r = self.viewer().mapToGlobal(
-            self.viewer().mapFromScene(rect.topRight()))
-        # width is the node width in screen
-        width = r.x() - l.x()
-
-        self.set_proxy_mode(width < self._proxy_mode_threshold)
-
-    def set_proxy_mode(self, mode):
-        """
-        Set whether to draw the node with proxy mode.
-        (proxy mode toggles visibility for some qgraphic items in the node.)
-
-        Args:
-            mode (bool): true to enable proxy mode.
-        """
-        if mode is self._proxy_mode:
-            return
-        self._proxy_mode = mode
-
-        visible = not mode
-
-        # disable overlay item.
-        self._x_item.proxy_mode = self._proxy_mode
-
-        # node widget visibility.
-        for w in self._widgets.values():
-            w.widget().setVisible(visible)
-
-        # port text is not visible in vertical layout.
-        if self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
-            port_text_visible = False
-        else:
-            port_text_visible = visible
-
-        # input port text visibility.
-        for port, text in self._input_items.items():
-            if port.display_name:
-                text.setVisible(port_text_visible)
-
-        # output port text visibility.
-        for port, text in self._output_items.items():
-            if port.display_name:
-                text.setVisible(port_text_visible)
-
-
-
-        self._text_item.setVisible(visible)
-        self._icon_item.setVisible(visible)
-
-    @property
-    def icon(self):
-        return self._properties['icon']
-
-    @icon.setter
-    def icon(self, path=None):
-        self._properties['icon'] = path
-        path = path or ICON_NODE_BASE
-        pixmap = QtGui.QPixmap(path)
-        if pixmap.size().height() > NodeEnum.ICON_SIZE.value:
-            pixmap = pixmap.scaledToHeight(
-                NodeEnum.ICON_SIZE.value,
-                QtCore.Qt.SmoothTransformation
-            )
-        self._icon_item.setPixmap(pixmap)
-        if self.scene():
-            self.post_init()
-
-        self.update()
-
-    @AbstractNodeItem.layout_direction.setter
-    def layout_direction(self, value=0):
-        AbstractNodeItem.layout_direction.fset(self, value)
-        self.draw_node()
-
-    @AbstractNodeItem.width.setter
-    def width(self, width=0.0):
-        w, h = self.calc_size()
-        width = width if width > w else w
-        AbstractNodeItem.width.fset(self, width)
-
-    @AbstractNodeItem.height.setter
-    def height(self, height=0.0):
-        w, h = self.calc_size()
-        h = 70 if h < 70 else h
-        height = height if height > h else h
-        AbstractNodeItem.height.fset(self, height)
-
-    @AbstractNodeItem.disabled.setter
-    def disabled(self, state=False):
-        AbstractNodeItem.disabled.fset(self, state)
-        for n, w in self._widgets.items():
-            w.widget().setDisabled(state)
-        self._tooltip_disable(state)
-        self._x_item.setVisible(state)
-
-    @AbstractNodeItem.selected.setter
-    def selected(self, selected=False):
-        AbstractNodeItem.selected.fset(self, selected)
-        if selected:
-            self.highlight_pipes()
-
-    @AbstractNodeItem.name.setter
-    def name(self, name=''):
-        AbstractNodeItem.name.fset(self, name)
-        if name == self._text_item.toPlainText():
-            return
-        self._text_item.setPlainText(name)
-        if self.scene():
-            self.align_label()
-        self.update()
-
-    @AbstractNodeItem.color.setter
-    def color(self, color=(100, 100, 100, 255)):
-        AbstractNodeItem.color.fset(self, color)
-        if self.scene():
-            self.scene().update()
-        self.update()
-
-    @AbstractNodeItem.text_color.setter
-    def text_color(self, color=(100, 100, 100, 255)):
-        AbstractNodeItem.text_color.fset(self, color)
-        self._set_text_color(color)
-        self.update()
-
-    @property
-    def text_item(self):
-        """
-        Get the node name text qgraphics item.
-
-        Returns:
-            NodeTextItem: node text object.
-        """
-        return self._text_item
-
-    @property
-    def inputs(self):
-        """
-        Returns:
-            list[PortItem]: input port graphic items.
-        """
-        return list(self._input_items.keys())
-
-    @property
-    def outputs(self):
-        """
-        Returns:
-            list[PortItem]: output port graphic items.
-        """
-        return list(self._output_items.keys())
-
-    def _add_port(self, port):
-        """
-        Adds a port qgraphics item into the node.
-
-        Args:
-            port (PortItem): port item.
-
-        Returns:
-            PortItem: port qgraphics item.
-        """
-        text = QtWidgets.QGraphicsTextItem(port.name, self)
-        text.font().setPointSize(8)
-        text.setFont(text.font())
-        text.setVisible(port.display_name)
-        text.setCacheMode(ITEM_CACHE_MODE)
-        if port.port_type == PortTypeEnum.IN.value:
-            self._input_items[port] = text
-        elif port.port_type == PortTypeEnum.OUT.value:
-            self._output_items[port] = text
-        if self.scene():
-            self.post_init()
-        return port
-
-    def add_input(self, name='input', multi_port=False, display_name=True,
-                  locked=False, painter_func=None):
-        """
-        Adds a port qgraphics item into the node with the "port_type" set as
-        IN_PORT.
-
-        Args:
-            name (str): name for the port.
-            multi_port (bool): allow multiple connections.
-            display_name (bool): display the port name.
-            locked (bool): locked state.
-            painter_func (function): custom paint function.
-
-        Returns:
-            PortItem: input port qgraphics item.
-        """
-        if painter_func:
-            port = CustomPortItem(self, painter_func)
-        else:
-            port = PortItem(self)
-        port.name = name
-        port.port_type = PortTypeEnum.IN.value
-        port.multi_connection = multi_port
-        port.display_name = display_name
-        port.locked = locked
-        return self._add_port(port)
-
-    def add_output(self, name='output', multi_port=False, display_name=True,
-                   locked=False, painter_func=None):
-        """
-        Adds a port qgraphics item into the node with the "port_type" set as
-        OUT_PORT.
-
-        Args:
-            name (str): name for the port.
-            multi_port (bool): allow multiple connections.
-            display_name (bool): display the port name.
-            locked (bool): locked state.
-            painter_func (function): custom paint function.
-
-        Returns:
-            PortItem: output port qgraphics item.
-        """
-        if painter_func:
-            port = CustomPortItem(self, painter_func)
-        else:
-            port = PortItem(self)
-        port.name = name
-        port.port_type = PortTypeEnum.OUT.value
-        port.multi_connection = multi_port
-        port.display_name = display_name
-        port.locked = locked
-        return self._add_port(port)
-
-    def _delete_port(self, port, text):
-        """
-        Removes port item and port text from node.
-
-        Args:
-            port (PortItem): port object.
-            text (QtWidgets.QGraphicsTextItem): port text object.
-        """
-        port.setParentItem(None)
-        text.setParentItem(None)
-        self.scene().removeItem(port)
-        self.scene().removeItem(text)
-        del port
-        del text
-
-    def delete_input(self, port):
-        """
-        Remove input port from node.
-
-        Args:
-            port (PortItem): port object.
-        """
-        self._delete_port(port, self._input_items.pop(port))
-
-    def delete_output(self, port):
-        """
-        Remove output port from node.
-
-        Args:
-            port (PortItem): port object.
-        """
-        self._delete_port(port, self._output_items.pop(port))
-
-    def get_input_text_item(self, port_item):
-        """
-        Args:
-            port_item (PortItem): port item.
-
-        Returns:
-            QGraphicsTextItem: graphic item used for the port text.
-        """
-        return self._input_items[port_item]
-
-    def get_output_text_item(self, port_item):
-        """
-        Args:
-            port_item (PortItem): port item.
-
-        Returns:
-            QGraphicsTextItem: graphic item used for the port text.
-        """
-        return self._output_items[port_item]
-
-    @property
-    def widgets(self):
-        return self._widgets.copy()
-
-    def add_widget(self, widget):
-        self._widgets[widget.get_name()] = widget
-
-    def get_widget(self, name):
-        widget = self._widgets.get(name)
-        if widget:
-            return widget
-        raise NodeWidgetError('node has no widget "{}"'.format(name))
-
-    def has_widget(self, name):
-        return name in self._widgets.keys()
-
-    def from_dict(self, node_dict):
-        super(NodeItem, self).from_dict(node_dict)
-        widgets = node_dict.pop('widgets', {})
-        for name, value in widgets.items():
-            if self._widgets.get(name):
-                self._widgets[name].set_value(value)
+#!/usr/bin/python
+from collections import OrderedDict
+
+from Qt import QtGui, QtCore, QtWidgets
+
+from NodeGraphQt.constants import (
+    ITEM_CACHE_MODE,
+    ICON_NODE_BASE,
+    LayoutDirectionEnum,
+    NodeEnum,
+    PortEnum,
+    PortTypeEnum,
+    Z_VAL_NODE
+)
+from NodeGraphQt.errors import NodeWidgetError
+from NodeGraphQt.qgraphics.node_abstract import AbstractNodeItem
+from NodeGraphQt.qgraphics.node_overlay_disabled import XDisabledItem
+from NodeGraphQt.qgraphics.node_text_item import NodeTextItem
+from NodeGraphQt.qgraphics.port import PortItem, CustomPortItem
+
+
+class NodeItem(AbstractNodeItem):
+    """
+    Base Node item.
+
+    Args:
+        name (str): name displayed on the node.
+        parent (QtWidgets.QGraphicsItem): parent item.
+    """
+
+    def __init__(self, name='node', parent=None):
+        super(NodeItem, self).__init__(name, parent)
+        pixmap = QtGui.QPixmap(ICON_NODE_BASE)
+        if pixmap.size().height() > NodeEnum.ICON_SIZE.value:
+            pixmap = pixmap.scaledToHeight(
+                NodeEnum.ICON_SIZE.value,
+                QtCore.Qt.SmoothTransformation
+            )
+        self._properties['icon'] = ICON_NODE_BASE
+        self._icon_item = QtWidgets.QGraphicsPixmapItem(pixmap, self)
+        self._icon_item.setTransformationMode(QtCore.Qt.SmoothTransformation)
+        self._text_item = NodeTextItem(self.name, self)
+        self._x_item = XDisabledItem(self, 'DISABLED')
+        self._input_items = OrderedDict()
+        self._output_items = OrderedDict()
+        self._widgets = OrderedDict()
+        self._proxy_mode = False
+        self._proxy_mode_threshold = 70
+
+    def post_init(self, viewer, pos=None):
+        """
+        Called after node has been added into the scene.
+
+        Args:
+            viewer (NodeGraphQt.widgets.viewer.NodeViewer): main viewer
+            pos (tuple): the cursor pos if node is called with tab search.
+        """
+        if self.layout_direction == LayoutDirectionEnum.VERTICAL.value:
+            font = QtGui.QFont()
+            font.setPointSize(15)
+            self.text_item.setFont(font)
+
+            # hide port text items for vertical layout.
+            if self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+                for text_item in self._input_items.values():
+                    text_item.setVisible(False)
+                for text_item in self._output_items.values():
+                    text_item.setVisible(False)
+
+    def _paint_horizontal(self, painter, option, widget):
+        painter.save()
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.setBrush(QtCore.Qt.NoBrush)
+
+        # base background.
+        margin = 1.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        radius = 4.0
+        painter.setBrush(QtGui.QColor(*self.color))
+        painter.drawRoundedRect(rect, radius, radius)
+
+        # light overlay on background when selected.
+        if self.selected:
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+            painter.drawRoundedRect(rect, radius, radius)
+
+        # node name background.
+        padding = 3.0, 2.0
+        text_rect = self._text_item.boundingRect()
+        text_rect = QtCore.QRectF(text_rect.x() + padding[0],
+                                  rect.y() + padding[1],
+                                  rect.width() - padding[0] - margin,
+                                  text_rect.height() - (padding[1] * 2))
+        if self.selected:
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
+        painter.drawRoundedRect(text_rect, 3.0, 3.0)
+
+        # node border
+        if self.selected:
+            border_width = 1.2
+            border_color = QtGui.QColor(
+                *NodeEnum.SELECTED_BORDER_COLOR.value
+            )
+        else:
+            border_width = 0.8
+            border_color = QtGui.QColor(*self.border_color)
+
+        border_rect = QtCore.QRectF(rect.left(), rect.top(),
+                                    rect.width(), rect.height())
+
+        pen = QtGui.QPen(border_color, border_width)
+        pen.setCosmetic(self.viewer().get_zoom() < 0.0)
+        path = QtGui.QPainterPath()
+        path.addRoundedRect(border_rect, radius, radius)
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(pen)
+        painter.drawPath(path)
+
+        painter.restore()
+
+    def _paint_vertical(self, painter, option, widget):
+        painter.save()
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.setBrush(QtCore.Qt.NoBrush)
+
+        # base background.
+        margin = 1.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        radius = 4.0
+        painter.setBrush(QtGui.QColor(*self.color))
+        painter.drawRoundedRect(rect, radius, radius)
+
+        # light overlay on background when selected.
+        if self.selected:
+            painter.setBrush(
+                QtGui.QColor(*NodeEnum.SELECTED_COLOR.value)
+            )
+            painter.drawRoundedRect(rect, radius, radius)
+
+        # top & bottom edge background.
+        padding = 2.0
+        height = 10
+        if self.selected:
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
+        for y in [rect.y() + padding, rect.height() - height - 1]:
+            edge_rect = QtCore.QRectF(rect.x() + padding, y,
+                                     rect.width() - (padding * 2), height)
+            painter.drawRoundedRect(edge_rect, 3.0, 3.0)
+
+        # node border
+        border_width = 0.8
+        border_color = QtGui.QColor(*self.border_color)
+        if self.selected:
+            border_width = 1.2
+            border_color = QtGui.QColor(
+                *NodeEnum.SELECTED_BORDER_COLOR.value
+            )
+        border_rect = QtCore.QRectF(rect.left(), rect.top(),
+                                    rect.width(), rect.height())
+
+        pen = QtGui.QPen(border_color, border_width)
+        pen.setCosmetic(self.viewer().get_zoom() < 0.0)
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(pen)
+        painter.drawRoundedRect(border_rect, radius, radius)
+
+        painter.restore()
+
+    def paint(self, painter, option, widget):
+        """
+        Draws the node base not the ports.
+
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        self.auto_switch_mode()
+        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+            self._paint_horizontal(painter, option, widget)
+        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            self._paint_vertical(painter, option, widget)
+        else:
+            raise RuntimeError('Node graph layout direction not valid!')
+
+    def mousePressEvent(self, event):
+        """
+        Re-implemented to ignore event if LMB is over port collision area.
+
+        Args:
+            event (QtWidgets.QGraphicsSceneMouseEvent): mouse event.
+        """
+        if event.button() == QtCore.Qt.LeftButton:
+            for p in self._input_items.keys():
+                if p.hovered:
+                    event.ignore()
+                    return
+            for p in self._output_items.keys():
+                if p.hovered:
+                    event.ignore()
+                    return
+        super(NodeItem, self).mousePressEvent(event)
+
+    def mouseReleaseEvent(self, event):
+        """
+        Re-implemented to ignore event if Alt modifier is pressed.
+
+        Args:
+            event (QtWidgets.QGraphicsSceneMouseEvent): mouse event.
+        """
+        if event.modifiers() == QtCore.Qt.AltModifier:
+            event.ignore()
+            return
+        super(NodeItem, self).mouseReleaseEvent(event)
+
+    def mouseDoubleClickEvent(self, event):
+        """
+        Re-implemented to emit "node_double_clicked" signal.
+
+        Args:
+            event (QtWidgets.QGraphicsSceneMouseEvent): mouse event.
+        """
+        if event.button() == QtCore.Qt.LeftButton:
+            if not self.disabled:
+                # enable text item edit mode.
+                items = self.scene().items(event.scenePos())
+                if self._text_item in items:
+                    self._text_item.set_editable(True)
+                    self._text_item.setFocus()
+                    event.ignore()
+                    return
+
+            viewer = self.viewer()
+            if viewer:
+                viewer.node_double_clicked.emit(self.id)
+        super(NodeItem, self).mouseDoubleClickEvent(event)
+
+    def itemChange(self, change, value):
+        """
+        Re-implemented to update pipes on selection changed.
+
+        Args:
+            change:
+            value:
+        """
+        if change == self.ItemSelectedChange and self.scene():
+            self.reset_pipes()
+            if value:
+                self.highlight_pipes()
+            self.setZValue(Z_VAL_NODE)
+            if not self.selected:
+                self.setZValue(Z_VAL_NODE + 1)
+
+        return super(NodeItem, self).itemChange(change, value)
+
+    def _tooltip_disable(self, state):
+        """
+        Updates the node tooltip when the node is enabled/disabled.
+
+        Args:
+            state (bool): node disable state.
+        """
+        tooltip = '<b>{}</b>'.format(self.name)
+        if state:
+            tooltip += ' <font color="red"><b>(DISABLED)</b></font>'
+        tooltip += '<br/>{}<br/>'.format(self.type_)
+        self.setToolTip(tooltip)
+
+    def _set_base_size(self, add_w=0.0, add_h=0.0):
+        """
+        Sets the initial base size for the node.
+
+        Args:
+            add_w (float): add additional width.
+            add_h (float): add additional height.
+        """
+        self._width, self._height = self.calc_size(add_w, add_h)
+        if self._width < NodeEnum.WIDTH.value:
+            self._width = NodeEnum.WIDTH.value
+        if self._height < NodeEnum.HEIGHT.value:
+            self._height = NodeEnum.HEIGHT.value
+
+    def _set_text_color(self, color):
+        """
+        set text color.
+
+        Args:
+            color (tuple): color value in (r, g, b, a).
+        """
+        text_color = QtGui.QColor(*color)
+        for port, text in self._input_items.items():
+            text.setDefaultTextColor(text_color)
+        for port, text in self._output_items.items():
+            text.setDefaultTextColor(text_color)
+        self._text_item.setDefaultTextColor(text_color)
+
+    def activate_pipes(self):
+        """
+        active pipe color.
+        """
+        ports = self.inputs + self.outputs
+        for port in ports:
+            for pipe in port.connected_pipes:
+                pipe.activate()
+
+    def highlight_pipes(self):
+        """
+        Highlight pipe color.
+        """
+        ports = self.inputs + self.outputs
+        for port in ports:
+            for pipe in port.connected_pipes:
+                pipe.highlight()
+
+    def reset_pipes(self):
+        """
+        Reset all the pipe colors.
+        """
+        ports = self.inputs + self.outputs
+        for port in ports:
+            for pipe in port.connected_pipes:
+                pipe.reset()
+
+    def _calc_size_horizontal(self):
+        # width, height from node name text.
+        text_w = self._text_item.boundingRect().width()
+        text_h = self._text_item.boundingRect().height()
+
+        # width, height from node ports.
+        port_width = 0.0
+        p_input_text_width = 0.0
+        p_output_text_width = 0.0
+        p_input_height = 0.0
+        p_output_height = 0.0
+        for port, text in self._input_items.items():
+            if not port.isVisible():
+                continue
+            if not port_width:
+                port_width = port.boundingRect().width()
+            t_width = text.boundingRect().width()
+            if text.isVisible() and t_width > p_input_text_width:
+                p_input_text_width = text.boundingRect().width()
+            p_input_height += port.boundingRect().height()
+        for port, text in self._output_items.items():
+            if not port.isVisible():
+                continue
+            if not port_width:
+                port_width = port.boundingRect().width()
+            t_width = text.boundingRect().width()
+            if text.isVisible() and t_width > p_output_text_width:
+                p_output_text_width = text.boundingRect().width()
+            p_output_height += port.boundingRect().height()
+
+        port_text_width = p_input_text_width + p_output_text_width
+
+        # width, height from node embedded widgets.
+        widget_width = 0.0
+        widget_height = 0.0
+        for widget in self._widgets.values():
+            w_width = widget.boundingRect().width()
+            w_height = widget.boundingRect().height()
+            if w_width > widget_width:
+                widget_width = w_width
+            widget_height += w_height
+
+        side_padding = 0.0
+        if all([widget_width, p_input_text_width, p_output_text_width]):
+            port_text_width = max([p_input_text_width, p_output_text_width])
+            port_text_width *= 2
+        elif widget_width:
+            side_padding = 10
+
+        width = port_width + max([text_w, port_text_width]) + side_padding
+        height = max([text_h, p_input_height, p_output_height, widget_height])
+        if widget_width:
+            # add additional width for node widget.
+            width += widget_width
+        if widget_height:
+            # add bottom margin for node widget.
+            height += 4.0
+        height *= 1.05
+        return width, height
+
+    def _calc_size_vertical(self):
+        p_input_width = 0.0
+        p_output_width = 0.0
+        p_input_height = 0.0
+        p_output_height = 0.0
+        for port in self._input_items.keys():
+            if port.isVisible():
+                p_input_width += port.boundingRect().width()
+                if not p_input_height:
+                    p_input_height = port.boundingRect().height()
+        for port in self._output_items.keys():
+            if port.isVisible():
+                p_output_width += port.boundingRect().width()
+                if not p_output_height:
+                    p_output_height = port.boundingRect().height()
+
+        widget_width = 0.0
+        widget_height = 0.0
+        for widget in self._widgets.values():
+            if widget.boundingRect().width() > widget_width:
+                widget_width = widget.boundingRect().width()
+            widget_height += widget.boundingRect().height()
+
+        width = max([p_input_width, p_output_width, widget_width])
+        height = p_input_height + p_output_height + widget_height
+        return width, height
+
+    def calc_size(self, add_w=0.0, add_h=0.0):
+        """
+        Calculates the minimum node size.
+
+        Args:
+            add_w (float): additional width.
+            add_h (float): additional height.
+
+        Returns:
+            tuple(float, float): width, height.
+        """
+        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+            width, height = self._calc_size_horizontal()
+        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            width, height = self._calc_size_vertical()
+        else:
+            raise RuntimeError('Node graph layout direction not valid!')
+
+        # additional width, height.
+        width += add_w
+        height += add_h
+        return width, height
+
+    def _align_icon_horizontal(self, h_offset, v_offset):
+        icon_rect = self._icon_item.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = self.boundingRect().left() + 2.0
+        y = text_rect.center().y() - (icon_rect.height() / 2)
+        self._icon_item.setPos(x + h_offset, y + v_offset)
+
+    def _align_icon_vertical(self, h_offset, v_offset):
+        center_y = self.boundingRect().center().y()
+        icon_rect = self._icon_item.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = self.boundingRect().right() + h_offset
+        y = center_y - text_rect.height() - (icon_rect.height() / 2) + v_offset
+        self._icon_item.setPos(x, y)
+
+    def align_icon(self, h_offset=0.0, v_offset=0.0):
+        """
+        Align node icon to the default top left of the node.
+
+        Args:
+            v_offset (float): additional vertical offset.
+            h_offset (float): additional horizontal offset.
+        """
+        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+            self._align_icon_horizontal(h_offset, v_offset)
+        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            self._align_icon_vertical(h_offset, v_offset)
+        else:
+            raise RuntimeError('Node graph layout direction not valid!')
+
+    def _align_label_horizontal(self, h_offset, v_offset):
+        rect = self.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = rect.center().x() - (text_rect.width() / 2)
+        self._text_item.setPos(x + h_offset, rect.y() + v_offset)
+
+    def _align_label_vertical(self, h_offset, v_offset):
+        rect = self._text_item.boundingRect()
+        x = self.boundingRect().right() + h_offset
+        y = self.boundingRect().center().y() - (rect.height() / 2) + v_offset
+        self.text_item.setPos(x, y)
+
+    def align_label(self, h_offset=0.0, v_offset=0.0):
+        """
+        Center node label text to the top of the node.
+
+        Args:
+            v_offset (float): vertical offset.
+            h_offset (float): horizontal offset.
+        """
+        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+            self._align_label_horizontal(h_offset, v_offset)
+        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            self._align_label_vertical(h_offset, v_offset)
+        else:
+            raise RuntimeError('Node graph layout direction not valid!')
+
+    def _align_widgets_horizontal(self, v_offset):
+        if not self._widgets:
+            return
+        rect = self.boundingRect()
+        y = rect.y() + v_offset
+        inputs = [p for p in self.inputs if p.isVisible()]
+        outputs = [p for p in self.outputs if p.isVisible()]
+        for widget in self._widgets.values():
+            widget_rect = widget.boundingRect()
+            if not inputs:
+                x = rect.left() + 10
+                widget.widget().setTitleAlign('left')
+            elif not outputs:
+                x = rect.right() - widget_rect.width() - 10
+                widget.widget().setTitleAlign('right')
+            else:
+                x = rect.center().x() - (widget_rect.width() / 2)
+                widget.widget().setTitleAlign('center')
+            widget.setPos(x, y)
+            y += widget_rect.height()
+
+    def _align_widgets_vertical(self, v_offset):
+        if not self._widgets:
+            return
+        rect = self.boundingRect()
+        y = rect.center().y() + v_offset
+        widget_height = 0.0
+        for widget in self._widgets.values():
+            widget_rect = widget.boundingRect()
+            widget_height += widget_rect.height()
+        y -= widget_height / 2
+
+        for widget in self._widgets.values():
+            widget_rect = widget.boundingRect()
+            x = rect.center().x() - (widget_rect.width() / 2)
+            widget.widget().setTitleAlign('center')
+            widget.setPos(x, y)
+            y += widget_rect.height()
+
+    def align_widgets(self, v_offset=0.0):
+        """
+        Align node widgets to the default center of the node.
+
+        Args:
+            v_offset (float): vertical offset.
+        """
+        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+            self._align_widgets_horizontal(v_offset)
+        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            self._align_widgets_vertical(v_offset)
+        else:
+            raise RuntimeError('Node graph layout direction not valid!')
+
+    def _align_ports_horizontal(self, v_offset):
+        width = self._width
+        txt_offset = PortEnum.CLICK_FALLOFF.value - 2
+        spacing = 1
+
+        # adjust input position
+        inputs = [p for p in self.inputs if p.isVisible()]
+        if inputs:
+            port_width = inputs[0].boundingRect().width()
+            port_height = inputs[0].boundingRect().height()
+            port_x = (port_width / 2) * -1
+            port_y = v_offset
+            for port in inputs:
+                port.setPos(port_x, port_y)
+                port_y += port_height + spacing
+        # adjust input text position
+        for port, text in self._input_items.items():
+            if port.isVisible():
+                txt_x = port.boundingRect().width() / 2 - txt_offset
+                text.setPos(txt_x, port.y() - 1.5)
+
+        # adjust output position
+        outputs = [p for p in self.outputs if p.isVisible()]
+        if outputs:
+            port_width = outputs[0].boundingRect().width()
+            port_height = outputs[0].boundingRect().height()
+            port_x = width - (port_width / 2)
+            port_y = v_offset
+            for port in outputs:
+                port.setPos(port_x, port_y)
+                port_y += port_height + spacing
+        # adjust output text position
+        for port, text in self._output_items.items():
+            if port.isVisible():
+                txt_width = text.boundingRect().width() - txt_offset
+                txt_x = port.x() - txt_width
+                text.setPos(txt_x, port.y() - 1.5)
+
+    def _align_ports_vertical(self, v_offset):
+        # adjust input position
+        inputs = [p for p in self.inputs if p.isVisible()]
+        if inputs:
+            port_width = inputs[0].boundingRect().width()
+            port_height = inputs[0].boundingRect().height()
+            half_width = port_width / 2
+            delta = self._width / (len(inputs) + 1)
+            port_x = delta
+            port_y = (port_height / 2) * -1
+            for port in inputs:
+                port.setPos(port_x - half_width, port_y)
+                port_x += delta
+
+        # adjust output position
+        outputs = [p for p in self.outputs if p.isVisible()]
+        if outputs:
+            port_width = outputs[0].boundingRect().width()
+            port_height = outputs[0].boundingRect().height()
+            half_width = port_width / 2
+            delta = self._width / (len(outputs) + 1)
+            port_x = delta
+            port_y = self._height - (port_height / 2)
+            for port in outputs:
+                port.setPos(port_x - half_width, port_y)
+                port_x += delta
+
+    def align_ports(self, v_offset=0.0):
+        """
+        Align input, output ports in the node layout.
+
+        Args:
+            v_offset (float): port vertical offset.
+        """
+        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+            self._align_ports_horizontal(v_offset)
+        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            self._align_ports_vertical(v_offset)
+        else:
+            raise RuntimeError('Node graph layout direction not valid!')
+
+    def _draw_node_horizontal(self):
+        height = self._text_item.boundingRect().height() + 4.0
+
+        # update port text items in visibility.
+        for port, text in self._input_items.items():
+            if port.isVisible():
+                text.setVisible(port.display_name)
+        for port, text in self._output_items.items():
+            if port.isVisible():
+                text.setVisible(port.display_name)
+
+        # setup initial base size.
+        self._set_base_size(add_h=height)
+        # set text color when node is initialized.
+        self._set_text_color(self.text_color)
+        # set the tooltip
+        self._tooltip_disable(self.disabled)
+
+        # --- set the initial node layout ---
+        # (do all the graphic item layout offsets here)
+
+        # align label text
+        self.align_label()
+        # align icon
+        self.align_icon(h_offset=2.0, v_offset=1.0)
+        # arrange input and output ports.
+        self.align_ports(v_offset=height)
+        # arrange node widgets
+        self.align_widgets(v_offset=height)
+
+        self.update()
+
+    def _draw_node_vertical(self):
+        # hide the port text items in vertical layout.
+        for port, text in self._input_items.items():
+            text.setVisible(False)
+        for port, text in self._output_items.items():
+            text.setVisible(False)
+
+        # setup initial base size.
+        self._set_base_size()
+        # set text color when node is initialized.
+        self._set_text_color(self.text_color)
+        # set the tooltip
+        self._tooltip_disable(self.disabled)
+
+        # --- setup node layout ---
+        # (do all the graphic item layout offsets here)
+
+        # align label text
+        self.align_label(h_offset=6)
+        # align icon
+        self.align_icon(h_offset=6, v_offset=4)
+        # arrange input and output ports.
+        self.align_ports()
+        # arrange node widgets
+        self.align_widgets()
+
+        self.update()
+
+    def draw_node(self):
+        """
+        Re-draw the node item in the scene with proper
+        calculated size and widgets aligned.
+        """
+        if self.layout_direction is LayoutDirectionEnum.HORIZONTAL.value:
+            self._draw_node_horizontal()
+        elif self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            self._draw_node_vertical()
+        else:
+            raise RuntimeError('Node graph layout direction not valid!')
+
+    def post_init(self, viewer=None, pos=None):
+        """
+        Called after node has been added into the scene.
+        Adjust the node layout and form after the node has been added.
+
+        Args:
+            viewer (NodeGraphQt.widgets.viewer.NodeViewer): not used
+            pos (tuple): cursor position.
+        """
+        self.draw_node()
+
+        # set initial node position.
+        if pos:
+            self.xy_pos = pos
+
+    def auto_switch_mode(self):
+        """
+        Decide whether to draw the node with proxy mode.
+        (this is called at the start in the "self.paint()" function.)
+        """
+        if ITEM_CACHE_MODE is QtWidgets.QGraphicsItem.ItemCoordinateCache:
+            return
+
+        rect = self.sceneBoundingRect()
+        l = self.viewer().mapToGlobal(
+            self.viewer().mapFromScene(rect.topLeft()))
+        r = self.viewer().mapToGlobal(
+            self.viewer().mapFromScene(rect.topRight()))
+        # width is the node width in screen
+        width = r.x() - l.x()
+
+        self.set_proxy_mode(width < self._proxy_mode_threshold)
+
+    def set_proxy_mode(self, mode):
+        """
+        Set whether to draw the node with proxy mode.
+        (proxy mode toggles visibility for some qgraphic items in the node.)
+
+        Args:
+            mode (bool): true to enable proxy mode.
+        """
+        if mode is self._proxy_mode:
+            return
+        self._proxy_mode = mode
+
+        visible = not mode
+
+        # disable overlay item.
+        self._x_item.proxy_mode = self._proxy_mode
+
+        # node widget visibility.
+        for w in self._widgets.values():
+            w.widget().setVisible(visible)
+
+        # port text is not visible in vertical layout.
+        if self.layout_direction is LayoutDirectionEnum.VERTICAL.value:
+            port_text_visible = False
+        else:
+            port_text_visible = visible
+
+        # input port text visibility.
+        for port, text in self._input_items.items():
+            if port.display_name:
+                text.setVisible(port_text_visible)
+
+        # output port text visibility.
+        for port, text in self._output_items.items():
+            if port.display_name:
+                text.setVisible(port_text_visible)
+
+
+
+        self._text_item.setVisible(visible)
+        self._icon_item.setVisible(visible)
+
+    @property
+    def icon(self):
+        return self._properties['icon']
+
+    @icon.setter
+    def icon(self, path=None):
+        self._properties['icon'] = path
+        path = path or ICON_NODE_BASE
+        pixmap = QtGui.QPixmap(path)
+        if pixmap.size().height() > NodeEnum.ICON_SIZE.value:
+            pixmap = pixmap.scaledToHeight(
+                NodeEnum.ICON_SIZE.value,
+                QtCore.Qt.SmoothTransformation
+            )
+        self._icon_item.setPixmap(pixmap)
+        if self.scene():
+            self.post_init()
+
+        self.update()
+
+    @AbstractNodeItem.layout_direction.setter
+    def layout_direction(self, value=0):
+        AbstractNodeItem.layout_direction.fset(self, value)
+        self.draw_node()
+
+    @AbstractNodeItem.width.setter
+    def width(self, width=0.0):
+        w, h = self.calc_size()
+        width = width if width > w else w
+        AbstractNodeItem.width.fset(self, width)
+
+    @AbstractNodeItem.height.setter
+    def height(self, height=0.0):
+        w, h = self.calc_size()
+        h = 70 if h < 70 else h
+        height = height if height > h else h
+        AbstractNodeItem.height.fset(self, height)
+
+    @AbstractNodeItem.disabled.setter
+    def disabled(self, state=False):
+        AbstractNodeItem.disabled.fset(self, state)
+        for n, w in self._widgets.items():
+            w.widget().setDisabled(state)
+        self._tooltip_disable(state)
+        self._x_item.setVisible(state)
+
+    @AbstractNodeItem.selected.setter
+    def selected(self, selected=False):
+        AbstractNodeItem.selected.fset(self, selected)
+        if selected:
+            self.highlight_pipes()
+
+    @AbstractNodeItem.name.setter
+    def name(self, name=''):
+        AbstractNodeItem.name.fset(self, name)
+        if name == self._text_item.toPlainText():
+            return
+        self._text_item.setPlainText(name)
+        if self.scene():
+            self.align_label()
+        self.update()
+
+    @AbstractNodeItem.color.setter
+    def color(self, color=(100, 100, 100, 255)):
+        AbstractNodeItem.color.fset(self, color)
+        if self.scene():
+            self.scene().update()
+        self.update()
+
+    @AbstractNodeItem.text_color.setter
+    def text_color(self, color=(100, 100, 100, 255)):
+        AbstractNodeItem.text_color.fset(self, color)
+        self._set_text_color(color)
+        self.update()
+
+    @property
+    def text_item(self):
+        """
+        Get the node name text qgraphics item.
+
+        Returns:
+            NodeTextItem: node text object.
+        """
+        return self._text_item
+
+    @property
+    def inputs(self):
+        """
+        Returns:
+            list[PortItem]: input port graphic items.
+        """
+        return list(self._input_items.keys())
+
+    @property
+    def outputs(self):
+        """
+        Returns:
+            list[PortItem]: output port graphic items.
+        """
+        return list(self._output_items.keys())
+
+    def _add_port(self, port):
+        """
+        Adds a port qgraphics item into the node.
+
+        Args:
+            port (PortItem): port item.
+
+        Returns:
+            PortItem: port qgraphics item.
+        """
+        text = QtWidgets.QGraphicsTextItem(port.name, self)
+        text.font().setPointSize(8)
+        text.setFont(text.font())
+        text.setVisible(port.display_name)
+        text.setCacheMode(ITEM_CACHE_MODE)
+        if port.port_type == PortTypeEnum.IN.value:
+            self._input_items[port] = text
+        elif port.port_type == PortTypeEnum.OUT.value:
+            self._output_items[port] = text
+        if self.scene():
+            self.post_init()
+        return port
+
+    def add_input(self, name='input', multi_port=False, display_name=True,
+                  locked=False, painter_func=None):
+        """
+        Adds a port qgraphics item into the node with the "port_type" set as
+        IN_PORT.
+
+        Args:
+            name (str): name for the port.
+            multi_port (bool): allow multiple connections.
+            display_name (bool): display the port name.
+            locked (bool): locked state.
+            painter_func (function): custom paint function.
+
+        Returns:
+            PortItem: input port qgraphics item.
+        """
+        if painter_func:
+            port = CustomPortItem(self, painter_func)
+        else:
+            port = PortItem(self)
+        port.name = name
+        port.port_type = PortTypeEnum.IN.value
+        port.multi_connection = multi_port
+        port.display_name = display_name
+        port.locked = locked
+        return self._add_port(port)
+
+    def add_output(self, name='output', multi_port=False, display_name=True,
+                   locked=False, painter_func=None):
+        """
+        Adds a port qgraphics item into the node with the "port_type" set as
+        OUT_PORT.
+
+        Args:
+            name (str): name for the port.
+            multi_port (bool): allow multiple connections.
+            display_name (bool): display the port name.
+            locked (bool): locked state.
+            painter_func (function): custom paint function.
+
+        Returns:
+            PortItem: output port qgraphics item.
+        """
+        if painter_func:
+            port = CustomPortItem(self, painter_func)
+        else:
+            port = PortItem(self)
+        port.name = name
+        port.port_type = PortTypeEnum.OUT.value
+        port.multi_connection = multi_port
+        port.display_name = display_name
+        port.locked = locked
+        return self._add_port(port)
+
+    def _delete_port(self, port, text):
+        """
+        Removes port item and port text from node.
+
+        Args:
+            port (PortItem): port object.
+            text (QtWidgets.QGraphicsTextItem): port text object.
+        """
+        port.setParentItem(None)
+        text.setParentItem(None)
+        self.scene().removeItem(port)
+        self.scene().removeItem(text)
+        del port
+        del text
+
+    def delete_input(self, port):
+        """
+        Remove input port from node.
+
+        Args:
+            port (PortItem): port object.
+        """
+        self._delete_port(port, self._input_items.pop(port))
+
+    def delete_output(self, port):
+        """
+        Remove output port from node.
+
+        Args:
+            port (PortItem): port object.
+        """
+        self._delete_port(port, self._output_items.pop(port))
+
+    def get_input_text_item(self, port_item):
+        """
+        Args:
+            port_item (PortItem): port item.
+
+        Returns:
+            QGraphicsTextItem: graphic item used for the port text.
+        """
+        return self._input_items[port_item]
+
+    def get_output_text_item(self, port_item):
+        """
+        Args:
+            port_item (PortItem): port item.
+
+        Returns:
+            QGraphicsTextItem: graphic item used for the port text.
+        """
+        return self._output_items[port_item]
+
+    @property
+    def widgets(self):
+        return self._widgets.copy()
+
+    def add_widget(self, widget):
+        self._widgets[widget.get_name()] = widget
+
+    def get_widget(self, name):
+        widget = self._widgets.get(name)
+        if widget:
+            return widget
+        raise NodeWidgetError('node has no widget "{}"'.format(name))
+
+    def has_widget(self, name):
+        return name in self._widgets.keys()
+
+    def from_dict(self, node_dict):
+        super(NodeItem, self).from_dict(node_dict)
+        widgets = node_dict.pop('widgets', {})
+        for name, value in widgets.items():
+            if self._widgets.get(name):
+                self._widgets[name].set_value(value)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_circle.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_circle.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,535 +1,535 @@
-#!/usr/bin/python
-from Qt import QtCore, QtGui, QtWidgets
-
-from NodeGraphQt.constants import NodeEnum, PortEnum
-from NodeGraphQt.qgraphics.node_base import NodeItem
-
-
-class CircleNodeItem(NodeItem):
-    """
-    Circle Node item.
-
-    Args:
-        name (str): name displayed on the node.
-        parent (QtWidgets.QGraphicsItem): parent item.
-    """
-
-    def __init__(self, name='circle', parent=None):
-        super(CircleNodeItem, self).__init__(name, parent)
-
-    def _align_ports_horizontal(self, v_offset):
-        width = self._width
-        txt_offset = PortEnum.CLICK_FALLOFF.value - 2
-        spacing = 1
-
-        node_center_y = self.boundingRect().center().y()
-        node_center_y += v_offset
-
-        # adjust input position
-        inputs = [p for p in self.inputs if p.isVisible()]
-        if inputs:
-            port_width = inputs[0].boundingRect().width()
-            port_height = inputs[0].boundingRect().height()
-
-            count = len(inputs)
-            if count > 2:
-                is_odd = bool(count % 2)
-                middle_idx = int(count / 2)
-
-                # top half
-                port_x = (port_width / 2) * -1
-                port_y = node_center_y - (port_height / 2)
-                for idx, port in enumerate(reversed(inputs[:middle_idx])):
-                    if idx == 0:
-                        if is_odd:
-                            port_x += (port_width / 2) - (txt_offset / 2)
-                            port_y -= port_height + spacing
-                        else:
-                            port_y -= (port_height / 2) + spacing
-                    port.setPos(port_x, port_y)
-                    port_x += (port_width / 2) - (txt_offset / 2)
-                    port_y -= port_height + spacing
-
-                # bottom half
-                port_x = (port_width / 2) * -1
-                port_y = node_center_y - (port_height / 2)
-                for idx, port in enumerate(inputs[middle_idx:]):
-                    if idx == 0:
-                        if not is_odd:
-                            port_y += (port_height / 2) + spacing
-                    port.setPos(port_x, port_y)
-                    port_x += (port_width / 2) - (txt_offset / 2)
-                    port_y += port_height + spacing
-
-            else:
-                port_x = (port_width / 2) * -1
-                port_y = node_center_y - (port_height / 2)
-                inputs[0].setPos(port_x, port_y - (port_height / 2) + spacing)
-                inputs[1].setPos(port_x, port_y + (port_height / 2) + spacing)
-
-        # adjust input text position
-        for port, text in self._input_items.items():
-            if port.isVisible():
-                port_width = port.boundingRect().width()
-                txt_x = port.pos().x() + port_width - txt_offset
-                text.setPos(txt_x, port.y() - 1.5)
-
-        # adjust output position
-        outputs = [p for p in self.outputs if p.isVisible()]
-        if outputs:
-            port_width = outputs[0].boundingRect().width()
-            port_height = outputs[0].boundingRect().height()
-
-            count = len(outputs)
-            if count > 2:
-                is_odd = bool(count % 2)
-                middle_idx = int(count / 2)
-
-                # top half
-                port_x = width - (port_width / 2)
-                port_y = node_center_y - (port_height / 2)
-                for idx, port in enumerate(reversed(outputs[:middle_idx])):
-                    if idx == 0:
-                        if is_odd:
-                            port_x -= (port_width / 2) - (txt_offset / 2)
-                            port_y -= port_height + spacing
-                        else:
-                            port_y -= (port_height / 2) + spacing
-                    port.setPos(port_x, port_y)
-                    port_x -= (port_width / 2) - (txt_offset / 2)
-                    port_y -= port_height + spacing
-
-                # bottom half
-                port_x = width - (port_width / 2)
-                port_y = node_center_y - (port_height / 2)
-                for idx, port in enumerate(outputs[middle_idx:]):
-                    if idx == 0:
-                        if not is_odd:
-                            port_y += (port_width / 2) - (txt_offset / 2)
-                    port.setPos(port_x, port_y)
-                    port_x -= (port_width / 2) - (txt_offset / 2)
-                    port_y += port_height + spacing
-            else:
-                port_x = width - (port_width / 2)
-                port_y = node_center_y - (port_height / 2)
-                outputs[0].setPos(port_x, port_y - (port_height / 2) + spacing)
-                outputs[1].setPos(port_x, port_y + (port_height / 2) + spacing)
-
-        # adjust output text position
-        for port, text in self._output_items.items():
-            if port.isVisible():
-                txt_width = text.boundingRect().width() - txt_offset
-                txt_x = port.x() - txt_width
-                text.setPos(txt_x, port.y() - 1.5)
-
-    def _align_ports_vertical(self, v_offset):
-        height = self._height
-        node_center_x = self.boundingRect().center().x() + v_offset
-
-        # adjust input position
-        inputs = [p for p in self.inputs if p.isVisible()]
-        if inputs:
-            port_width = inputs[0].boundingRect().width()
-            port_height = inputs[0].boundingRect().height()
-
-            count = len(inputs)
-            if count > 2:
-                is_odd = bool(count % 2)
-                middle_idx = int(count / 2)
-
-                delta = (self._width / (len(inputs) + 1)) / 2
-
-                # left half
-                port_x = node_center_x - (port_width / 2)
-                port_y = (port_height / 2) * -1
-                for idx, port in enumerate(reversed(inputs[:middle_idx])):
-                    if idx == 0:
-                        if is_odd:
-                            port_x -= (port_width / 2) + delta
-                            port_y += (port_height / 2)
-                        else:
-                            port_x -= delta
-                    port.setPos(port_x, port_y)
-                    port_x -= (port_width / 2) + delta
-                    port_y += (port_height / 2)
-
-                # right half
-                port_x = node_center_x - (port_width / 2)
-                port_y = (port_height / 2) * -1
-                for idx, port in enumerate(inputs[middle_idx:]):
-                    if idx == 0:
-                        if not is_odd:
-                            port_x += delta
-                    port.setPos(port_x, port_y)
-                    port_x += (port_width / 2) + delta
-                    port_y += (port_height / 2)
-
-        # adjust output position
-        outputs = [p for p in self.outputs if p.isVisible()]
-        if outputs:
-            port_width = outputs[0].boundingRect().width()
-            port_height = outputs[0].boundingRect().height()
-
-            count = len(outputs)
-            if count > 2:
-                is_odd = bool(count % 2)
-                middle_idx = int(count / 2)
-
-                delta = (self._width / (len(outputs) + 1)) / 2
-
-                # left half
-                port_x = node_center_x - (port_width / 2)
-                port_y = height - (port_height / 2)
-                for idx, port in enumerate(reversed(outputs[:middle_idx])):
-                    if idx == 0:
-                        if is_odd:
-                            port_x -= (port_width / 2) + delta
-                            port_y -= (port_height / 2)
-                        else:
-                            port_x -= delta
-                    port.setPos(port_x, port_y)
-                    port_x -= (port_width / 2) + delta
-                    port_y -= (port_height / 2)
-
-                # right half
-                port_x = node_center_x - (port_width / 2)
-                port_y = height - (port_height / 2)
-                for idx, port in enumerate(outputs[middle_idx:]):
-                    if idx == 0:
-                        if not is_odd:
-                            port_x += delta
-                    port.setPos(port_x, port_y)
-                    port_x += (port_width / 2) + delta
-                    port_y -= (port_height / 2)
-
-    def _paint_horizontal(self, painter, option, widget):
-        painter.save()
-
-        #  display node area for debugging
-        # ----------------------------------------------------------------------
-        # pen = QtGui.QPen(QtGui.QColor(255, 255, 255, 80), 0.8)
-        # pen.setStyle(QtCore.Qt.DotLine)
-        # painter.setPen(pen)
-        # painter.drawRect(self.boundingRect())
-        # ----------------------------------------------------------------------
-
-        text_rect = self._text_item.boundingRect()
-        text_width = text_rect.width()
-        if text_width < 20.0:
-            text_width = 20.0
-
-        text_rect = QtCore.QRectF(
-            self.boundingRect().center().x() - (text_width / 2),
-            self.boundingRect().center().y() - (text_rect.height() / 2),
-            text_rect.width(),
-            text_rect.height()
-        )
-
-        padding = 10.0
-        rect = QtCore.QRectF(
-            text_rect.center().x() - (text_rect.width() / 2) - (padding / 2),
-            text_rect.center().y() - (text_rect.width() / 2) - (padding / 2),
-            text_rect.width() + padding,
-            text_rect.width() + padding
-        )
-
-        # draw port lines.
-        pen_color = QtGui.QColor(*self.border_color)
-        pen_color.setAlpha(120)
-        pen = QtGui.QPen(pen_color, 1.5)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        painter.setPen(pen)
-        painter.setBrush(QtCore.Qt.NoBrush)
-        for p in self.inputs:
-            if p.isVisible():
-                p_text = self.get_input_text_item(p)
-                if p_text.isVisible():
-                    pt_width = p_text.boundingRect().width() * 1.2
-                else:
-                    pt_width = p.boundingRect().width() / 4
-                pt1 = QtCore.QPointF(
-                    p.pos().x() + (p.boundingRect().width() / 2) + pt_width,
-                    p.pos().y() + (p.boundingRect().height() / 2)
-                )
-                path = QtGui.QPainterPath()
-                path.moveTo(pt1)
-                # path.lineTo(QtCore.QPointF(pt1.x() + 4.0, pt1.y()))
-                path.lineTo(rect.center())
-                painter.drawPath(path)
-
-        for p in self.outputs:
-            if p.isVisible():
-                p_text = self.get_output_text_item(p)
-                if p_text.isVisible():
-                    pt_width = p_text.boundingRect().width() * 1.2
-                else:
-                    pt_width = p.boundingRect().width() / 4
-                pt1 = QtCore.QPointF(
-                    p.pos().x() + (p.boundingRect().width() / 2) - pt_width,
-                    p.pos().y() + (p.boundingRect().height() / 2)
-                )
-                path = QtGui.QPainterPath()
-                path.moveTo(pt1)
-                # path.lineTo(QtCore.QPointF(pt1.x() - 2.0, pt1.y()))
-                path.lineTo(rect.center())
-                painter.drawPath(path)
-
-        # draw the base color.
-        painter.setBrush(QtGui.QColor(*self.color))
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.drawEllipse(rect)
-
-        # draw outline.
-        if self.selected:
-            # light overlay on background when selected.
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-            painter.drawEllipse(rect)
-
-            border_width = 1.2
-            border_color = QtGui.QColor(
-                *NodeEnum.SELECTED_BORDER_COLOR.value
-            )
-        else:
-            border_width = 0.8
-            border_color = QtGui.QColor(*self.border_color)
-
-        # draw the outlines.
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtGui.QPen(border_color, border_width))
-        painter.drawEllipse(rect)
-
-        # node name background.
-        text_rect = self._text_item.boundingRect()
-        text_rect = QtCore.QRectF(
-            rect.center().x() - (text_rect.width() / 2),
-            rect.center().y() - (text_rect.height() / 2),
-            text_rect.width(),
-            text_rect.height()
-        )
-        if self.selected:
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.drawRoundedRect(text_rect, 8.0, 8.0)
-
-        painter.restore()
-
-    def _paint_vertical(self, painter, option, widget):
-        painter.save()
-
-        #  display node area for debugging
-        # ----------------------------------------------------------------------
-        # pen = QtGui.QPen(QtGui.QColor(255, 255, 255, 80), 0.8)
-        # pen.setStyle(QtCore.Qt.DotLine)
-        # painter.setPen(pen)
-        # painter.drawRect(self.boundingRect())
-        # ----------------------------------------------------------------------
-
-        rect = self.boundingRect()
-        width = min(rect.width(), rect.height()) / 1.8
-        rect = QtCore.QRectF(
-            rect.center().x() - (width / 2),
-            rect.center().y() - (width / 2),
-            width, width
-        )
-
-        # draw port lines.
-        pen_color = QtGui.QColor(*self.border_color)
-        pen_color.setAlpha(120)
-        pen = QtGui.QPen(pen_color, 1.5)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        painter.setPen(pen)
-        painter.setBrush(QtCore.Qt.NoBrush)
-        for p in self.inputs:
-            if p.isVisible():
-                pt1 = QtCore.QPointF(
-                    p.pos().x() + (p.boundingRect().width() / 2),
-                    p.pos().y() + (p.boundingRect().height() / 2)
-                )
-                path = QtGui.QPainterPath()
-                path.moveTo(pt1)
-                path.moveTo(QtCore.QPointF(pt1.x(), pt1.y()))
-                path.lineTo(rect.center())
-                painter.drawPath(path)
-
-        for p in self.outputs:
-            if p.isVisible():
-                pt1 = QtCore.QPointF(
-                    p.pos().x() + (p.boundingRect().width() / 2),
-                    p.pos().y() + (p.boundingRect().height() / 2)
-                )
-                path = QtGui.QPainterPath()
-                path.moveTo(pt1)
-                path.lineTo(QtCore.QPointF(pt1.x(), pt1.y()))
-                path.lineTo(rect.center())
-                painter.drawPath(path)
-
-        # draw the base color.
-        painter.setBrush(QtGui.QColor(*self.color))
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.drawEllipse(rect)
-
-        # draw outline.
-        if self.selected:
-            # light overlay on background when selected.
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-            painter.drawEllipse(rect)
-
-            border_width = 1.2
-            border_color = QtGui.QColor(
-                *NodeEnum.SELECTED_BORDER_COLOR.value
-            )
-        else:
-            border_width = 0.8
-            border_color = QtGui.QColor(*self.border_color)
-
-        # draw the outlines.
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtGui.QPen(border_color, border_width))
-        painter.drawEllipse(rect)
-
-        painter.restore()
-        
-    def _align_icon_horizontal(self, h_offset, v_offset):
-        icon_rect = self._icon_item.boundingRect()
-        x = self.boundingRect().center().x() - (icon_rect.width() / 2)
-        y = self.boundingRect().top()
-        self._icon_item.setPos(x + h_offset, y + v_offset)
-
-    def _align_icon_vertical(self, h_offset, v_offset):
-        rect = self.boundingRect()
-        icon_rect = self._icon_item.boundingRect()
-        x = rect.left() - icon_rect.width() + (rect.width() / 4)
-        y = rect.center().y() - (icon_rect.height() / 2)
-        self._icon_item.setPos(x + h_offset, y + v_offset)
-
-    def _align_widgets_horizontal(self, v_offset):
-        if not self._widgets:
-            return
-        rect = self.boundingRect()
-        y = rect.bottom() + v_offset
-        inputs = [p for p in self.inputs if p.isVisible()]
-        outputs = [p for p in self.outputs if p.isVisible()]
-        for widget in self._widgets.values():
-            widget_rect = widget.boundingRect()
-            if not inputs:
-                x = rect.left() + 10
-                widget.widget().setTitleAlign('left')
-            elif not outputs:
-                x = rect.right() - widget_rect.width() - 10
-                widget.widget().setTitleAlign('right')
-            else:
-                x = rect.center().x() - (widget_rect.width() / 2)
-                widget.widget().setTitleAlign('center')
-            widget.setPos(x, y)
-            y += widget_rect.height()
-
-    def _align_widgets_vertical(self, v_offset):
-        if not self._widgets:
-            return
-        rect = self.boundingRect()
-        y = rect.center().y() + v_offset
-        widget_height = 0.0
-        for widget in self._widgets.values():
-            widget_rect = widget.boundingRect()
-            widget_height += widget_rect.height()
-        y -= widget_height / 2
-
-        for widget in self._widgets.values():
-            widget_rect = widget.boundingRect()
-            x = rect.center().x() - (widget_rect.width() / 2)
-            widget.widget().setTitleAlign('center')
-            widget.setPos(x, y)
-            y += widget_rect.height()
-
-    def _align_label_horizontal(self, h_offset, v_offset):
-        rect = self.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = rect.center().x() - (text_rect.width() / 2)
-        y = rect.center().y() - (text_rect.height() / 2)
-        self._text_item.setPos(x + h_offset, y + v_offset)
-
-    def _align_label_vertical(self, h_offset, v_offset):
-        rect = self.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = rect.right() - (rect.width() / 4)
-        y = rect.center().y() - (text_rect.height() / 2)
-        self._text_item.setPos(x + h_offset, y + v_offset)
-
-    def _draw_node_horizontal(self):
-        # update port text items in visibility.
-        text_width = 0
-        port_widths = 0
-        for port, text in self._input_items.items():
-            text.setVisible(port.display_name)
-            if port.display_name:
-                if text.boundingRect().width() > text_width:
-                    text_width = text.boundingRect().width()
-                port_widths += port.boundingRect().width() / len(self._input_items)
-
-        for port, text in self._output_items.items():
-            text.setVisible(port.display_name)
-            if port.display_name:
-                if text.boundingRect().width() > text_width:
-                    text_width = text.boundingRect().width()
-                port_widths += port.boundingRect().width() / len(self._output_items)
-
-        add_width = (text_width * 2) + port_widths
-        add_height = self.text_item.boundingRect().width() / 2
-
-        # setup initial base size.
-        self._set_base_size(add_w=add_width, add_h=add_height)
-        # set text color when node is initialized.
-        self._set_text_color(self.text_color)
-        # set the tooltip
-        self._tooltip_disable(self.disabled)
-
-        # --- set the initial node layout ---
-        # (do all the graphic item layout offsets here)
-
-        # align label text
-        self.align_label()
-        # arrange icon
-        self.align_icon()
-        # arrange input and output ports.
-        self.align_ports()
-        # arrange node widgets
-        self.align_widgets(v_offset=0.0)
-
-        self.update()
-
-    def _draw_node_vertical(self):
-        add_height = 0
-
-        # hide the port text items in vertical layout.
-        for port, text in self._input_items.items():
-            text.setVisible(False)
-            add_height += port.boundingRect().height() / 2
-        for port, text in self._output_items.items():
-            text.setVisible(False)
-            add_height += port.boundingRect().height() / 2
-
-        if add_height < 50:
-            add_height = 50
-
-        # setup initial base size.
-        self._set_base_size(add_w=50, add_h=add_height)
-        # set text color when node is initialized.
-        self._set_text_color(self.text_color)
-        # set the tooltip
-        self._tooltip_disable(self.disabled)
-
-        # --- set the initial node layout ---
-        # (do all the graphic item layout offsets here)
-
-        # align label text
-        self.align_label()
-        # align icon
-        self.align_icon()
-        # arrange input and output ports.
-        self.align_ports()
-        # arrange node widgets
-        self.align_widgets(v_offset=0.0)
-
-        self.update()
+#!/usr/bin/python
+from Qt import QtCore, QtGui, QtWidgets
+
+from NodeGraphQt.constants import NodeEnum, PortEnum
+from NodeGraphQt.qgraphics.node_base import NodeItem
+
+
+class CircleNodeItem(NodeItem):
+    """
+    Circle Node item.
+
+    Args:
+        name (str): name displayed on the node.
+        parent (QtWidgets.QGraphicsItem): parent item.
+    """
+
+    def __init__(self, name='circle', parent=None):
+        super(CircleNodeItem, self).__init__(name, parent)
+
+    def _align_ports_horizontal(self, v_offset):
+        width = self._width
+        txt_offset = PortEnum.CLICK_FALLOFF.value - 2
+        spacing = 1
+
+        node_center_y = self.boundingRect().center().y()
+        node_center_y += v_offset
+
+        # adjust input position
+        inputs = [p for p in self.inputs if p.isVisible()]
+        if inputs:
+            port_width = inputs[0].boundingRect().width()
+            port_height = inputs[0].boundingRect().height()
+
+            count = len(inputs)
+            if count > 2:
+                is_odd = bool(count % 2)
+                middle_idx = int(count / 2)
+
+                # top half
+                port_x = (port_width / 2) * -1
+                port_y = node_center_y - (port_height / 2)
+                for idx, port in enumerate(reversed(inputs[:middle_idx])):
+                    if idx == 0:
+                        if is_odd:
+                            port_x += (port_width / 2) - (txt_offset / 2)
+                            port_y -= port_height + spacing
+                        else:
+                            port_y -= (port_height / 2) + spacing
+                    port.setPos(port_x, port_y)
+                    port_x += (port_width / 2) - (txt_offset / 2)
+                    port_y -= port_height + spacing
+
+                # bottom half
+                port_x = (port_width / 2) * -1
+                port_y = node_center_y - (port_height / 2)
+                for idx, port in enumerate(inputs[middle_idx:]):
+                    if idx == 0:
+                        if not is_odd:
+                            port_y += (port_height / 2) + spacing
+                    port.setPos(port_x, port_y)
+                    port_x += (port_width / 2) - (txt_offset / 2)
+                    port_y += port_height + spacing
+
+            else:
+                port_x = (port_width / 2) * -1
+                port_y = node_center_y - (port_height / 2)
+                inputs[0].setPos(port_x, port_y - (port_height / 2) + spacing)
+                inputs[1].setPos(port_x, port_y + (port_height / 2) + spacing)
+
+        # adjust input text position
+        for port, text in self._input_items.items():
+            if port.isVisible():
+                port_width = port.boundingRect().width()
+                txt_x = port.pos().x() + port_width - txt_offset
+                text.setPos(txt_x, port.y() - 1.5)
+
+        # adjust output position
+        outputs = [p for p in self.outputs if p.isVisible()]
+        if outputs:
+            port_width = outputs[0].boundingRect().width()
+            port_height = outputs[0].boundingRect().height()
+
+            count = len(outputs)
+            if count > 2:
+                is_odd = bool(count % 2)
+                middle_idx = int(count / 2)
+
+                # top half
+                port_x = width - (port_width / 2)
+                port_y = node_center_y - (port_height / 2)
+                for idx, port in enumerate(reversed(outputs[:middle_idx])):
+                    if idx == 0:
+                        if is_odd:
+                            port_x -= (port_width / 2) - (txt_offset / 2)
+                            port_y -= port_height + spacing
+                        else:
+                            port_y -= (port_height / 2) + spacing
+                    port.setPos(port_x, port_y)
+                    port_x -= (port_width / 2) - (txt_offset / 2)
+                    port_y -= port_height + spacing
+
+                # bottom half
+                port_x = width - (port_width / 2)
+                port_y = node_center_y - (port_height / 2)
+                for idx, port in enumerate(outputs[middle_idx:]):
+                    if idx == 0:
+                        if not is_odd:
+                            port_y += (port_width / 2) - (txt_offset / 2)
+                    port.setPos(port_x, port_y)
+                    port_x -= (port_width / 2) - (txt_offset / 2)
+                    port_y += port_height + spacing
+            else:
+                port_x = width - (port_width / 2)
+                port_y = node_center_y - (port_height / 2)
+                outputs[0].setPos(port_x, port_y - (port_height / 2) + spacing)
+                outputs[1].setPos(port_x, port_y + (port_height / 2) + spacing)
+
+        # adjust output text position
+        for port, text in self._output_items.items():
+            if port.isVisible():
+                txt_width = text.boundingRect().width() - txt_offset
+                txt_x = port.x() - txt_width
+                text.setPos(txt_x, port.y() - 1.5)
+
+    def _align_ports_vertical(self, v_offset):
+        height = self._height
+        node_center_x = self.boundingRect().center().x() + v_offset
+
+        # adjust input position
+        inputs = [p for p in self.inputs if p.isVisible()]
+        if inputs:
+            port_width = inputs[0].boundingRect().width()
+            port_height = inputs[0].boundingRect().height()
+
+            count = len(inputs)
+            if count > 2:
+                is_odd = bool(count % 2)
+                middle_idx = int(count / 2)
+
+                delta = (self._width / (len(inputs) + 1)) / 2
+
+                # left half
+                port_x = node_center_x - (port_width / 2)
+                port_y = (port_height / 2) * -1
+                for idx, port in enumerate(reversed(inputs[:middle_idx])):
+                    if idx == 0:
+                        if is_odd:
+                            port_x -= (port_width / 2) + delta
+                            port_y += (port_height / 2)
+                        else:
+                            port_x -= delta
+                    port.setPos(port_x, port_y)
+                    port_x -= (port_width / 2) + delta
+                    port_y += (port_height / 2)
+
+                # right half
+                port_x = node_center_x - (port_width / 2)
+                port_y = (port_height / 2) * -1
+                for idx, port in enumerate(inputs[middle_idx:]):
+                    if idx == 0:
+                        if not is_odd:
+                            port_x += delta
+                    port.setPos(port_x, port_y)
+                    port_x += (port_width / 2) + delta
+                    port_y += (port_height / 2)
+
+        # adjust output position
+        outputs = [p for p in self.outputs if p.isVisible()]
+        if outputs:
+            port_width = outputs[0].boundingRect().width()
+            port_height = outputs[0].boundingRect().height()
+
+            count = len(outputs)
+            if count > 2:
+                is_odd = bool(count % 2)
+                middle_idx = int(count / 2)
+
+                delta = (self._width / (len(outputs) + 1)) / 2
+
+                # left half
+                port_x = node_center_x - (port_width / 2)
+                port_y = height - (port_height / 2)
+                for idx, port in enumerate(reversed(outputs[:middle_idx])):
+                    if idx == 0:
+                        if is_odd:
+                            port_x -= (port_width / 2) + delta
+                            port_y -= (port_height / 2)
+                        else:
+                            port_x -= delta
+                    port.setPos(port_x, port_y)
+                    port_x -= (port_width / 2) + delta
+                    port_y -= (port_height / 2)
+
+                # right half
+                port_x = node_center_x - (port_width / 2)
+                port_y = height - (port_height / 2)
+                for idx, port in enumerate(outputs[middle_idx:]):
+                    if idx == 0:
+                        if not is_odd:
+                            port_x += delta
+                    port.setPos(port_x, port_y)
+                    port_x += (port_width / 2) + delta
+                    port_y -= (port_height / 2)
+
+    def _paint_horizontal(self, painter, option, widget):
+        painter.save()
+
+        #  display node area for debugging
+        # ----------------------------------------------------------------------
+        # pen = QtGui.QPen(QtGui.QColor(255, 255, 255, 80), 0.8)
+        # pen.setStyle(QtCore.Qt.DotLine)
+        # painter.setPen(pen)
+        # painter.drawRect(self.boundingRect())
+        # ----------------------------------------------------------------------
+
+        text_rect = self._text_item.boundingRect()
+        text_width = text_rect.width()
+        if text_width < 20.0:
+            text_width = 20.0
+
+        text_rect = QtCore.QRectF(
+            self.boundingRect().center().x() - (text_width / 2),
+            self.boundingRect().center().y() - (text_rect.height() / 2),
+            text_rect.width(),
+            text_rect.height()
+        )
+
+        padding = 10.0
+        rect = QtCore.QRectF(
+            text_rect.center().x() - (text_rect.width() / 2) - (padding / 2),
+            text_rect.center().y() - (text_rect.width() / 2) - (padding / 2),
+            text_rect.width() + padding,
+            text_rect.width() + padding
+        )
+
+        # draw port lines.
+        pen_color = QtGui.QColor(*self.border_color)
+        pen_color.setAlpha(120)
+        pen = QtGui.QPen(pen_color, 1.5)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        painter.setPen(pen)
+        painter.setBrush(QtCore.Qt.NoBrush)
+        for p in self.inputs:
+            if p.isVisible():
+                p_text = self.get_input_text_item(p)
+                if p_text.isVisible():
+                    pt_width = p_text.boundingRect().width() * 1.2
+                else:
+                    pt_width = p.boundingRect().width() / 4
+                pt1 = QtCore.QPointF(
+                    p.pos().x() + (p.boundingRect().width() / 2) + pt_width,
+                    p.pos().y() + (p.boundingRect().height() / 2)
+                )
+                path = QtGui.QPainterPath()
+                path.moveTo(pt1)
+                # path.lineTo(QtCore.QPointF(pt1.x() + 4.0, pt1.y()))
+                path.lineTo(rect.center())
+                painter.drawPath(path)
+
+        for p in self.outputs:
+            if p.isVisible():
+                p_text = self.get_output_text_item(p)
+                if p_text.isVisible():
+                    pt_width = p_text.boundingRect().width() * 1.2
+                else:
+                    pt_width = p.boundingRect().width() / 4
+                pt1 = QtCore.QPointF(
+                    p.pos().x() + (p.boundingRect().width() / 2) - pt_width,
+                    p.pos().y() + (p.boundingRect().height() / 2)
+                )
+                path = QtGui.QPainterPath()
+                path.moveTo(pt1)
+                # path.lineTo(QtCore.QPointF(pt1.x() - 2.0, pt1.y()))
+                path.lineTo(rect.center())
+                painter.drawPath(path)
+
+        # draw the base color.
+        painter.setBrush(QtGui.QColor(*self.color))
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.drawEllipse(rect)
+
+        # draw outline.
+        if self.selected:
+            # light overlay on background when selected.
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+            painter.drawEllipse(rect)
+
+            border_width = 1.2
+            border_color = QtGui.QColor(
+                *NodeEnum.SELECTED_BORDER_COLOR.value
+            )
+        else:
+            border_width = 0.8
+            border_color = QtGui.QColor(*self.border_color)
+
+        # draw the outlines.
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtGui.QPen(border_color, border_width))
+        painter.drawEllipse(rect)
+
+        # node name background.
+        text_rect = self._text_item.boundingRect()
+        text_rect = QtCore.QRectF(
+            rect.center().x() - (text_rect.width() / 2),
+            rect.center().y() - (text_rect.height() / 2),
+            text_rect.width(),
+            text_rect.height()
+        )
+        if self.selected:
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.drawRoundedRect(text_rect, 8.0, 8.0)
+
+        painter.restore()
+
+    def _paint_vertical(self, painter, option, widget):
+        painter.save()
+
+        #  display node area for debugging
+        # ----------------------------------------------------------------------
+        # pen = QtGui.QPen(QtGui.QColor(255, 255, 255, 80), 0.8)
+        # pen.setStyle(QtCore.Qt.DotLine)
+        # painter.setPen(pen)
+        # painter.drawRect(self.boundingRect())
+        # ----------------------------------------------------------------------
+
+        rect = self.boundingRect()
+        width = min(rect.width(), rect.height()) / 1.8
+        rect = QtCore.QRectF(
+            rect.center().x() - (width / 2),
+            rect.center().y() - (width / 2),
+            width, width
+        )
+
+        # draw port lines.
+        pen_color = QtGui.QColor(*self.border_color)
+        pen_color.setAlpha(120)
+        pen = QtGui.QPen(pen_color, 1.5)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        painter.setPen(pen)
+        painter.setBrush(QtCore.Qt.NoBrush)
+        for p in self.inputs:
+            if p.isVisible():
+                pt1 = QtCore.QPointF(
+                    p.pos().x() + (p.boundingRect().width() / 2),
+                    p.pos().y() + (p.boundingRect().height() / 2)
+                )
+                path = QtGui.QPainterPath()
+                path.moveTo(pt1)
+                path.moveTo(QtCore.QPointF(pt1.x(), pt1.y()))
+                path.lineTo(rect.center())
+                painter.drawPath(path)
+
+        for p in self.outputs:
+            if p.isVisible():
+                pt1 = QtCore.QPointF(
+                    p.pos().x() + (p.boundingRect().width() / 2),
+                    p.pos().y() + (p.boundingRect().height() / 2)
+                )
+                path = QtGui.QPainterPath()
+                path.moveTo(pt1)
+                path.lineTo(QtCore.QPointF(pt1.x(), pt1.y()))
+                path.lineTo(rect.center())
+                painter.drawPath(path)
+
+        # draw the base color.
+        painter.setBrush(QtGui.QColor(*self.color))
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.drawEllipse(rect)
+
+        # draw outline.
+        if self.selected:
+            # light overlay on background when selected.
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+            painter.drawEllipse(rect)
+
+            border_width = 1.2
+            border_color = QtGui.QColor(
+                *NodeEnum.SELECTED_BORDER_COLOR.value
+            )
+        else:
+            border_width = 0.8
+            border_color = QtGui.QColor(*self.border_color)
+
+        # draw the outlines.
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtGui.QPen(border_color, border_width))
+        painter.drawEllipse(rect)
+
+        painter.restore()
+        
+    def _align_icon_horizontal(self, h_offset, v_offset):
+        icon_rect = self._icon_item.boundingRect()
+        x = self.boundingRect().center().x() - (icon_rect.width() / 2)
+        y = self.boundingRect().top()
+        self._icon_item.setPos(x + h_offset, y + v_offset)
+
+    def _align_icon_vertical(self, h_offset, v_offset):
+        rect = self.boundingRect()
+        icon_rect = self._icon_item.boundingRect()
+        x = rect.left() - icon_rect.width() + (rect.width() / 4)
+        y = rect.center().y() - (icon_rect.height() / 2)
+        self._icon_item.setPos(x + h_offset, y + v_offset)
+
+    def _align_widgets_horizontal(self, v_offset):
+        if not self._widgets:
+            return
+        rect = self.boundingRect()
+        y = rect.bottom() + v_offset
+        inputs = [p for p in self.inputs if p.isVisible()]
+        outputs = [p for p in self.outputs if p.isVisible()]
+        for widget in self._widgets.values():
+            widget_rect = widget.boundingRect()
+            if not inputs:
+                x = rect.left() + 10
+                widget.widget().setTitleAlign('left')
+            elif not outputs:
+                x = rect.right() - widget_rect.width() - 10
+                widget.widget().setTitleAlign('right')
+            else:
+                x = rect.center().x() - (widget_rect.width() / 2)
+                widget.widget().setTitleAlign('center')
+            widget.setPos(x, y)
+            y += widget_rect.height()
+
+    def _align_widgets_vertical(self, v_offset):
+        if not self._widgets:
+            return
+        rect = self.boundingRect()
+        y = rect.center().y() + v_offset
+        widget_height = 0.0
+        for widget in self._widgets.values():
+            widget_rect = widget.boundingRect()
+            widget_height += widget_rect.height()
+        y -= widget_height / 2
+
+        for widget in self._widgets.values():
+            widget_rect = widget.boundingRect()
+            x = rect.center().x() - (widget_rect.width() / 2)
+            widget.widget().setTitleAlign('center')
+            widget.setPos(x, y)
+            y += widget_rect.height()
+
+    def _align_label_horizontal(self, h_offset, v_offset):
+        rect = self.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = rect.center().x() - (text_rect.width() / 2)
+        y = rect.center().y() - (text_rect.height() / 2)
+        self._text_item.setPos(x + h_offset, y + v_offset)
+
+    def _align_label_vertical(self, h_offset, v_offset):
+        rect = self.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = rect.right() - (rect.width() / 4)
+        y = rect.center().y() - (text_rect.height() / 2)
+        self._text_item.setPos(x + h_offset, y + v_offset)
+
+    def _draw_node_horizontal(self):
+        # update port text items in visibility.
+        text_width = 0
+        port_widths = 0
+        for port, text in self._input_items.items():
+            text.setVisible(port.display_name)
+            if port.display_name:
+                if text.boundingRect().width() > text_width:
+                    text_width = text.boundingRect().width()
+                port_widths += port.boundingRect().width() / len(self._input_items)
+
+        for port, text in self._output_items.items():
+            text.setVisible(port.display_name)
+            if port.display_name:
+                if text.boundingRect().width() > text_width:
+                    text_width = text.boundingRect().width()
+                port_widths += port.boundingRect().width() / len(self._output_items)
+
+        add_width = (text_width * 2) + port_widths
+        add_height = self.text_item.boundingRect().width() / 2
+
+        # setup initial base size.
+        self._set_base_size(add_w=add_width, add_h=add_height)
+        # set text color when node is initialized.
+        self._set_text_color(self.text_color)
+        # set the tooltip
+        self._tooltip_disable(self.disabled)
+
+        # --- set the initial node layout ---
+        # (do all the graphic item layout offsets here)
+
+        # align label text
+        self.align_label()
+        # arrange icon
+        self.align_icon()
+        # arrange input and output ports.
+        self.align_ports()
+        # arrange node widgets
+        self.align_widgets(v_offset=0.0)
+
+        self.update()
+
+    def _draw_node_vertical(self):
+        add_height = 0
+
+        # hide the port text items in vertical layout.
+        for port, text in self._input_items.items():
+            text.setVisible(False)
+            add_height += port.boundingRect().height() / 2
+        for port, text in self._output_items.items():
+            text.setVisible(False)
+            add_height += port.boundingRect().height() / 2
+
+        if add_height < 50:
+            add_height = 50
+
+        # setup initial base size.
+        self._set_base_size(add_w=50, add_h=add_height)
+        # set text color when node is initialized.
+        self._set_text_color(self.text_color)
+        # set the tooltip
+        self._tooltip_disable(self.disabled)
+
+        # --- set the initial node layout ---
+        # (do all the graphic item layout offsets here)
+
+        # align label text
+        self.align_label()
+        # align icon
+        self.align_icon()
+        # arrange input and output ports.
+        self.align_ports()
+        # arrange node widgets
+        self.align_widgets(v_offset=0.0)
+
+        self.update()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_group.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_group.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,317 +1,317 @@
-#!/usr/bin/python
-from Qt import QtCore, QtGui, QtWidgets
-
-from NodeGraphQt.constants import NodeEnum, PortEnum
-from NodeGraphQt.qgraphics.node_base import NodeItem
-
-
-class GroupNodeItem(NodeItem):
-    """
-    Group Node item.
-
-    Args:
-        name (str): name displayed on the node.
-        parent (QtWidgets.QGraphicsItem): parent item.
-    """
-
-    def __init__(self, name='group', parent=None):
-        super(GroupNodeItem, self).__init__(name, parent)
-
-    def _paint_horizontal(self, painter, option, widget):
-        painter.save()
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtCore.Qt.NoPen)
-
-        # base background.
-        margin = 6.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        # draw the base color
-        offset = 3.0
-        rect_1 = QtCore.QRectF(rect.x() + (offset / 2),
-                               rect.y() + offset + 2.0,
-                               rect.width(), rect.height())
-        rect_2 = QtCore.QRectF(rect.x() - offset,
-                               rect.y() - offset,
-                               rect.width(), rect.height())
-        poly = QtGui.QPolygonF()
-        poly.append(rect_1.topRight())
-        poly.append(rect_2.topRight())
-        poly.append(rect_2.bottomLeft())
-        poly.append(rect_1.bottomLeft())
-
-        painter.setBrush(QtGui.QColor(*self.color).darker(180))
-        painter.drawRect(rect_1)
-        painter.drawPolygon(poly)
-
-        painter.setBrush(QtGui.QColor(*self.color))
-        painter.drawRect(rect_2)
-
-        if self.selected:
-            border_color = QtGui.QColor(
-                *NodeEnum.SELECTED_BORDER_COLOR.value
-            )
-            # light overlay on background when selected.
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-            painter.drawRect(rect_2)
-        else:
-            border_color = QtGui.QColor(*self.border_color)
-
-        # node name background
-        padding = 2.0, 2.0
-        text_rect = self._text_item.boundingRect()
-        text_rect = QtCore.QRectF(rect_2.left() + padding[0],
-                                  rect_2.top() + padding[1],
-                                  rect.right() - (padding[0] * 2) - margin,
-                                  text_rect.height() - (padding[1] * 2))
-        if self.selected:
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.drawRect(text_rect)
-
-        # draw the outlines.
-        pen = QtGui.QPen(border_color.darker(120), 0.8)
-        pen.setJoinStyle(QtCore.Qt.RoundJoin)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(pen)
-        painter.drawLines([rect_1.topRight(), rect_2.topRight(),
-                           rect_1.topRight(), rect_1.bottomRight(),
-                           rect_1.bottomRight(), rect_1.bottomLeft(),
-                           rect_1.bottomLeft(), rect_2.bottomLeft()])
-        painter.drawLine(rect_1.bottomRight(), rect_2.bottomRight())
-
-        pen = QtGui.QPen(border_color, 0.8)
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        painter.setPen(pen)
-        painter.drawRect(rect_2)
-
-        painter.restore()
-
-    def _paint_vertical(self, painter, option, widget):
-        painter.save()
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtCore.Qt.NoPen)
-
-        # base background.
-        margin = 6.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        # draw the base color
-        offset = 3.0
-        rect_1 = QtCore.QRectF(rect.x() + offset,
-                               rect.y() + (offset / 2),
-                               rect.width(), rect.height())
-        rect_2 = QtCore.QRectF(rect.x() - offset,
-                               rect.y() - offset,
-                               rect.width(), rect.height())
-        poly = QtGui.QPolygonF()
-        poly.append(rect_1.topRight())
-        poly.append(rect_2.topRight())
-        poly.append(rect_2.bottomLeft())
-        poly.append(rect_1.bottomLeft())
-
-        painter.setBrush(QtGui.QColor(*self.color).dark(180))
-        painter.drawRect(rect_1)
-        painter.drawPolygon(poly)
-        painter.setBrush(QtGui.QColor(*self.color))
-        painter.drawRect(rect_2)
-
-        if self.selected:
-            border_color = QtGui.QColor(
-                *NodeEnum.SELECTED_BORDER_COLOR.value
-            )
-            # light overlay on background when selected.
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-            painter.drawRect(rect_2)
-        else:
-            border_color = QtGui.QColor(*self.border_color)
-
-        # top & bottom edge background.
-        padding = 2.0
-        height = 10
-        if self.selected:
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
-
-        painter.setPen(QtCore.Qt.NoPen)
-        for y in [rect_2.top() + padding, rect_2.bottom() - height - padding]:
-            top_rect = QtCore.QRectF(rect.x() + padding - offset, y,
-                                     rect.width() - (padding * 2), height)
-            painter.drawRect(top_rect)
-
-        # draw the outlines.
-        pen = QtGui.QPen(border_color.darker(120), 0.8)
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(pen)
-        painter.drawLines([rect_1.topRight(), rect_2.topRight(),
-                           rect_1.topRight(), rect_1.bottomRight(),
-                           rect_1.bottomRight(), rect_1.bottomLeft(),
-                           rect_1.bottomLeft(), rect_2.bottomLeft()])
-        painter.drawLine(rect_1.bottomRight(), rect_2.bottomRight())
-
-        pen = QtGui.QPen(border_color, 0.8)
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        painter.setPen(pen)
-        painter.drawRect(rect_2)
-
-        painter.restore()
-        
-    def _align_icon_horizontal(self, h_offset, v_offset):
-        super(GroupNodeItem, self)._align_icon_horizontal(h_offset, v_offset)
-        
-    def _align_icon_vertical(self, h_offset, v_offset):
-        y = self._height / 2
-        y -= self._icon_item.boundingRect().height()
-        self._icon_item.setPos(self._width + h_offset, y + v_offset)
-
-    def _align_label_horizontal(self, h_offset, v_offset):
-        super(GroupNodeItem, self)._align_label_horizontal(h_offset, v_offset)
-        
-    def _align_label_vertical(self, h_offset, v_offset):
-        y = self._height / 2
-        y -= self.text_item.boundingRect().height() / 2
-        self._text_item.setPos(self._width + h_offset, y + v_offset)
-
-    def _align_ports_horizontal(self, v_offset):
-        width = self._width
-        txt_offset = PortEnum.CLICK_FALLOFF.value - 2
-        spacing = 1
-
-        # adjust input position
-        inputs = [p for p in self.inputs if p.isVisible()]
-        if inputs:
-            port_width = inputs[0].boundingRect().width()
-            port_height = inputs[0].boundingRect().height()
-            port_x = port_width / 2 * -1
-            port_x += 3.0
-            port_y = v_offset
-            for port in inputs:
-                port.setPos(port_x, port_y)
-                port_y += port_height + spacing
-        # adjust input text position
-        for port, text in self._input_items.items():
-            if port.isVisible():
-                txt_x = port.boundingRect().width() / 2 - txt_offset
-                txt_x += 3.0
-                text.setPos(txt_x, port.y() - 1.5)
-
-        # adjust output position
-        outputs = [p for p in self.outputs if p.isVisible()]
-        if outputs:
-            port_width = outputs[0].boundingRect().width()
-            port_height = outputs[0].boundingRect().height()
-            port_x = width - (port_width / 2)
-            port_x -= 9.0
-            port_y = v_offset
-            for port in outputs:
-                port.setPos(port_x, port_y)
-                port_y += port_height + spacing
-        # adjust output text position
-        for port, text in self._output_items.items():
-            if port.isVisible():
-                txt_width = text.boundingRect().width() - txt_offset
-                txt_x = port.x() - txt_width
-                text.setPos(txt_x, port.y() - 1.5)
-
-    def _align_ports_vertical(self, v_offset):
-        # adjust input position
-        inputs = [p for p in self.inputs if p.isVisible()]
-        if inputs:
-            port_width = inputs[0].boundingRect().width()
-            port_height = inputs[0].boundingRect().height()
-            half_width = port_width / 2
-            delta = self._width / (len(inputs) + 1)
-            port_x = delta
-            port_y = -port_height / 2 + 3.0
-            for port in inputs:
-                port.setPos(port_x - half_width, port_y)
-                port_x += delta
-
-        # adjust output position
-        outputs = [p for p in self.outputs if p.isVisible()]
-        if outputs:
-            port_width = outputs[0].boundingRect().width()
-            port_height = outputs[0].boundingRect().height()
-            half_width = port_width / 2
-            delta = self._width / (len(outputs) + 1)
-            port_x = delta
-            port_y = self._height - (port_height / 2) - 9.0
-            for port in outputs:
-                port.setPos(port_x - half_width, port_y)
-                port_x += delta
-
-    def _draw_node_horizontal(self):
-        height = self._text_item.boundingRect().height()
-
-        # update port text items in visibility.
-        for port, text in self._input_items.items():
-            text.setVisible(port.display_name)
-        for port, text in self._output_items.items():
-            text.setVisible(port.display_name)
-
-        # setup initial base size.
-        self._set_base_size(add_w=8.0, add_h=height + 10)
-        # set text color when node is initialized.
-        self._set_text_color(self.text_color)
-        # set the tooltip
-        self._tooltip_disable(self.disabled)
-
-        # --- set the initial node layout ---
-        # (do all the graphic item layout offsets here)
-
-        # align label text
-        self.align_label()
-        # arrange icon
-        self.align_icon(h_offset=2.0, v_offset=3.0)
-        # arrange input and output ports.
-        self.align_ports(v_offset=height)
-        # arrange node widgets
-        self.align_widgets(v_offset=height)
-
-        self.update()
-
-    def _draw_node_vertical(self):
-        height = self._text_item.boundingRect().height()
-
-        # hide the port text items in vertical layout.
-        for port, text in self._input_items.items():
-            text.setVisible(False)
-        for port, text in self._output_items.items():
-            text.setVisible(False)
-
-        # setup initial base size.
-        self._set_base_size(add_w=8.0)
-        # set text color when node is initialized.
-        self._set_text_color(self.text_color)
-        # set the tooltip
-        self._tooltip_disable(self.disabled)
-
-        # --- set the initial node layout ---
-        # (do all the graphic item layout offsets here)
-
-        # align label text
-        self.align_label(h_offset=7, v_offset=6)
-        # align icon
-        self.align_icon(h_offset=4, v_offset=-2)
-        # arrange input and output ports.
-        self.align_ports(v_offset=height + (height / 2))
-        # arrange node widgets
-        self.align_widgets(v_offset=height / 2)
-
-        self.update()
+#!/usr/bin/python
+from Qt import QtCore, QtGui, QtWidgets
+
+from NodeGraphQt.constants import NodeEnum, PortEnum
+from NodeGraphQt.qgraphics.node_base import NodeItem
+
+
+class GroupNodeItem(NodeItem):
+    """
+    Group Node item.
+
+    Args:
+        name (str): name displayed on the node.
+        parent (QtWidgets.QGraphicsItem): parent item.
+    """
+
+    def __init__(self, name='group', parent=None):
+        super(GroupNodeItem, self).__init__(name, parent)
+
+    def _paint_horizontal(self, painter, option, widget):
+        painter.save()
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtCore.Qt.NoPen)
+
+        # base background.
+        margin = 6.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        # draw the base color
+        offset = 3.0
+        rect_1 = QtCore.QRectF(rect.x() + (offset / 2),
+                               rect.y() + offset + 2.0,
+                               rect.width(), rect.height())
+        rect_2 = QtCore.QRectF(rect.x() - offset,
+                               rect.y() - offset,
+                               rect.width(), rect.height())
+        poly = QtGui.QPolygonF()
+        poly.append(rect_1.topRight())
+        poly.append(rect_2.topRight())
+        poly.append(rect_2.bottomLeft())
+        poly.append(rect_1.bottomLeft())
+
+        painter.setBrush(QtGui.QColor(*self.color).darker(180))
+        painter.drawRect(rect_1)
+        painter.drawPolygon(poly)
+
+        painter.setBrush(QtGui.QColor(*self.color))
+        painter.drawRect(rect_2)
+
+        if self.selected:
+            border_color = QtGui.QColor(
+                *NodeEnum.SELECTED_BORDER_COLOR.value
+            )
+            # light overlay on background when selected.
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+            painter.drawRect(rect_2)
+        else:
+            border_color = QtGui.QColor(*self.border_color)
+
+        # node name background
+        padding = 2.0, 2.0
+        text_rect = self._text_item.boundingRect()
+        text_rect = QtCore.QRectF(rect_2.left() + padding[0],
+                                  rect_2.top() + padding[1],
+                                  rect.right() - (padding[0] * 2) - margin,
+                                  text_rect.height() - (padding[1] * 2))
+        if self.selected:
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.drawRect(text_rect)
+
+        # draw the outlines.
+        pen = QtGui.QPen(border_color.darker(120), 0.8)
+        pen.setJoinStyle(QtCore.Qt.RoundJoin)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(pen)
+        painter.drawLines([rect_1.topRight(), rect_2.topRight(),
+                           rect_1.topRight(), rect_1.bottomRight(),
+                           rect_1.bottomRight(), rect_1.bottomLeft(),
+                           rect_1.bottomLeft(), rect_2.bottomLeft()])
+        painter.drawLine(rect_1.bottomRight(), rect_2.bottomRight())
+
+        pen = QtGui.QPen(border_color, 0.8)
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        painter.setPen(pen)
+        painter.drawRect(rect_2)
+
+        painter.restore()
+
+    def _paint_vertical(self, painter, option, widget):
+        painter.save()
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtCore.Qt.NoPen)
+
+        # base background.
+        margin = 6.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        # draw the base color
+        offset = 3.0
+        rect_1 = QtCore.QRectF(rect.x() + offset,
+                               rect.y() + (offset / 2),
+                               rect.width(), rect.height())
+        rect_2 = QtCore.QRectF(rect.x() - offset,
+                               rect.y() - offset,
+                               rect.width(), rect.height())
+        poly = QtGui.QPolygonF()
+        poly.append(rect_1.topRight())
+        poly.append(rect_2.topRight())
+        poly.append(rect_2.bottomLeft())
+        poly.append(rect_1.bottomLeft())
+
+        painter.setBrush(QtGui.QColor(*self.color).dark(180))
+        painter.drawRect(rect_1)
+        painter.drawPolygon(poly)
+        painter.setBrush(QtGui.QColor(*self.color))
+        painter.drawRect(rect_2)
+
+        if self.selected:
+            border_color = QtGui.QColor(
+                *NodeEnum.SELECTED_BORDER_COLOR.value
+            )
+            # light overlay on background when selected.
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+            painter.drawRect(rect_2)
+        else:
+            border_color = QtGui.QColor(*self.border_color)
+
+        # top & bottom edge background.
+        padding = 2.0
+        height = 10
+        if self.selected:
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            painter.setBrush(QtGui.QColor(0, 0, 0, 80))
+
+        painter.setPen(QtCore.Qt.NoPen)
+        for y in [rect_2.top() + padding, rect_2.bottom() - height - padding]:
+            top_rect = QtCore.QRectF(rect.x() + padding - offset, y,
+                                     rect.width() - (padding * 2), height)
+            painter.drawRect(top_rect)
+
+        # draw the outlines.
+        pen = QtGui.QPen(border_color.darker(120), 0.8)
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(pen)
+        painter.drawLines([rect_1.topRight(), rect_2.topRight(),
+                           rect_1.topRight(), rect_1.bottomRight(),
+                           rect_1.bottomRight(), rect_1.bottomLeft(),
+                           rect_1.bottomLeft(), rect_2.bottomLeft()])
+        painter.drawLine(rect_1.bottomRight(), rect_2.bottomRight())
+
+        pen = QtGui.QPen(border_color, 0.8)
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        painter.setPen(pen)
+        painter.drawRect(rect_2)
+
+        painter.restore()
+        
+    def _align_icon_horizontal(self, h_offset, v_offset):
+        super(GroupNodeItem, self)._align_icon_horizontal(h_offset, v_offset)
+        
+    def _align_icon_vertical(self, h_offset, v_offset):
+        y = self._height / 2
+        y -= self._icon_item.boundingRect().height()
+        self._icon_item.setPos(self._width + h_offset, y + v_offset)
+
+    def _align_label_horizontal(self, h_offset, v_offset):
+        super(GroupNodeItem, self)._align_label_horizontal(h_offset, v_offset)
+        
+    def _align_label_vertical(self, h_offset, v_offset):
+        y = self._height / 2
+        y -= self.text_item.boundingRect().height() / 2
+        self._text_item.setPos(self._width + h_offset, y + v_offset)
+
+    def _align_ports_horizontal(self, v_offset):
+        width = self._width
+        txt_offset = PortEnum.CLICK_FALLOFF.value - 2
+        spacing = 1
+
+        # adjust input position
+        inputs = [p for p in self.inputs if p.isVisible()]
+        if inputs:
+            port_width = inputs[0].boundingRect().width()
+            port_height = inputs[0].boundingRect().height()
+            port_x = port_width / 2 * -1
+            port_x += 3.0
+            port_y = v_offset
+            for port in inputs:
+                port.setPos(port_x, port_y)
+                port_y += port_height + spacing
+        # adjust input text position
+        for port, text in self._input_items.items():
+            if port.isVisible():
+                txt_x = port.boundingRect().width() / 2 - txt_offset
+                txt_x += 3.0
+                text.setPos(txt_x, port.y() - 1.5)
+
+        # adjust output position
+        outputs = [p for p in self.outputs if p.isVisible()]
+        if outputs:
+            port_width = outputs[0].boundingRect().width()
+            port_height = outputs[0].boundingRect().height()
+            port_x = width - (port_width / 2)
+            port_x -= 9.0
+            port_y = v_offset
+            for port in outputs:
+                port.setPos(port_x, port_y)
+                port_y += port_height + spacing
+        # adjust output text position
+        for port, text in self._output_items.items():
+            if port.isVisible():
+                txt_width = text.boundingRect().width() - txt_offset
+                txt_x = port.x() - txt_width
+                text.setPos(txt_x, port.y() - 1.5)
+
+    def _align_ports_vertical(self, v_offset):
+        # adjust input position
+        inputs = [p for p in self.inputs if p.isVisible()]
+        if inputs:
+            port_width = inputs[0].boundingRect().width()
+            port_height = inputs[0].boundingRect().height()
+            half_width = port_width / 2
+            delta = self._width / (len(inputs) + 1)
+            port_x = delta
+            port_y = -port_height / 2 + 3.0
+            for port in inputs:
+                port.setPos(port_x - half_width, port_y)
+                port_x += delta
+
+        # adjust output position
+        outputs = [p for p in self.outputs if p.isVisible()]
+        if outputs:
+            port_width = outputs[0].boundingRect().width()
+            port_height = outputs[0].boundingRect().height()
+            half_width = port_width / 2
+            delta = self._width / (len(outputs) + 1)
+            port_x = delta
+            port_y = self._height - (port_height / 2) - 9.0
+            for port in outputs:
+                port.setPos(port_x - half_width, port_y)
+                port_x += delta
+
+    def _draw_node_horizontal(self):
+        height = self._text_item.boundingRect().height()
+
+        # update port text items in visibility.
+        for port, text in self._input_items.items():
+            text.setVisible(port.display_name)
+        for port, text in self._output_items.items():
+            text.setVisible(port.display_name)
+
+        # setup initial base size.
+        self._set_base_size(add_w=8.0, add_h=height + 10)
+        # set text color when node is initialized.
+        self._set_text_color(self.text_color)
+        # set the tooltip
+        self._tooltip_disable(self.disabled)
+
+        # --- set the initial node layout ---
+        # (do all the graphic item layout offsets here)
+
+        # align label text
+        self.align_label()
+        # arrange icon
+        self.align_icon(h_offset=2.0, v_offset=3.0)
+        # arrange input and output ports.
+        self.align_ports(v_offset=height)
+        # arrange node widgets
+        self.align_widgets(v_offset=height)
+
+        self.update()
+
+    def _draw_node_vertical(self):
+        height = self._text_item.boundingRect().height()
+
+        # hide the port text items in vertical layout.
+        for port, text in self._input_items.items():
+            text.setVisible(False)
+        for port, text in self._output_items.items():
+            text.setVisible(False)
+
+        # setup initial base size.
+        self._set_base_size(add_w=8.0)
+        # set text color when node is initialized.
+        self._set_text_color(self.text_color)
+        # set the tooltip
+        self._tooltip_disable(self.disabled)
+
+        # --- set the initial node layout ---
+        # (do all the graphic item layout offsets here)
+
+        # align label text
+        self.align_label(h_offset=7, v_offset=6)
+        # align icon
+        self.align_icon(h_offset=4, v_offset=-2)
+        # arrange input and output ports.
+        self.align_ports(v_offset=height + (height / 2))
+        # arrange node widgets
+        self.align_widgets(v_offset=height / 2)
+
+        self.update()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_overlay_disabled.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_overlay_disabled.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,108 +1,108 @@
-#!/usr/bin/python
-from Qt import QtGui, QtCore, QtWidgets
-
-from NodeGraphQt.constants import Z_VAL_NODE_WIDGET
-
-
-class XDisabledItem(QtWidgets.QGraphicsItem):
-    """
-    Node disabled overlay item.
-
-    Args:
-        parent (NodeItem): the parent node item.
-        text (str): disable overlay text.
-    """
-
-    def __init__(self, parent=None, text=None):
-        super(XDisabledItem, self).__init__(parent)
-        self.setZValue(Z_VAL_NODE_WIDGET + 2)
-        self.setVisible(False)
-        self.proxy_mode = False
-        self.color = (0, 0, 0, 255)
-        self.text = text
-
-    def boundingRect(self):
-        return self.parentItem().boundingRect()
-
-    def paint(self, painter, option, widget):
-        """
-        Draws the overlay disabled X item on top of a node item.
-
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        painter.save()
-
-        margin = 20
-        rect = self.boundingRect()
-        dis_rect = QtCore.QRectF(rect.left() - (margin / 2),
-                                 rect.top() - (margin / 2),
-                                 rect.width() + margin,
-                                 rect.height() + margin)
-        if not self.proxy_mode:
-            pen = QtGui.QPen(QtGui.QColor(*self.color), 8)
-            pen.setCapStyle(QtCore.Qt.RoundCap)
-            painter.setPen(pen)
-            painter.drawLine(dis_rect.topLeft(), dis_rect.bottomRight())
-            painter.drawLine(dis_rect.topRight(), dis_rect.bottomLeft())
-
-        bg_color = QtGui.QColor(*self.color)
-        bg_color.setAlpha(100)
-        bg_margin = -0.5
-        bg_rect = QtCore.QRectF(dis_rect.left() - (bg_margin / 2),
-                                dis_rect.top() - (bg_margin / 2),
-                                dis_rect.width() + bg_margin,
-                                dis_rect.height() + bg_margin)
-        painter.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 0)))
-        painter.setBrush(bg_color)
-        painter.drawRoundedRect(bg_rect, 5, 5)
-
-        if not self.proxy_mode:
-            point_size = 4.0
-            pen = QtGui.QPen(QtGui.QColor(155, 0, 0, 255), 0.7)
-        else:
-            point_size = 8.0
-            pen = QtGui.QPen(QtGui.QColor(155, 0, 0, 255), 4.0)
-
-        painter.setPen(pen)
-        painter.drawLine(dis_rect.topLeft(), dis_rect.bottomRight())
-        painter.drawLine(dis_rect.topRight(), dis_rect.bottomLeft())
-
-        point_pos = (dis_rect.topLeft(), dis_rect.topRight(),
-                     dis_rect.bottomLeft(), dis_rect.bottomRight())
-        painter.setBrush(QtGui.QColor(255, 0, 0, 255))
-        for p in point_pos:
-            p.setX(p.x() - (point_size / 2))
-            p.setY(p.y() - (point_size / 2))
-            point_rect = QtCore.QRectF(
-                p, QtCore.QSizeF(point_size, point_size))
-            painter.drawEllipse(point_rect)
-
-        if self.text and not self.proxy_mode:
-            font = painter.font()
-            font.setPointSize(10)
-
-            painter.setFont(font)
-            font_metrics = QtGui.QFontMetrics(font)
-            font_width = font_metrics.width(self.text)
-            font_height = font_metrics.height()
-            txt_w = font_width * 1.25
-            txt_h = font_height * 2.25
-            text_bg_rect = QtCore.QRectF((rect.width() / 2) - (txt_w / 2),
-                                         (rect.height() / 2) - (txt_h / 2),
-                                         txt_w, txt_h)
-            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0), 0.5))
-            painter.setBrush(QtGui.QColor(*self.color))
-            painter.drawRoundedRect(text_bg_rect, 2, 2)
-
-            text_rect = QtCore.QRectF((rect.width() / 2) - (font_width / 2),
-                                      (rect.height() / 2) - (font_height / 2),
-                                      txt_w * 2, font_height * 2)
-
-            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0), 1))
-            painter.drawText(text_rect, self.text)
-
-        painter.restore()
+#!/usr/bin/python
+from Qt import QtGui, QtCore, QtWidgets
+
+from NodeGraphQt.constants import Z_VAL_NODE_WIDGET
+
+
+class XDisabledItem(QtWidgets.QGraphicsItem):
+    """
+    Node disabled overlay item.
+
+    Args:
+        parent (NodeItem): the parent node item.
+        text (str): disable overlay text.
+    """
+
+    def __init__(self, parent=None, text=None):
+        super(XDisabledItem, self).__init__(parent)
+        self.setZValue(Z_VAL_NODE_WIDGET + 2)
+        self.setVisible(False)
+        self.proxy_mode = False
+        self.color = (0, 0, 0, 255)
+        self.text = text
+
+    def boundingRect(self):
+        return self.parentItem().boundingRect()
+
+    def paint(self, painter, option, widget):
+        """
+        Draws the overlay disabled X item on top of a node item.
+
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        painter.save()
+
+        margin = 20
+        rect = self.boundingRect()
+        dis_rect = QtCore.QRectF(rect.left() - (margin / 2),
+                                 rect.top() - (margin / 2),
+                                 rect.width() + margin,
+                                 rect.height() + margin)
+        if not self.proxy_mode:
+            pen = QtGui.QPen(QtGui.QColor(*self.color), 8)
+            pen.setCapStyle(QtCore.Qt.RoundCap)
+            painter.setPen(pen)
+            painter.drawLine(dis_rect.topLeft(), dis_rect.bottomRight())
+            painter.drawLine(dis_rect.topRight(), dis_rect.bottomLeft())
+
+        bg_color = QtGui.QColor(*self.color)
+        bg_color.setAlpha(100)
+        bg_margin = -0.5
+        bg_rect = QtCore.QRectF(dis_rect.left() - (bg_margin / 2),
+                                dis_rect.top() - (bg_margin / 2),
+                                dis_rect.width() + bg_margin,
+                                dis_rect.height() + bg_margin)
+        painter.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 0)))
+        painter.setBrush(bg_color)
+        painter.drawRoundedRect(bg_rect, 5, 5)
+
+        if not self.proxy_mode:
+            point_size = 4.0
+            pen = QtGui.QPen(QtGui.QColor(155, 0, 0, 255), 0.7)
+        else:
+            point_size = 8.0
+            pen = QtGui.QPen(QtGui.QColor(155, 0, 0, 255), 4.0)
+
+        painter.setPen(pen)
+        painter.drawLine(dis_rect.topLeft(), dis_rect.bottomRight())
+        painter.drawLine(dis_rect.topRight(), dis_rect.bottomLeft())
+
+        point_pos = (dis_rect.topLeft(), dis_rect.topRight(),
+                     dis_rect.bottomLeft(), dis_rect.bottomRight())
+        painter.setBrush(QtGui.QColor(255, 0, 0, 255))
+        for p in point_pos:
+            p.setX(p.x() - (point_size / 2))
+            p.setY(p.y() - (point_size / 2))
+            point_rect = QtCore.QRectF(
+                p, QtCore.QSizeF(point_size, point_size))
+            painter.drawEllipse(point_rect)
+
+        if self.text and not self.proxy_mode:
+            font = painter.font()
+            font.setPointSize(10)
+
+            painter.setFont(font)
+            font_metrics = QtGui.QFontMetrics(font)
+            font_width = font_metrics.width(self.text)
+            font_height = font_metrics.height()
+            txt_w = font_width * 1.25
+            txt_h = font_height * 2.25
+            text_bg_rect = QtCore.QRectF((rect.width() / 2) - (txt_w / 2),
+                                         (rect.height() / 2) - (txt_h / 2),
+                                         txt_w, txt_h)
+            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0), 0.5))
+            painter.setBrush(QtGui.QColor(*self.color))
+            painter.drawRoundedRect(text_bg_rect, 2, 2)
+
+            text_rect = QtCore.QRectF((rect.width() / 2) - (font_width / 2),
+                                      (rect.height() / 2) - (font_height / 2),
+                                      txt_w * 2, font_height * 2)
+
+            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0), 1))
+            painter.drawText(text_rect, self.text)
+
+        painter.restore()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_port_in.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_port_out.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,234 +1,234 @@
-#!/usr/bin/python
-from Qt import QtCore, QtGui, QtWidgets
-
-from NodeGraphQt.constants import NodeEnum
-from NodeGraphQt.qgraphics.node_base import NodeItem
-
-
-class PortInputNodeItem(NodeItem):
-    """
-    Input Port Node item.
-
-    Args:
-        name (str): name displayed on the node.
-        parent (QtWidgets.QGraphicsItem): parent item.
-    """
-
-    def __init__(self, name='group port', parent=None):
-        super(PortInputNodeItem, self).__init__(name, parent)
-        self._icon_item.setVisible(False)
-        self._text_item.set_locked(True)
-        self._x_item.text = 'Port Locked'
-
-    def _set_base_size(self, add_w=0.0, add_h=0.0):
-        width, height = self.calc_size(add_w, add_h)
-        self._width = width + 60
-        self._height = height if height >= 60 else 60
-
-    def _paint_horizontal(self, painter, option, widget):
-        self.auto_switch_mode()
-
-        painter.save()
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtCore.Qt.NoPen)
-
-        margin = 2.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        text_rect = self._text_item.boundingRect()
-        text_rect = QtCore.QRectF(
-            rect.center().x() - (text_rect.width() / 2) - 5,
-            rect.center().y() - (text_rect.height() / 2),
-            text_rect.width() + 10,
-            text_rect.height()
-        )
-
-        painter.setBrush(QtGui.QColor(255, 255, 255, 20))
-        painter.drawRoundedRect(rect, 20, 20)
-
-        painter.setBrush(QtGui.QColor(0, 0, 0, 100))
-        painter.drawRoundedRect(text_rect, 3, 3)
-
-        size = int(rect.height() / 4)
-        triangle = QtGui.QPolygonF()
-        triangle.append(QtCore.QPointF(-size, size))
-        triangle.append(QtCore.QPointF(0.0, 0.0))
-        triangle.append(QtCore.QPointF(size, size))
-
-        transform = QtGui.QTransform()
-        transform.translate(rect.width() - (size / 6), rect.center().y())
-        transform.rotate(90)
-        poly = transform.map(triangle)
-
-        if self.selected:
-            pen = QtGui.QPen(
-                QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value), 1.3
-            )
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            pen = QtGui.QPen(QtGui.QColor(*self.border_color), 1.2)
-            painter.setBrush(QtGui.QColor(0, 0, 0, 50))
-
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        painter.setPen(pen)
-        painter.drawPolygon(poly)
-
-        edge_size = 30
-        edge_rect = QtCore.QRectF(rect.width() - (size * 1.7),
-                                  rect.center().y() - (edge_size / 2),
-                                  4, edge_size)
-        painter.drawRect(edge_rect)
-
-        painter.restore()
-
-    def _paint_vertical(self, painter, option, widget):
-        self.auto_switch_mode()
-
-        painter.save()
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtCore.Qt.NoPen)
-
-        margin = 2.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        text_rect = self._text_item.boundingRect()
-        text_rect = QtCore.QRectF(
-            rect.center().x() - (text_rect.width() / 2) - 5,
-            rect.top() + margin,
-            text_rect.width() + 10,
-            text_rect.height()
-        )
-
-        painter.setBrush(QtGui.QColor(255, 255, 255, 20))
-        painter.drawRoundedRect(rect, 20, 20)
-
-        painter.setBrush(QtGui.QColor(0, 0, 0, 100))
-        painter.drawRoundedRect(text_rect, 3, 3)
-
-        size = int(rect.height() / 4)
-        triangle = QtGui.QPolygonF()
-        triangle.append(QtCore.QPointF(-size, size))
-        triangle.append(QtCore.QPointF(0.0, 0.0))
-        triangle.append(QtCore.QPointF(size, size))
-
-        transform = QtGui.QTransform()
-        transform.translate(rect.center().x(), rect.bottom() - (size / 3))
-        transform.rotate(180)
-        poly = transform.map(triangle)
-
-        if self.selected:
-            pen = QtGui.QPen(
-                QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value), 1.3
-            )
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            pen = QtGui.QPen(QtGui.QColor(*self.border_color), 1.2)
-            painter.setBrush(QtGui.QColor(0, 0, 0, 50))
-
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        painter.setPen(pen)
-        painter.drawPolygon(poly)
-
-        edge_size = 30
-        edge_rect = QtCore.QRectF(rect.center().x() - (edge_size / 2),
-                                  rect.bottom() - (size * 1.9),
-                                  edge_size, 4)
-        painter.drawRect(edge_rect)
-
-        painter.restore()
-
-    def set_proxy_mode(self, mode):
-        """
-        Set whether to draw the node with proxy mode.
-        (proxy mode toggles visibility for some qgraphic items in the node.)
-
-        Args:
-            mode (bool): true to enable proxy mode.
-        """
-        if mode is self._proxy_mode:
-            return
-        self._proxy_mode = mode
-
-        visible = not mode
-
-        # disable overlay item.
-        self._x_item.proxy_mode = self._proxy_mode
-
-        # node widget visibility.
-        for w in self._widgets.values():
-            w.widget().setVisible(visible)
-
-        # input port text visibility.
-        for port, text in self._input_items.items():
-            if port.display_name:
-                text.setVisible(visible)
-
-        # output port text visibility.
-        for port, text in self._output_items.items():
-            if port.display_name:
-                text.setVisible(visible)
-
-        self._text_item.setVisible(visible)
-
-    def _align_label_horizontal(self, h_offset, v_offset):
-        rect = self.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = rect.center().x() - (text_rect.width() / 2)
-        y = rect.center().y() - (text_rect.height() / 2)
-        self._text_item.setPos(x + h_offset, y + v_offset)
-
-    def _align_label_vertical(self, h_offset, v_offset):
-        rect = self.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = rect.center().x() - (text_rect.width() / 1.5) - 2.0
-        y = rect.center().y() - text_rect.height() - 2.0
-        self._text_item.setPos(x + h_offset, y + v_offset)
-
-    def _align_ports_horizontal(self, v_offset):
-        """
-        Align input, output ports in the node layout.
-        """
-        v_offset = self.boundingRect().height() / 2
-        if self.inputs or self.outputs:
-            for ports in [self.inputs, self.outputs]:
-                if ports:
-                    v_offset -= ports[0].boundingRect().height() / 2
-                    break
-        super(PortInputNodeItem, self)._align_ports_horizontal(v_offset)
-
-    def _align_ports_vertical(self, v_offset):
-        super(PortInputNodeItem, self)._align_ports_vertical(v_offset)
-
-    def _draw_node_horizontal(self):
-        """
-        Re-draw the node item in the scene.
-        (re-implemented for vertical layout design)
-        """
-        # setup initial base size.
-        self._set_base_size()
-        # set text color when node is initialized.
-        self._set_text_color(self.text_color)
-        # set the tooltip
-        self._tooltip_disable(self.disabled)
-
-        # --- set the initial node layout ---
-        # (do all the graphic item layout offsets here)
-
-        # align label text
-        self.align_label()
-        # arrange icon
-        self.align_icon()
-        # arrange input and output ports.
-        self.align_ports()
-        # arrange node widgets
-        self.align_widgets()
-
-        self.update()
+#!/usr/bin/python
+from Qt import QtCore, QtGui, QtWidgets
+
+from NodeGraphQt.constants import NodeEnum
+from NodeGraphQt.qgraphics.node_base import NodeItem
+
+
+class PortOutputNodeItem(NodeItem):
+    """
+    Output Port Node item.
+
+    Args:
+        name (str): name displayed on the node.
+        parent (QtWidgets.QGraphicsItem): parent item.
+    """
+
+    def __init__(self, name='group port', parent=None):
+        super(PortOutputNodeItem, self).__init__(name, parent)
+        self._icon_item.setVisible(False)
+        self._text_item.set_locked(True)
+        self._x_item.text = 'Port Locked'
+
+    def _set_base_size(self, add_w=0.0, add_h=0.0):
+        width, height = self.calc_size(add_w, add_h)
+        self._width = width + 60
+        self._height = height if height >= 60 else 60
+
+    def _paint_horizontal(self, painter, option, widget):
+        self.auto_switch_mode()
+
+        painter.save()
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtCore.Qt.NoPen)
+
+        margin = 2.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        text_rect = self._text_item.boundingRect()
+        text_rect = QtCore.QRectF(
+            rect.center().x() - (text_rect.width() / 2) - 5,
+            rect.center().y() - (text_rect.height() / 2),
+            text_rect.width() + 10,
+            text_rect.height()
+        )
+
+        painter.setBrush(QtGui.QColor(255, 255, 255, 20))
+        painter.drawRoundedRect(rect, 20, 20)
+
+        painter.setBrush(QtGui.QColor(0, 0, 0, 100))
+        painter.drawRoundedRect(text_rect, 3, 3)
+
+        size = int(rect.height() / 4)
+        triangle = QtGui.QPolygonF()
+        triangle.append(QtCore.QPointF(-size, size))
+        triangle.append(QtCore.QPointF(0.0, 0.0))
+        triangle.append(QtCore.QPointF(size, size))
+
+        transform = QtGui.QTransform()
+        transform.translate(rect.x() + (size / 3), rect.center().y())
+        transform.rotate(-90)
+        poly = transform.map(triangle)
+
+        if self.selected:
+            pen = QtGui.QPen(
+                QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value), 1.3
+            )
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            pen = QtGui.QPen(QtGui.QColor(*self.border_color), 1.2)
+            painter.setBrush(QtGui.QColor(0, 0, 0, 50))
+
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        painter.setPen(pen)
+        painter.drawPolygon(poly)
+
+        edge_size = 30
+        edge_rect = QtCore.QRectF(rect.x() + (size * 1.6),
+                                  rect.center().y() - (edge_size / 2),
+                                  4, edge_size)
+        painter.drawRect(edge_rect)
+
+        painter.restore()
+
+    def _paint_vertical(self, painter, option, widget):
+        self.auto_switch_mode()
+
+        painter.save()
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtCore.Qt.NoPen)
+
+        margin = 2.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        text_rect = self._text_item.boundingRect()
+        text_rect = QtCore.QRectF(
+            rect.center().x() - (text_rect.width() / 2) - 5,
+            rect.height() - text_rect.height(),
+            text_rect.width() + 10,
+            text_rect.height()
+        )
+
+        painter.setBrush(QtGui.QColor(255, 255, 255, 20))
+        painter.drawRoundedRect(rect, 20, 20)
+
+        painter.setBrush(QtGui.QColor(0, 0, 0, 100))
+        painter.drawRoundedRect(text_rect, 3, 3)
+
+        size = int(rect.height() / 4)
+        triangle = QtGui.QPolygonF()
+        triangle.append(QtCore.QPointF(-size, size))
+        triangle.append(QtCore.QPointF(0.0, 0.0))
+        triangle.append(QtCore.QPointF(size, size))
+
+        transform = QtGui.QTransform()
+        transform.translate(rect.center().x(), rect.y() + (size / 3))
+        # transform.rotate(-90)
+        poly = transform.map(triangle)
+
+        if self.selected:
+            pen = QtGui.QPen(
+                QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value), 1.3
+            )
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            pen = QtGui.QPen(QtGui.QColor(*self.border_color), 1.2)
+            painter.setBrush(QtGui.QColor(0, 0, 0, 50))
+
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        painter.setPen(pen)
+        painter.drawPolygon(poly)
+
+        edge_size = 30
+        edge_rect = QtCore.QRectF(rect.center().x() - (edge_size / 2),
+                                  rect.y() + (size * 1.6),
+                                  edge_size, 4)
+        painter.drawRect(edge_rect)
+
+        painter.restore()
+
+    def set_proxy_mode(self, mode):
+        """
+        Set whether to draw the node with proxy mode.
+        (proxy mode toggles visibility for some qgraphic items in the node.)
+
+        Args:
+            mode (bool): true to enable proxy mode.
+        """
+        if mode is self._proxy_mode:
+            return
+        self._proxy_mode = mode
+
+        visible = not mode
+
+        # disable overlay item.
+        self._x_item.proxy_mode = self._proxy_mode
+
+        # node widget visibility.
+        for w in self._widgets.values():
+            w.widget().setVisible(visible)
+
+        # input port text visibility.
+        for port, text in self._input_items.items():
+            if port.display_name:
+                text.setVisible(visible)
+
+        # output port text visibility.
+        for port, text in self._output_items.items():
+            if port.display_name:
+                text.setVisible(visible)
+
+        self._text_item.setVisible(visible)
+
+    def _align_label_horizontal(self, h_offset, v_offset):
+        rect = self.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = rect.center().x() - (text_rect.width() / 2)
+        y = rect.center().y() - (text_rect.height() / 2)
+        self._text_item.setPos(x + h_offset, y + v_offset)
+
+    def _align_label_vertical(self, h_offset, v_offset):
+        rect = self.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = rect.center().x() - (text_rect.width() / 1.5) - 2.0
+        y = rect.height() - text_rect.height() - 4.0
+        self._text_item.setPos(x + h_offset, y + v_offset)
+
+    def _align_ports_horizontal(self, v_offset):
+        """
+        Align input, output ports in the node layout.
+        """
+        v_offset = self.boundingRect().height() / 2
+        if self.inputs or self.outputs:
+            for ports in [self.inputs, self.outputs]:
+                if ports:
+                    v_offset -= ports[0].boundingRect().height() / 2
+                    break
+        super(PortOutputNodeItem, self)._align_ports_horizontal(v_offset)
+
+    def _align_ports_vertical(self, v_offset):
+        super(PortOutputNodeItem, self)._align_ports_vertical(v_offset)
+
+    def _draw_node_horizontal(self):
+        """
+        Re-draw the node item in the scene.
+        (re-implemented for vertical layout design)
+        """
+        # setup initial base size.
+        self._set_base_size()
+        # set text color when node is initialized.
+        self._set_text_color(self.text_color)
+        # set the tooltip
+        self._tooltip_disable(self.disabled)
+
+        # --- set the initial node layout ---
+        # (do all the graphic item layout offsets here)
+
+        # align label text
+        self.align_label()
+        # align icon
+        self.align_icon()
+        # arrange input and output ports.
+        self.align_ports()
+        # arrange node widgets
+        self.align_widgets()
+
+        self.update()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_port_out.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_port_in.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,234 +1,234 @@
-#!/usr/bin/python
-from Qt import QtCore, QtGui, QtWidgets
-
-from NodeGraphQt.constants import NodeEnum
-from NodeGraphQt.qgraphics.node_base import NodeItem
-
-
-class PortOutputNodeItem(NodeItem):
-    """
-    Output Port Node item.
-
-    Args:
-        name (str): name displayed on the node.
-        parent (QtWidgets.QGraphicsItem): parent item.
-    """
-
-    def __init__(self, name='group port', parent=None):
-        super(PortOutputNodeItem, self).__init__(name, parent)
-        self._icon_item.setVisible(False)
-        self._text_item.set_locked(True)
-        self._x_item.text = 'Port Locked'
-
-    def _set_base_size(self, add_w=0.0, add_h=0.0):
-        width, height = self.calc_size(add_w, add_h)
-        self._width = width + 60
-        self._height = height if height >= 60 else 60
-
-    def _paint_horizontal(self, painter, option, widget):
-        self.auto_switch_mode()
-
-        painter.save()
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtCore.Qt.NoPen)
-
-        margin = 2.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        text_rect = self._text_item.boundingRect()
-        text_rect = QtCore.QRectF(
-            rect.center().x() - (text_rect.width() / 2) - 5,
-            rect.center().y() - (text_rect.height() / 2),
-            text_rect.width() + 10,
-            text_rect.height()
-        )
-
-        painter.setBrush(QtGui.QColor(255, 255, 255, 20))
-        painter.drawRoundedRect(rect, 20, 20)
-
-        painter.setBrush(QtGui.QColor(0, 0, 0, 100))
-        painter.drawRoundedRect(text_rect, 3, 3)
-
-        size = int(rect.height() / 4)
-        triangle = QtGui.QPolygonF()
-        triangle.append(QtCore.QPointF(-size, size))
-        triangle.append(QtCore.QPointF(0.0, 0.0))
-        triangle.append(QtCore.QPointF(size, size))
-
-        transform = QtGui.QTransform()
-        transform.translate(rect.x() + (size / 3), rect.center().y())
-        transform.rotate(-90)
-        poly = transform.map(triangle)
-
-        if self.selected:
-            pen = QtGui.QPen(
-                QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value), 1.3
-            )
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            pen = QtGui.QPen(QtGui.QColor(*self.border_color), 1.2)
-            painter.setBrush(QtGui.QColor(0, 0, 0, 50))
-
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        painter.setPen(pen)
-        painter.drawPolygon(poly)
-
-        edge_size = 30
-        edge_rect = QtCore.QRectF(rect.x() + (size * 1.6),
-                                  rect.center().y() - (edge_size / 2),
-                                  4, edge_size)
-        painter.drawRect(edge_rect)
-
-        painter.restore()
-
-    def _paint_vertical(self, painter, option, widget):
-        self.auto_switch_mode()
-
-        painter.save()
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setPen(QtCore.Qt.NoPen)
-
-        margin = 2.0
-        rect = self.boundingRect()
-        rect = QtCore.QRectF(rect.left() + margin,
-                             rect.top() + margin,
-                             rect.width() - (margin * 2),
-                             rect.height() - (margin * 2))
-
-        text_rect = self._text_item.boundingRect()
-        text_rect = QtCore.QRectF(
-            rect.center().x() - (text_rect.width() / 2) - 5,
-            rect.height() - text_rect.height(),
-            text_rect.width() + 10,
-            text_rect.height()
-        )
-
-        painter.setBrush(QtGui.QColor(255, 255, 255, 20))
-        painter.drawRoundedRect(rect, 20, 20)
-
-        painter.setBrush(QtGui.QColor(0, 0, 0, 100))
-        painter.drawRoundedRect(text_rect, 3, 3)
-
-        size = int(rect.height() / 4)
-        triangle = QtGui.QPolygonF()
-        triangle.append(QtCore.QPointF(-size, size))
-        triangle.append(QtCore.QPointF(0.0, 0.0))
-        triangle.append(QtCore.QPointF(size, size))
-
-        transform = QtGui.QTransform()
-        transform.translate(rect.center().x(), rect.y() + (size / 3))
-        # transform.rotate(-90)
-        poly = transform.map(triangle)
-
-        if self.selected:
-            pen = QtGui.QPen(
-                QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value), 1.3
-            )
-            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
-        else:
-            pen = QtGui.QPen(QtGui.QColor(*self.border_color), 1.2)
-            painter.setBrush(QtGui.QColor(0, 0, 0, 50))
-
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        painter.setPen(pen)
-        painter.drawPolygon(poly)
-
-        edge_size = 30
-        edge_rect = QtCore.QRectF(rect.center().x() - (edge_size / 2),
-                                  rect.y() + (size * 1.6),
-                                  edge_size, 4)
-        painter.drawRect(edge_rect)
-
-        painter.restore()
-
-    def set_proxy_mode(self, mode):
-        """
-        Set whether to draw the node with proxy mode.
-        (proxy mode toggles visibility for some qgraphic items in the node.)
-
-        Args:
-            mode (bool): true to enable proxy mode.
-        """
-        if mode is self._proxy_mode:
-            return
-        self._proxy_mode = mode
-
-        visible = not mode
-
-        # disable overlay item.
-        self._x_item.proxy_mode = self._proxy_mode
-
-        # node widget visibility.
-        for w in self._widgets.values():
-            w.widget().setVisible(visible)
-
-        # input port text visibility.
-        for port, text in self._input_items.items():
-            if port.display_name:
-                text.setVisible(visible)
-
-        # output port text visibility.
-        for port, text in self._output_items.items():
-            if port.display_name:
-                text.setVisible(visible)
-
-        self._text_item.setVisible(visible)
-
-    def _align_label_horizontal(self, h_offset, v_offset):
-        rect = self.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = rect.center().x() - (text_rect.width() / 2)
-        y = rect.center().y() - (text_rect.height() / 2)
-        self._text_item.setPos(x + h_offset, y + v_offset)
-
-    def _align_label_vertical(self, h_offset, v_offset):
-        rect = self.boundingRect()
-        text_rect = self._text_item.boundingRect()
-        x = rect.center().x() - (text_rect.width() / 1.5) - 2.0
-        y = rect.height() - text_rect.height() - 4.0
-        self._text_item.setPos(x + h_offset, y + v_offset)
-
-    def _align_ports_horizontal(self, v_offset):
-        """
-        Align input, output ports in the node layout.
-        """
-        v_offset = self.boundingRect().height() / 2
-        if self.inputs or self.outputs:
-            for ports in [self.inputs, self.outputs]:
-                if ports:
-                    v_offset -= ports[0].boundingRect().height() / 2
-                    break
-        super(PortOutputNodeItem, self)._align_ports_horizontal(v_offset)
-
-    def _align_ports_vertical(self, v_offset):
-        super(PortOutputNodeItem, self)._align_ports_vertical(v_offset)
-
-    def _draw_node_horizontal(self):
-        """
-        Re-draw the node item in the scene.
-        (re-implemented for vertical layout design)
-        """
-        # setup initial base size.
-        self._set_base_size()
-        # set text color when node is initialized.
-        self._set_text_color(self.text_color)
-        # set the tooltip
-        self._tooltip_disable(self.disabled)
-
-        # --- set the initial node layout ---
-        # (do all the graphic item layout offsets here)
-
-        # align label text
-        self.align_label()
-        # align icon
-        self.align_icon()
-        # arrange input and output ports.
-        self.align_ports()
-        # arrange node widgets
-        self.align_widgets()
-
-        self.update()
+#!/usr/bin/python
+from Qt import QtCore, QtGui, QtWidgets
+
+from NodeGraphQt.constants import NodeEnum
+from NodeGraphQt.qgraphics.node_base import NodeItem
+
+
+class PortInputNodeItem(NodeItem):
+    """
+    Input Port Node item.
+
+    Args:
+        name (str): name displayed on the node.
+        parent (QtWidgets.QGraphicsItem): parent item.
+    """
+
+    def __init__(self, name='group port', parent=None):
+        super(PortInputNodeItem, self).__init__(name, parent)
+        self._icon_item.setVisible(False)
+        self._text_item.set_locked(True)
+        self._x_item.text = 'Port Locked'
+
+    def _set_base_size(self, add_w=0.0, add_h=0.0):
+        width, height = self.calc_size(add_w, add_h)
+        self._width = width + 60
+        self._height = height if height >= 60 else 60
+
+    def _paint_horizontal(self, painter, option, widget):
+        self.auto_switch_mode()
+
+        painter.save()
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtCore.Qt.NoPen)
+
+        margin = 2.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        text_rect = self._text_item.boundingRect()
+        text_rect = QtCore.QRectF(
+            rect.center().x() - (text_rect.width() / 2) - 5,
+            rect.center().y() - (text_rect.height() / 2),
+            text_rect.width() + 10,
+            text_rect.height()
+        )
+
+        painter.setBrush(QtGui.QColor(255, 255, 255, 20))
+        painter.drawRoundedRect(rect, 20, 20)
+
+        painter.setBrush(QtGui.QColor(0, 0, 0, 100))
+        painter.drawRoundedRect(text_rect, 3, 3)
+
+        size = int(rect.height() / 4)
+        triangle = QtGui.QPolygonF()
+        triangle.append(QtCore.QPointF(-size, size))
+        triangle.append(QtCore.QPointF(0.0, 0.0))
+        triangle.append(QtCore.QPointF(size, size))
+
+        transform = QtGui.QTransform()
+        transform.translate(rect.width() - (size / 6), rect.center().y())
+        transform.rotate(90)
+        poly = transform.map(triangle)
+
+        if self.selected:
+            pen = QtGui.QPen(
+                QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value), 1.3
+            )
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            pen = QtGui.QPen(QtGui.QColor(*self.border_color), 1.2)
+            painter.setBrush(QtGui.QColor(0, 0, 0, 50))
+
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        painter.setPen(pen)
+        painter.drawPolygon(poly)
+
+        edge_size = 30
+        edge_rect = QtCore.QRectF(rect.width() - (size * 1.7),
+                                  rect.center().y() - (edge_size / 2),
+                                  4, edge_size)
+        painter.drawRect(edge_rect)
+
+        painter.restore()
+
+    def _paint_vertical(self, painter, option, widget):
+        self.auto_switch_mode()
+
+        painter.save()
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setPen(QtCore.Qt.NoPen)
+
+        margin = 2.0
+        rect = self.boundingRect()
+        rect = QtCore.QRectF(rect.left() + margin,
+                             rect.top() + margin,
+                             rect.width() - (margin * 2),
+                             rect.height() - (margin * 2))
+
+        text_rect = self._text_item.boundingRect()
+        text_rect = QtCore.QRectF(
+            rect.center().x() - (text_rect.width() / 2) - 5,
+            rect.top() + margin,
+            text_rect.width() + 10,
+            text_rect.height()
+        )
+
+        painter.setBrush(QtGui.QColor(255, 255, 255, 20))
+        painter.drawRoundedRect(rect, 20, 20)
+
+        painter.setBrush(QtGui.QColor(0, 0, 0, 100))
+        painter.drawRoundedRect(text_rect, 3, 3)
+
+        size = int(rect.height() / 4)
+        triangle = QtGui.QPolygonF()
+        triangle.append(QtCore.QPointF(-size, size))
+        triangle.append(QtCore.QPointF(0.0, 0.0))
+        triangle.append(QtCore.QPointF(size, size))
+
+        transform = QtGui.QTransform()
+        transform.translate(rect.center().x(), rect.bottom() - (size / 3))
+        transform.rotate(180)
+        poly = transform.map(triangle)
+
+        if self.selected:
+            pen = QtGui.QPen(
+                QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value), 1.3
+            )
+            painter.setBrush(QtGui.QColor(*NodeEnum.SELECTED_COLOR.value))
+        else:
+            pen = QtGui.QPen(QtGui.QColor(*self.border_color), 1.2)
+            painter.setBrush(QtGui.QColor(0, 0, 0, 50))
+
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        painter.setPen(pen)
+        painter.drawPolygon(poly)
+
+        edge_size = 30
+        edge_rect = QtCore.QRectF(rect.center().x() - (edge_size / 2),
+                                  rect.bottom() - (size * 1.9),
+                                  edge_size, 4)
+        painter.drawRect(edge_rect)
+
+        painter.restore()
+
+    def set_proxy_mode(self, mode):
+        """
+        Set whether to draw the node with proxy mode.
+        (proxy mode toggles visibility for some qgraphic items in the node.)
+
+        Args:
+            mode (bool): true to enable proxy mode.
+        """
+        if mode is self._proxy_mode:
+            return
+        self._proxy_mode = mode
+
+        visible = not mode
+
+        # disable overlay item.
+        self._x_item.proxy_mode = self._proxy_mode
+
+        # node widget visibility.
+        for w in self._widgets.values():
+            w.widget().setVisible(visible)
+
+        # input port text visibility.
+        for port, text in self._input_items.items():
+            if port.display_name:
+                text.setVisible(visible)
+
+        # output port text visibility.
+        for port, text in self._output_items.items():
+            if port.display_name:
+                text.setVisible(visible)
+
+        self._text_item.setVisible(visible)
+
+    def _align_label_horizontal(self, h_offset, v_offset):
+        rect = self.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = rect.center().x() - (text_rect.width() / 2)
+        y = rect.center().y() - (text_rect.height() / 2)
+        self._text_item.setPos(x + h_offset, y + v_offset)
+
+    def _align_label_vertical(self, h_offset, v_offset):
+        rect = self.boundingRect()
+        text_rect = self._text_item.boundingRect()
+        x = rect.center().x() - (text_rect.width() / 1.5) - 2.0
+        y = rect.center().y() - text_rect.height() - 2.0
+        self._text_item.setPos(x + h_offset, y + v_offset)
+
+    def _align_ports_horizontal(self, v_offset):
+        """
+        Align input, output ports in the node layout.
+        """
+        v_offset = self.boundingRect().height() / 2
+        if self.inputs or self.outputs:
+            for ports in [self.inputs, self.outputs]:
+                if ports:
+                    v_offset -= ports[0].boundingRect().height() / 2
+                    break
+        super(PortInputNodeItem, self)._align_ports_horizontal(v_offset)
+
+    def _align_ports_vertical(self, v_offset):
+        super(PortInputNodeItem, self)._align_ports_vertical(v_offset)
+
+    def _draw_node_horizontal(self):
+        """
+        Re-draw the node item in the scene.
+        (re-implemented for vertical layout design)
+        """
+        # setup initial base size.
+        self._set_base_size()
+        # set text color when node is initialized.
+        self._set_text_color(self.text_color)
+        # set the tooltip
+        self._tooltip_disable(self.disabled)
+
+        # --- set the initial node layout ---
+        # (do all the graphic item layout offsets here)
+
+        # align label text
+        self.align_label()
+        # arrange icon
+        self.align_icon()
+        # arrange input and output ports.
+        self.align_ports()
+        # arrange node widgets
+        self.align_widgets()
+
+        self.update()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/node_text_item.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/node_text_item.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,117 +1,117 @@
-from Qt import QtWidgets, QtCore, QtGui
-
-
-class NodeTextItem(QtWidgets.QGraphicsTextItem):
-    """
-    NodeTextItem class used to display and edit the name of a NodeItem.
-    """
-
-    def __init__(self, text, parent=None):
-        super(NodeTextItem, self).__init__(text, parent)
-        self._locked = False
-        self.set_locked(False)
-        self.set_editable(False)
-
-    def mouseDoubleClickEvent(self, event):
-        """
-        Re-implemented to jump into edit mode when user clicks on node text.
-
-        Args:
-            event (QtWidgets.QGraphicsSceneMouseEvent): mouse event.
-        """
-        if not self._locked:
-            if event.button() == QtCore.Qt.LeftButton:
-                self.set_editable(True)
-                event.ignore()
-                return
-        super(NodeTextItem, self).mouseDoubleClickEvent(event)
-
-    def keyPressEvent(self, event):
-        """
-        Re-implemented to catch the Return & Escape keys when in edit mode.
-
-        Args:
-            event (QtGui.QKeyEvent): key event.
-        """
-        if event.key() == QtCore.Qt.Key_Return:
-            current_text = self.toPlainText()
-            self.set_node_name(current_text)
-            self.set_editable(False)
-        elif event.key() == QtCore.Qt.Key_Escape:
-            self.setPlainText(self.node.name)
-            self.set_editable(False)
-        super(NodeTextItem, self).keyPressEvent(event)
-
-    def focusOutEvent(self, event):
-        """
-        Re-implemented to jump out of edit mode.
-
-        Args:
-            event (QtGui.QFocusEvent):
-        """
-        current_text = self.toPlainText()
-        self.set_node_name(current_text)
-        self.set_editable(False)
-        super(NodeTextItem, self).focusOutEvent(event)
-
-    def set_editable(self, value=False):
-        """
-        Set the edit mode for the text item.
-
-        Args:
-            value (bool):  true in edit mode.
-        """
-        if self._locked:
-            return
-        if value:
-            self.setTextInteractionFlags(
-                QtCore.Qt.TextEditable |
-                QtCore.Qt.TextSelectableByMouse |
-                QtCore.Qt.TextSelectableByKeyboard
-            )
-        else:
-            self.setTextInteractionFlags(QtCore.Qt.NoTextInteraction)
-            cursor = self.textCursor()
-            cursor.clearSelection()
-            self.setTextCursor(cursor)
-
-    def set_node_name(self, name):
-        """
-        Updates the node name through the node "NodeViewer().node_name_changed"
-        signal which then updates the node name through the BaseNode object this
-        will register it as an undo command.
-
-        Args:
-            name (str): new node name.
-        """
-        name = name.strip()
-        if name != self.node.name:
-            viewer = self.node.viewer()
-            viewer.node_name_changed.emit(self.node.id, name)
-
-    def set_locked(self, state=False):
-        """
-        Locks the text item so it can not be editable.
-
-        Args:
-            state (bool): lock state.
-        """
-        self._locked = state
-        if self._locked:
-            self.setFlag(QtWidgets.QGraphicsItem.ItemIsFocusable, False)
-            self.setCursor(QtCore.Qt.ArrowCursor)
-            self.setToolTip('')
-        else:
-            self.setFlag(QtWidgets.QGraphicsItem.ItemIsFocusable, True)
-            self.setToolTip('double-click to edit node name.')
-            self.setCursor(QtCore.Qt.IBeamCursor)
-
-    @property
-    def node(self):
-        """
-        Get the parent node item.
-
-        Returns:
-            NodeItem: parent node qgraphics item.
-        """
-        return self.parentItem()
+from Qt import QtWidgets, QtCore, QtGui
+
+
+class NodeTextItem(QtWidgets.QGraphicsTextItem):
+    """
+    NodeTextItem class used to display and edit the name of a NodeItem.
+    """
+
+    def __init__(self, text, parent=None):
+        super(NodeTextItem, self).__init__(text, parent)
+        self._locked = False
+        self.set_locked(False)
+        self.set_editable(False)
+
+    def mouseDoubleClickEvent(self, event):
+        """
+        Re-implemented to jump into edit mode when user clicks on node text.
+
+        Args:
+            event (QtWidgets.QGraphicsSceneMouseEvent): mouse event.
+        """
+        if not self._locked:
+            if event.button() == QtCore.Qt.LeftButton:
+                self.set_editable(True)
+                event.ignore()
+                return
+        super(NodeTextItem, self).mouseDoubleClickEvent(event)
+
+    def keyPressEvent(self, event):
+        """
+        Re-implemented to catch the Return & Escape keys when in edit mode.
+
+        Args:
+            event (QtGui.QKeyEvent): key event.
+        """
+        if event.key() == QtCore.Qt.Key_Return:
+            current_text = self.toPlainText()
+            self.set_node_name(current_text)
+            self.set_editable(False)
+        elif event.key() == QtCore.Qt.Key_Escape:
+            self.setPlainText(self.node.name)
+            self.set_editable(False)
+        super(NodeTextItem, self).keyPressEvent(event)
+
+    def focusOutEvent(self, event):
+        """
+        Re-implemented to jump out of edit mode.
+
+        Args:
+            event (QtGui.QFocusEvent):
+        """
+        current_text = self.toPlainText()
+        self.set_node_name(current_text)
+        self.set_editable(False)
+        super(NodeTextItem, self).focusOutEvent(event)
+
+    def set_editable(self, value=False):
+        """
+        Set the edit mode for the text item.
+
+        Args:
+            value (bool):  true in edit mode.
+        """
+        if self._locked:
+            return
+        if value:
+            self.setTextInteractionFlags(
+                QtCore.Qt.TextEditable |
+                QtCore.Qt.TextSelectableByMouse |
+                QtCore.Qt.TextSelectableByKeyboard
+            )
+        else:
+            self.setTextInteractionFlags(QtCore.Qt.NoTextInteraction)
+            cursor = self.textCursor()
+            cursor.clearSelection()
+            self.setTextCursor(cursor)
+
+    def set_node_name(self, name):
+        """
+        Updates the node name through the node "NodeViewer().node_name_changed"
+        signal which then updates the node name through the BaseNode object this
+        will register it as an undo command.
+
+        Args:
+            name (str): new node name.
+        """
+        name = name.strip()
+        if name != self.node.name:
+            viewer = self.node.viewer()
+            viewer.node_name_changed.emit(self.node.id, name)
+
+    def set_locked(self, state=False):
+        """
+        Locks the text item so it can not be editable.
+
+        Args:
+            state (bool): lock state.
+        """
+        self._locked = state
+        if self._locked:
+            self.setFlag(QtWidgets.QGraphicsItem.ItemIsFocusable, False)
+            self.setCursor(QtCore.Qt.ArrowCursor)
+            self.setToolTip('')
+        else:
+            self.setFlag(QtWidgets.QGraphicsItem.ItemIsFocusable, True)
+            self.setToolTip('double-click to edit node name.')
+            self.setCursor(QtCore.Qt.IBeamCursor)
+
+    @property
+    def node(self):
+        """
+        Get the parent node item.
+
+        Returns:
+            NodeItem: parent node qgraphics item.
+        """
+        return self.parentItem()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/pipe.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/pipe.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,666 +1,666 @@
-#!/usr/bin/python
-import math
-
-from Qt import QtCore, QtGui, QtWidgets
-
-from NodeGraphQt.constants import (
-    LayoutDirectionEnum,
-    PipeEnum,
-    PipeLayoutEnum,
-    PortTypeEnum,
-    ITEM_CACHE_MODE,
-    Z_VAL_PIPE,
-    Z_VAL_NODE_WIDGET
-)
-from NodeGraphQt.qgraphics.port import PortItem
-
-PIPE_STYLES = {
-    PipeEnum.DRAW_TYPE_DEFAULT.value: QtCore.Qt.SolidLine,
-    PipeEnum.DRAW_TYPE_DASHED.value: QtCore.Qt.DashLine,
-    PipeEnum.DRAW_TYPE_DOTTED.value: QtCore.Qt.DotLine
-}
-
-
-class PipeItem(QtWidgets.QGraphicsPathItem):
-    """
-    Base Pipe item used for drawing node connections.
-    """
-
-    def __init__(self, input_port=None, output_port=None):
-        super(PipeItem, self).__init__()
-        self.setZValue(Z_VAL_PIPE)
-        self.setAcceptHoverEvents(True)
-        self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable)
-        self.setCacheMode(ITEM_CACHE_MODE)
-
-        self._color = PipeEnum.COLOR.value
-        self._style = PipeEnum.DRAW_TYPE_DEFAULT.value
-        self._active = False
-        self._highlight = False
-        self._input_port = input_port
-        self._output_port = output_port
-
-        size = 6.0
-        self._poly = QtGui.QPolygonF()
-        self._poly.append(QtCore.QPointF(-size, size))
-        self._poly.append(QtCore.QPointF(0.0, -size * 1.5))
-        self._poly.append(QtCore.QPointF(size, size))
-
-        self._dir_pointer = QtWidgets.QGraphicsPolygonItem(self)
-        self._dir_pointer.setPolygon(self._poly)
-        self._dir_pointer.setFlag(self.ItemIsSelectable, False)
-
-        self.reset()
-
-    def __repr__(self):
-        in_name = self._input_port.name if self._input_port else ''
-        out_name = self._output_port.name if self._output_port else ''
-        return '{}.Pipe(\'{}\', \'{}\')'.format(
-            self.__module__, in_name, out_name)
-
-    def hoverEnterEvent(self, event):
-        self.activate()
-
-    def hoverLeaveEvent(self, event):
-        self.reset()
-        if self.input_port and self.output_port:
-            if self.input_port.node.selected:
-                self.highlight()
-            elif self.output_port.node.selected:
-                self.highlight()
-        if self.isSelected():
-            self.highlight()
-
-    def itemChange(self, change, value):
-        if change == self.ItemSelectedChange and self.scene():
-            if value:
-                self.highlight()
-            else:
-                self.reset()
-        return super(PipeItem, self).itemChange(change, value)
-
-    def paint(self, painter, option, widget):
-        """
-        Draws the connection line between nodes.
-
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        painter.save()
-
-        pen = self.pen()
-        if self.disabled():
-            if not self._active:
-                pen.setColor(QtGui.QColor(*PipeEnum.DISABLED_COLOR.value))
-                pen.setStyle(PIPE_STYLES.get(PipeEnum.DRAW_TYPE_DOTTED.value))
-                pen.setWidth(pen.width() * 1.25)
-
-        painter.setPen(pen)
-        painter.setBrush(self.brush())
-        painter.setRenderHint(painter.Antialiasing, True)
-        painter.drawPath(self.path())
-
-        # QPaintDevice: Cannot destroy paint device that is being painted.
-        painter.restore()
-
-    @staticmethod
-    def _calc_distance(p1, p2):
-        x = math.pow((p2.x() - p1.x()), 2)
-        y = math.pow((p2.y() - p1.y()), 2)
-        return math.sqrt(x + y)
-
-    def _draw_direction_pointer(self):
-        """
-        updates the pipe direction pointer arrow.
-        """
-        if not (self.input_port and self.output_port):
-            self._dir_pointer.setVisible(False)
-            return
-
-        if self.disabled():
-            if not (self._active or self._highlight):
-                color = QtGui.QColor(*PipeEnum.DISABLED_COLOR.value)
-                pen = self._dir_pointer.pen()
-                pen.setColor(color)
-                self._dir_pointer.setPen(pen)
-                self._dir_pointer.setBrush(color.darker(200))
-
-        self._dir_pointer.setVisible(True)
-        loc_pt = self.path().pointAtPercent(0.49)
-        tgt_pt = self.path().pointAtPercent(0.51)
-        radians = math.atan2(tgt_pt.y() - loc_pt.y(),
-                             tgt_pt.x() - loc_pt.x())
-        degrees = math.degrees(radians) - 90
-        self._dir_pointer.setRotation(degrees)
-        self._dir_pointer.setPos(self.path().pointAtPercent(0.5))
-
-        cen_x = self.path().pointAtPercent(0.5).x()
-        cen_y = self.path().pointAtPercent(0.5).y()
-        dist = math.hypot(tgt_pt.x() - cen_x, tgt_pt.y() - cen_y)
-
-        self._dir_pointer.setVisible(True)
-        if dist < 0.3:
-            self._dir_pointer.setVisible(False)
-            return
-        if dist < 1.0:
-            self._dir_pointer.setScale(dist)
-
-    def _draw_path_cycled_vertical(self, start_port, pos1, pos2, path):
-        """
-        Draw pipe vertically around node if connection is cyclic.
-
-        Args:
-            start_port (PortItem): port used to draw the starting point.
-            pos1 (QPointF): start port position.
-            pos2 (QPointF): end port position.
-            path (QPainterPath): path to draw.
-        """
-        n_rect = start_port.node.boundingRect()
-        ptype = start_port.port_type
-        start_pos = pos1 if ptype == PortTypeEnum.IN.value else pos2
-        end_pos = pos2 if ptype == PortTypeEnum.IN.value else pos1
-
-        padding = 40
-        top = start_pos.y() - padding
-        bottom = end_pos.y() + padding
-        path.moveTo(end_pos)
-        path.lineTo(end_pos.x(), bottom)
-        path.lineTo(end_pos.x() + n_rect.right(), bottom)
-        path.lineTo(end_pos.x() + n_rect.right(), top)
-        path.lineTo(start_pos.x(), top)
-        path.lineTo(start_pos)
-        self.setPath(path)
-
-    def _draw_path_cycled_horizontal(self, start_port, pos1, pos2, path):
-        """
-        Draw pipe horizontally around node if connection is cyclic.
-
-        Args:
-            start_port (PortItem): port used to draw the starting point.
-            pos1 (QPointF): start port position.
-            pos2 (QPointF): end port position.
-            path (QPainterPath): path to draw.
-        """
-        n_rect = start_port.node.boundingRect()
-        ptype = start_port.port_type
-        start_pos = pos1 if ptype == PortTypeEnum.IN.value else pos2
-        end_pos = pos2 if ptype == PortTypeEnum.IN.value else pos1
-
-        padding = 40
-        left = end_pos.x() + padding
-        right = start_pos.x() - padding
-        path.moveTo(start_pos)
-        path.lineTo(right, start_pos.y())
-        path.lineTo(right, end_pos.y() + n_rect.bottom())
-        path.lineTo(left, end_pos.y() + n_rect.bottom())
-        path.lineTo(left, end_pos.y())
-        path.lineTo(end_pos)
-        self.setPath(path)
-
-    def _draw_path_vertical(self, start_port, pos1, pos2, path):
-        """
-        Draws the vertical path between ports.
-
-        Args:
-            start_port (PortItem): port used to draw the starting point.
-            pos1 (QPointF): start port position.
-            pos2 (QPointF): end port position.
-            path (QPainterPath): path to draw.
-        """
-        if self.viewer_pipe_layout() == PipeLayoutEnum.CURVED.value:
-            ctr_offset_y1, ctr_offset_y2 = pos1.y(), pos2.y()
-            tangent = abs(ctr_offset_y1 - ctr_offset_y2)
-
-            max_height = start_port.node.boundingRect().height()
-            tangent = min(tangent, max_height)
-            if start_port.port_type == PortTypeEnum.IN.value:
-                ctr_offset_y1 -= tangent
-                ctr_offset_y2 += tangent
-            else:
-                ctr_offset_y1 += tangent
-                ctr_offset_y2 -= tangent
-
-            ctr_point1 = QtCore.QPointF(pos1.x(), ctr_offset_y1)
-            ctr_point2 = QtCore.QPointF(pos2.x(), ctr_offset_y2)
-            path.cubicTo(ctr_point1, ctr_point2, pos2)
-            self.setPath(path)
-        elif self.viewer_pipe_layout() == PipeLayoutEnum.ANGLE.value:
-            ctr_offset_y1, ctr_offset_y2 = pos1.y(), pos2.y()
-            distance = abs(ctr_offset_y1 - ctr_offset_y2)/2
-            if start_port.port_type == PortTypeEnum.IN.value:
-                ctr_offset_y1 -= distance
-                ctr_offset_y2 += distance
-            else:
-                ctr_offset_y1 += distance
-                ctr_offset_y2 -= distance
-
-            ctr_point1 = QtCore.QPointF(pos1.x(), ctr_offset_y1)
-            ctr_point2 = QtCore.QPointF(pos2.x(), ctr_offset_y2)
-            path.lineTo(ctr_point1)
-            path.lineTo(ctr_point2)
-            path.lineTo(pos2)
-            self.setPath(path)
-
-    def _draw_path_horizontal(self, start_port, pos1, pos2, path):
-        """
-        Draws the horizontal path between ports.
-
-        Args:
-            start_port (PortItem): port used to draw the starting point.
-            pos1 (QPointF): start port position.
-            pos2 (QPointF): end port position.
-            path (QPainterPath): path to draw.
-        """
-        if self.viewer_pipe_layout() == PipeLayoutEnum.CURVED.value:
-            ctr_offset_x1, ctr_offset_x2 = pos1.x(), pos2.x()
-            tangent = abs(ctr_offset_x1 - ctr_offset_x2)
-
-            max_width = start_port.node.boundingRect().width()
-            tangent = min(tangent, max_width)
-            if start_port.port_type == PortTypeEnum.IN.value:
-                ctr_offset_x1 -= tangent
-                ctr_offset_x2 += tangent
-            else:
-                ctr_offset_x1 += tangent
-                ctr_offset_x2 -= tangent
-
-            ctr_point1 = QtCore.QPointF(ctr_offset_x1, pos1.y())
-            ctr_point2 = QtCore.QPointF(ctr_offset_x2, pos2.y())
-            path.cubicTo(ctr_point1, ctr_point2, pos2)
-            self.setPath(path)
-        elif self.viewer_pipe_layout() == PipeLayoutEnum.ANGLE.value:
-            ctr_offset_x1, ctr_offset_x2 = pos1.x(), pos2.x()
-            distance = abs(ctr_offset_x1 - ctr_offset_x2) / 2
-            if start_port.port_type == PortTypeEnum.IN.value:
-                ctr_offset_x1 -= distance
-                ctr_offset_x2 += distance
-            else:
-                ctr_offset_x1 += distance
-                ctr_offset_x2 -= distance
-
-            ctr_point1 = QtCore.QPointF(ctr_offset_x1, pos1.y())
-            ctr_point2 = QtCore.QPointF(ctr_offset_x2, pos2.y())
-            path.lineTo(ctr_point1)
-            path.lineTo(ctr_point2)
-            path.lineTo(pos2)
-            self.setPath(path)
-
-    def draw_path(self, start_port, end_port=None, cursor_pos=None):
-        """
-        Draws the path between ports.
-
-        Args:
-            start_port (PortItem): port used to draw the starting point.
-            end_port (PortItem): port used to draw the end point.
-            cursor_pos (QtCore.QPointF): cursor position if specified this
-                will be the draw end point.
-        """
-        if not start_port:
-            return
-
-        # get start / end positions.
-        pos1 = start_port.scenePos()
-        pos1.setX(pos1.x() + (start_port.boundingRect().width() / 2))
-        pos1.setY(pos1.y() + (start_port.boundingRect().height() / 2))
-        if cursor_pos:
-            pos2 = cursor_pos
-        elif end_port:
-            pos2 = end_port.scenePos()
-            pos2.setX(pos2.x() + (start_port.boundingRect().width() / 2))
-            pos2.setY(pos2.y() + (start_port.boundingRect().height() / 2))
-        else:
-            return
-
-        # visibility check for connected pipe.
-        if self.input_port and self.output_port:
-            is_visible = all([
-                self._input_port.isVisible(),
-                self._output_port.isVisible(),
-                self._input_port.node.isVisible(),
-                self._output_port.node.isVisible()
-            ])
-            self.setVisible(is_visible)
-
-            # don't draw pipe if a port or node is not visible.
-            if not is_visible:
-                return
-
-        line = QtCore.QLineF(pos1, pos2)
-        path = QtGui.QPainterPath()
-
-        direction = self.viewer_layout_direction()
-
-        if end_port and not self.viewer().acyclic:
-            if end_port.node == start_port.node:
-                if direction is LayoutDirectionEnum.VERTICAL.value:
-                    self._draw_path_cycled_vertical(
-                        start_port, pos1, pos2, path
-                    )
-                    self._draw_direction_pointer()
-                    return
-                elif direction is LayoutDirectionEnum.HORIZONTAL.value:
-                    self._draw_path_cycled_horizontal(
-                        start_port, pos1, pos2, path
-                    )
-                    self._draw_direction_pointer()
-                    return
-
-        path.moveTo(line.x1(), line.y1())
-
-        if self.viewer_pipe_layout() == PipeLayoutEnum.STRAIGHT.value:
-            path.lineTo(pos2)
-            self.setPath(path)
-            self._draw_direction_pointer()
-            return
-
-        if direction is LayoutDirectionEnum.VERTICAL.value:
-            self._draw_path_vertical(start_port, pos1, pos2, path)
-        elif direction is LayoutDirectionEnum.HORIZONTAL.value:
-            self._draw_path_horizontal(start_port, pos1, pos2, path)
-
-        self._draw_direction_pointer()
-
-    def reset_path(self):
-        """
-        reset the pipe initial path position.
-        """
-        path = QtGui.QPainterPath(QtCore.QPointF(0.0, 0.0))
-        self.setPath(path)
-        self._draw_direction_pointer()
-
-    def port_from_pos(self, pos, reverse=False):
-        """
-        Args:
-            pos (QtCore.QPointF): current scene position.
-            reverse (bool): false to return the nearest port.
-
-        Returns:
-            PortItem: port item.
-        """
-        inport_pos = self.input_port.scenePos()
-        outport_pos = self.output_port.scenePos()
-        input_dist = self._calc_distance(inport_pos, pos)
-        output_dist = self._calc_distance(outport_pos, pos)
-        if input_dist < output_dist:
-            port = self.output_port if reverse else self.input_port
-        else:
-            port = self.input_port if reverse else self.output_port
-        return port
-
-    def viewer(self):
-        """
-        Returns:
-            NodeViewer: node graph viewer.
-        """
-        if self.scene():
-            return self.scene().viewer()
-
-    def viewer_pipe_layout(self):
-        """
-        Returns:
-            int: pipe layout mode.
-        """
-        viewer = self.viewer()
-        if viewer:
-            return viewer.get_pipe_layout()
-
-    def viewer_layout_direction(self):
-        """
-        Returns:
-            int: graph layout mode.
-        """
-        viewer = self.viewer()
-        if viewer:
-            return viewer.get_layout_direction()
-
-    def set_pipe_styling(self, color, width=0.5, style=0):
-        """
-        Args:
-            color (list or tuple): (r, g, b, a) values 0-255
-            width (float): pipe width.
-            style (int): pipe style.
-        """
-        pen = self.pen()
-        pen.setWidth(width)
-        pen.setColor(QtGui.QColor(*color))
-        pen.setStyle(PIPE_STYLES.get(style))
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        self.setPen(pen)
-        self.setBrush(QtGui.QBrush(QtGui.QColor(0, 0, 0, 0)))
-
-        pen = self._dir_pointer.pen()
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        pen.setWidth(width)
-        pen.setColor(QtGui.QColor(*color))
-        self._dir_pointer.setPen(pen)
-        self._dir_pointer.setBrush(QtGui.QColor(*color).darker(200))
-
-    def activate(self):
-        self._active = True
-        self.set_pipe_styling(
-            color=PipeEnum.ACTIVE_COLOR.value,
-            width=2.5,
-            style=PipeEnum.DRAW_TYPE_DEFAULT.value
-        )
-
-    def active(self):
-        return self._active
-
-    def highlight(self):
-        self._highlight = True
-        self.set_pipe_styling(
-            color=PipeEnum.HIGHLIGHT_COLOR.value,
-            width=2.5,
-            style=PipeEnum.DRAW_TYPE_DEFAULT.value
-        )
-
-    def highlighted(self):
-        return self._highlight
-
-    def reset(self):
-        """
-        reset the pipe state and styling.
-        """
-        self._active = False
-        self._highlight = False
-        self.set_pipe_styling(color=self.color, width=1.2, style=self.style)
-        self._draw_direction_pointer()
-
-    def set_connections(self, port1, port2):
-        """
-        Args:
-            port1 (PortItem): port item object.
-            port2 (PortItem): port item object.
-        """
-        ports = {
-            port1.port_type: port1,
-            port2.port_type: port2
-        }
-        self.input_port = ports[PortTypeEnum.IN.value]
-        self.output_port = ports[PortTypeEnum.OUT.value]
-        ports[PortTypeEnum.IN.value].add_pipe(self)
-        ports[PortTypeEnum.OUT.value].add_pipe(self)
-
-    def disabled(self):
-        """
-        Returns:
-            bool: true if pipe is a disabled connection.
-        """
-        if self.input_port and self.input_port.node.disabled:
-            return True
-        if self.output_port and self.output_port.node.disabled:
-            return True
-        return False
-
-    @property
-    def input_port(self):
-        return self._input_port
-
-    @input_port.setter
-    def input_port(self, port):
-        if isinstance(port, PortItem) or not port:
-            self._input_port = port
-        else:
-            self._input_port = None
-
-    @property
-    def output_port(self):
-        return self._output_port
-
-    @output_port.setter
-    def output_port(self, port):
-        if isinstance(port, PortItem) or not port:
-            self._output_port = port
-        else:
-            self._output_port = None
-
-    @property
-    def color(self):
-        return self._color
-
-    @color.setter
-    def color(self, color):
-        self._color = color
-
-    @property
-    def style(self):
-        return self._style
-
-    @style.setter
-    def style(self, style):
-        self._style = style
-
-    def delete(self):
-        if self.input_port and self.input_port.connected_pipes:
-            self.input_port.remove_pipe(self)
-        if self.output_port and self.output_port.connected_pipes:
-            self.output_port.remove_pipe(self)
-        if self.scene():
-            self.scene().removeItem(self)
-
-
-class LivePipeItem(PipeItem):
-    """
-    Live Pipe item used for drawing the live connection with the cursor.
-    """
-
-    def __init__(self):
-        super(LivePipeItem, self).__init__()
-        self.setZValue(Z_VAL_NODE_WIDGET + 1)
-
-        self.color = PipeEnum.ACTIVE_COLOR.value
-        self.style = PipeEnum.DRAW_TYPE_DASHED.value
-        self.set_pipe_styling(color=self.color, width=2.8, style=self.style)
-
-        self.shift_selected = False
-
-        self._idx_pointer = LivePipePolygonItem(self)
-        self._idx_pointer.setPolygon(self._poly)
-        self._idx_pointer.setBrush(QtGui.QColor(*self.color).darker(300))
-        pen = self._idx_pointer.pen()
-        pen.setWidth(self.pen().width())
-        pen.setColor(self.pen().color())
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        self._idx_pointer.setPen(pen)
-
-        color = self.pen().color()
-        color.setAlpha(80)
-        self._idx_text = QtWidgets.QGraphicsTextItem(self)
-        self._idx_text.setDefaultTextColor(color)
-        font = self._idx_text.font()
-        font.setPointSize(7)
-        self._idx_text.setFont(font)
-
-    def hoverEnterEvent(self, event):
-        """
-        re-implemented back to the base default behaviour or the pipe will
-        lose it styling when another pipe is selected.
-        """
-        QtWidgets.QGraphicsPathItem.hoverEnterEvent(self, event)
-
-    def draw_path(self, start_port, end_port=None, cursor_pos=None, color=None):
-        """
-        re-implemented to also update the index pointer arrow position.
-
-        Args:
-            start_port (PortItem): port used to draw the starting point.
-            end_port (PortItem): port used to draw the end point.
-            cursor_pos (QtCore.QPointF): cursor position if specified this
-                will be the draw end point.
-            color (list[int]): override arrow index pointer color. (r, g, b)
-        """
-        super(LivePipeItem, self).draw_path(start_port, end_port, cursor_pos)
-        self.draw_index_pointer(start_port, cursor_pos, color)
-
-    def draw_index_pointer(self, start_port, cursor_pos, color=None):
-        """
-        Update the index pointer arrow position and direction when the
-        live pipe path is redrawn.
-
-        Args:
-            start_port (PortItem): start port item.
-            cursor_pos (QtCore.QPoint): cursor scene position.
-            color (list[int]): override arrow index pointer color. (r, g, b).
-        """
-        text_rect = self._idx_text.boundingRect()
-
-        transform = QtGui.QTransform()
-        transform.translate(cursor_pos.x(), cursor_pos.y())
-        if self.viewer_layout_direction() is LayoutDirectionEnum.VERTICAL.value:
-            text_pos = (
-                cursor_pos.x() + (text_rect.width() / 2.5),
-                cursor_pos.y() - (text_rect.height() / 2)
-            )
-            if start_port.port_type == PortTypeEnum.OUT.value:
-                transform.rotate(180)
-        elif self.viewer_layout_direction() is LayoutDirectionEnum.HORIZONTAL.value:
-            text_pos = (
-                cursor_pos.x() - (text_rect.width() / 2),
-                cursor_pos.y() - (text_rect.height() * 1.25)
-            )
-            if start_port.port_type == PortTypeEnum.IN.value:
-                transform.rotate(-90)
-            else:
-                transform.rotate(90)
-        self._idx_text.setPos(*text_pos)
-        self._idx_text.setPlainText('{}'.format(start_port.name))
-
-        self._idx_pointer.setPolygon(transform.map(self._poly))
-
-        pen_color = QtGui.QColor(*PipeEnum.HIGHLIGHT_COLOR.value)
-        if isinstance(color, (list, tuple)):
-            pen_color = QtGui.QColor(*color)
-
-        pen = self._idx_pointer.pen()
-        pen.setColor(pen_color)
-        self._idx_pointer.setBrush(pen_color.darker(300))
-        self._idx_pointer.setPen(pen)
-
-
-class LivePipePolygonItem(QtWidgets.QGraphicsPolygonItem):
-    """
-    Custom live pipe polygon shape.
-    """
-
-    def __init__(self, parent):
-        super(LivePipePolygonItem, self).__init__(parent)
-        self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, True)
-
-    def paint(self, painter, option, widget):
-        """
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        painter.save()
-        painter.setBrush(self.brush())
-        painter.setPen(self.pen())
-        painter.drawPolygon(self.polygon())
-        painter.restore()
+#!/usr/bin/python
+import math
+
+from Qt import QtCore, QtGui, QtWidgets
+
+from NodeGraphQt.constants import (
+    LayoutDirectionEnum,
+    PipeEnum,
+    PipeLayoutEnum,
+    PortTypeEnum,
+    ITEM_CACHE_MODE,
+    Z_VAL_PIPE,
+    Z_VAL_NODE_WIDGET
+)
+from NodeGraphQt.qgraphics.port import PortItem
+
+PIPE_STYLES = {
+    PipeEnum.DRAW_TYPE_DEFAULT.value: QtCore.Qt.SolidLine,
+    PipeEnum.DRAW_TYPE_DASHED.value: QtCore.Qt.DashLine,
+    PipeEnum.DRAW_TYPE_DOTTED.value: QtCore.Qt.DotLine
+}
+
+
+class PipeItem(QtWidgets.QGraphicsPathItem):
+    """
+    Base Pipe item used for drawing node connections.
+    """
+
+    def __init__(self, input_port=None, output_port=None):
+        super(PipeItem, self).__init__()
+        self.setZValue(Z_VAL_PIPE)
+        self.setAcceptHoverEvents(True)
+        self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable)
+        self.setCacheMode(ITEM_CACHE_MODE)
+
+        self._color = PipeEnum.COLOR.value
+        self._style = PipeEnum.DRAW_TYPE_DEFAULT.value
+        self._active = False
+        self._highlight = False
+        self._input_port = input_port
+        self._output_port = output_port
+
+        size = 6.0
+        self._poly = QtGui.QPolygonF()
+        self._poly.append(QtCore.QPointF(-size, size))
+        self._poly.append(QtCore.QPointF(0.0, -size * 1.5))
+        self._poly.append(QtCore.QPointF(size, size))
+
+        self._dir_pointer = QtWidgets.QGraphicsPolygonItem(self)
+        self._dir_pointer.setPolygon(self._poly)
+        self._dir_pointer.setFlag(self.ItemIsSelectable, False)
+
+        self.reset()
+
+    def __repr__(self):
+        in_name = self._input_port.name if self._input_port else ''
+        out_name = self._output_port.name if self._output_port else ''
+        return '{}.Pipe(\'{}\', \'{}\')'.format(
+            self.__module__, in_name, out_name)
+
+    def hoverEnterEvent(self, event):
+        self.activate()
+
+    def hoverLeaveEvent(self, event):
+        self.reset()
+        if self.input_port and self.output_port:
+            if self.input_port.node.selected:
+                self.highlight()
+            elif self.output_port.node.selected:
+                self.highlight()
+        if self.isSelected():
+            self.highlight()
+
+    def itemChange(self, change, value):
+        if change == self.ItemSelectedChange and self.scene():
+            if value:
+                self.highlight()
+            else:
+                self.reset()
+        return super(PipeItem, self).itemChange(change, value)
+
+    def paint(self, painter, option, widget):
+        """
+        Draws the connection line between nodes.
+
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        painter.save()
+
+        pen = self.pen()
+        if self.disabled():
+            if not self._active:
+                pen.setColor(QtGui.QColor(*PipeEnum.DISABLED_COLOR.value))
+                pen.setStyle(PIPE_STYLES.get(PipeEnum.DRAW_TYPE_DOTTED.value))
+                pen.setWidth(pen.width() * 1.25)
+
+        painter.setPen(pen)
+        painter.setBrush(self.brush())
+        painter.setRenderHint(painter.Antialiasing, True)
+        painter.drawPath(self.path())
+
+        # QPaintDevice: Cannot destroy paint device that is being painted.
+        painter.restore()
+
+    @staticmethod
+    def _calc_distance(p1, p2):
+        x = math.pow((p2.x() - p1.x()), 2)
+        y = math.pow((p2.y() - p1.y()), 2)
+        return math.sqrt(x + y)
+
+    def _draw_direction_pointer(self):
+        """
+        updates the pipe direction pointer arrow.
+        """
+        if not (self.input_port and self.output_port):
+            self._dir_pointer.setVisible(False)
+            return
+
+        if self.disabled():
+            if not (self._active or self._highlight):
+                color = QtGui.QColor(*PipeEnum.DISABLED_COLOR.value)
+                pen = self._dir_pointer.pen()
+                pen.setColor(color)
+                self._dir_pointer.setPen(pen)
+                self._dir_pointer.setBrush(color.darker(200))
+
+        self._dir_pointer.setVisible(True)
+        loc_pt = self.path().pointAtPercent(0.49)
+        tgt_pt = self.path().pointAtPercent(0.51)
+        radians = math.atan2(tgt_pt.y() - loc_pt.y(),
+                             tgt_pt.x() - loc_pt.x())
+        degrees = math.degrees(radians) - 90
+        self._dir_pointer.setRotation(degrees)
+        self._dir_pointer.setPos(self.path().pointAtPercent(0.5))
+
+        cen_x = self.path().pointAtPercent(0.5).x()
+        cen_y = self.path().pointAtPercent(0.5).y()
+        dist = math.hypot(tgt_pt.x() - cen_x, tgt_pt.y() - cen_y)
+
+        self._dir_pointer.setVisible(True)
+        if dist < 0.3:
+            self._dir_pointer.setVisible(False)
+            return
+        if dist < 1.0:
+            self._dir_pointer.setScale(dist)
+
+    def _draw_path_cycled_vertical(self, start_port, pos1, pos2, path):
+        """
+        Draw pipe vertically around node if connection is cyclic.
+
+        Args:
+            start_port (PortItem): port used to draw the starting point.
+            pos1 (QPointF): start port position.
+            pos2 (QPointF): end port position.
+            path (QPainterPath): path to draw.
+        """
+        n_rect = start_port.node.boundingRect()
+        ptype = start_port.port_type
+        start_pos = pos1 if ptype == PortTypeEnum.IN.value else pos2
+        end_pos = pos2 if ptype == PortTypeEnum.IN.value else pos1
+
+        padding = 40
+        top = start_pos.y() - padding
+        bottom = end_pos.y() + padding
+        path.moveTo(end_pos)
+        path.lineTo(end_pos.x(), bottom)
+        path.lineTo(end_pos.x() + n_rect.right(), bottom)
+        path.lineTo(end_pos.x() + n_rect.right(), top)
+        path.lineTo(start_pos.x(), top)
+        path.lineTo(start_pos)
+        self.setPath(path)
+
+    def _draw_path_cycled_horizontal(self, start_port, pos1, pos2, path):
+        """
+        Draw pipe horizontally around node if connection is cyclic.
+
+        Args:
+            start_port (PortItem): port used to draw the starting point.
+            pos1 (QPointF): start port position.
+            pos2 (QPointF): end port position.
+            path (QPainterPath): path to draw.
+        """
+        n_rect = start_port.node.boundingRect()
+        ptype = start_port.port_type
+        start_pos = pos1 if ptype == PortTypeEnum.IN.value else pos2
+        end_pos = pos2 if ptype == PortTypeEnum.IN.value else pos1
+
+        padding = 40
+        left = end_pos.x() + padding
+        right = start_pos.x() - padding
+        path.moveTo(start_pos)
+        path.lineTo(right, start_pos.y())
+        path.lineTo(right, end_pos.y() + n_rect.bottom())
+        path.lineTo(left, end_pos.y() + n_rect.bottom())
+        path.lineTo(left, end_pos.y())
+        path.lineTo(end_pos)
+        self.setPath(path)
+
+    def _draw_path_vertical(self, start_port, pos1, pos2, path):
+        """
+        Draws the vertical path between ports.
+
+        Args:
+            start_port (PortItem): port used to draw the starting point.
+            pos1 (QPointF): start port position.
+            pos2 (QPointF): end port position.
+            path (QPainterPath): path to draw.
+        """
+        if self.viewer_pipe_layout() == PipeLayoutEnum.CURVED.value:
+            ctr_offset_y1, ctr_offset_y2 = pos1.y(), pos2.y()
+            tangent = abs(ctr_offset_y1 - ctr_offset_y2)
+
+            max_height = start_port.node.boundingRect().height()
+            tangent = min(tangent, max_height)
+            if start_port.port_type == PortTypeEnum.IN.value:
+                ctr_offset_y1 -= tangent
+                ctr_offset_y2 += tangent
+            else:
+                ctr_offset_y1 += tangent
+                ctr_offset_y2 -= tangent
+
+            ctr_point1 = QtCore.QPointF(pos1.x(), ctr_offset_y1)
+            ctr_point2 = QtCore.QPointF(pos2.x(), ctr_offset_y2)
+            path.cubicTo(ctr_point1, ctr_point2, pos2)
+            self.setPath(path)
+        elif self.viewer_pipe_layout() == PipeLayoutEnum.ANGLE.value:
+            ctr_offset_y1, ctr_offset_y2 = pos1.y(), pos2.y()
+            distance = abs(ctr_offset_y1 - ctr_offset_y2)/2
+            if start_port.port_type == PortTypeEnum.IN.value:
+                ctr_offset_y1 -= distance
+                ctr_offset_y2 += distance
+            else:
+                ctr_offset_y1 += distance
+                ctr_offset_y2 -= distance
+
+            ctr_point1 = QtCore.QPointF(pos1.x(), ctr_offset_y1)
+            ctr_point2 = QtCore.QPointF(pos2.x(), ctr_offset_y2)
+            path.lineTo(ctr_point1)
+            path.lineTo(ctr_point2)
+            path.lineTo(pos2)
+            self.setPath(path)
+
+    def _draw_path_horizontal(self, start_port, pos1, pos2, path):
+        """
+        Draws the horizontal path between ports.
+
+        Args:
+            start_port (PortItem): port used to draw the starting point.
+            pos1 (QPointF): start port position.
+            pos2 (QPointF): end port position.
+            path (QPainterPath): path to draw.
+        """
+        if self.viewer_pipe_layout() == PipeLayoutEnum.CURVED.value:
+            ctr_offset_x1, ctr_offset_x2 = pos1.x(), pos2.x()
+            tangent = abs(ctr_offset_x1 - ctr_offset_x2)
+
+            max_width = start_port.node.boundingRect().width()
+            tangent = min(tangent, max_width)
+            if start_port.port_type == PortTypeEnum.IN.value:
+                ctr_offset_x1 -= tangent
+                ctr_offset_x2 += tangent
+            else:
+                ctr_offset_x1 += tangent
+                ctr_offset_x2 -= tangent
+
+            ctr_point1 = QtCore.QPointF(ctr_offset_x1, pos1.y())
+            ctr_point2 = QtCore.QPointF(ctr_offset_x2, pos2.y())
+            path.cubicTo(ctr_point1, ctr_point2, pos2)
+            self.setPath(path)
+        elif self.viewer_pipe_layout() == PipeLayoutEnum.ANGLE.value:
+            ctr_offset_x1, ctr_offset_x2 = pos1.x(), pos2.x()
+            distance = abs(ctr_offset_x1 - ctr_offset_x2) / 2
+            if start_port.port_type == PortTypeEnum.IN.value:
+                ctr_offset_x1 -= distance
+                ctr_offset_x2 += distance
+            else:
+                ctr_offset_x1 += distance
+                ctr_offset_x2 -= distance
+
+            ctr_point1 = QtCore.QPointF(ctr_offset_x1, pos1.y())
+            ctr_point2 = QtCore.QPointF(ctr_offset_x2, pos2.y())
+            path.lineTo(ctr_point1)
+            path.lineTo(ctr_point2)
+            path.lineTo(pos2)
+            self.setPath(path)
+
+    def draw_path(self, start_port, end_port=None, cursor_pos=None):
+        """
+        Draws the path between ports.
+
+        Args:
+            start_port (PortItem): port used to draw the starting point.
+            end_port (PortItem): port used to draw the end point.
+            cursor_pos (QtCore.QPointF): cursor position if specified this
+                will be the draw end point.
+        """
+        if not start_port:
+            return
+
+        # get start / end positions.
+        pos1 = start_port.scenePos()
+        pos1.setX(pos1.x() + (start_port.boundingRect().width() / 2))
+        pos1.setY(pos1.y() + (start_port.boundingRect().height() / 2))
+        if cursor_pos:
+            pos2 = cursor_pos
+        elif end_port:
+            pos2 = end_port.scenePos()
+            pos2.setX(pos2.x() + (start_port.boundingRect().width() / 2))
+            pos2.setY(pos2.y() + (start_port.boundingRect().height() / 2))
+        else:
+            return
+
+        # visibility check for connected pipe.
+        if self.input_port and self.output_port:
+            is_visible = all([
+                self._input_port.isVisible(),
+                self._output_port.isVisible(),
+                self._input_port.node.isVisible(),
+                self._output_port.node.isVisible()
+            ])
+            self.setVisible(is_visible)
+
+            # don't draw pipe if a port or node is not visible.
+            if not is_visible:
+                return
+
+        line = QtCore.QLineF(pos1, pos2)
+        path = QtGui.QPainterPath()
+
+        direction = self.viewer_layout_direction()
+
+        if end_port and not self.viewer().acyclic:
+            if end_port.node == start_port.node:
+                if direction is LayoutDirectionEnum.VERTICAL.value:
+                    self._draw_path_cycled_vertical(
+                        start_port, pos1, pos2, path
+                    )
+                    self._draw_direction_pointer()
+                    return
+                elif direction is LayoutDirectionEnum.HORIZONTAL.value:
+                    self._draw_path_cycled_horizontal(
+                        start_port, pos1, pos2, path
+                    )
+                    self._draw_direction_pointer()
+                    return
+
+        path.moveTo(line.x1(), line.y1())
+
+        if self.viewer_pipe_layout() == PipeLayoutEnum.STRAIGHT.value:
+            path.lineTo(pos2)
+            self.setPath(path)
+            self._draw_direction_pointer()
+            return
+
+        if direction is LayoutDirectionEnum.VERTICAL.value:
+            self._draw_path_vertical(start_port, pos1, pos2, path)
+        elif direction is LayoutDirectionEnum.HORIZONTAL.value:
+            self._draw_path_horizontal(start_port, pos1, pos2, path)
+
+        self._draw_direction_pointer()
+
+    def reset_path(self):
+        """
+        reset the pipe initial path position.
+        """
+        path = QtGui.QPainterPath(QtCore.QPointF(0.0, 0.0))
+        self.setPath(path)
+        self._draw_direction_pointer()
+
+    def port_from_pos(self, pos, reverse=False):
+        """
+        Args:
+            pos (QtCore.QPointF): current scene position.
+            reverse (bool): false to return the nearest port.
+
+        Returns:
+            PortItem: port item.
+        """
+        inport_pos = self.input_port.scenePos()
+        outport_pos = self.output_port.scenePos()
+        input_dist = self._calc_distance(inport_pos, pos)
+        output_dist = self._calc_distance(outport_pos, pos)
+        if input_dist < output_dist:
+            port = self.output_port if reverse else self.input_port
+        else:
+            port = self.input_port if reverse else self.output_port
+        return port
+
+    def viewer(self):
+        """
+        Returns:
+            NodeViewer: node graph viewer.
+        """
+        if self.scene():
+            return self.scene().viewer()
+
+    def viewer_pipe_layout(self):
+        """
+        Returns:
+            int: pipe layout mode.
+        """
+        viewer = self.viewer()
+        if viewer:
+            return viewer.get_pipe_layout()
+
+    def viewer_layout_direction(self):
+        """
+        Returns:
+            int: graph layout mode.
+        """
+        viewer = self.viewer()
+        if viewer:
+            return viewer.get_layout_direction()
+
+    def set_pipe_styling(self, color, width=0.5, style=0):
+        """
+        Args:
+            color (list or tuple): (r, g, b, a) values 0-255
+            width (float): pipe width.
+            style (int): pipe style.
+        """
+        pen = self.pen()
+        pen.setWidth(width)
+        pen.setColor(QtGui.QColor(*color))
+        pen.setStyle(PIPE_STYLES.get(style))
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        self.setPen(pen)
+        self.setBrush(QtGui.QBrush(QtCore.Qt.NoBrush))
+
+        pen = self._dir_pointer.pen()
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        pen.setWidth(width)
+        pen.setColor(QtGui.QColor(*color))
+        self._dir_pointer.setPen(pen)
+        self._dir_pointer.setBrush(QtGui.QColor(*color).darker(200))
+
+    def activate(self):
+        self._active = True
+        self.set_pipe_styling(
+            color=PipeEnum.ACTIVE_COLOR.value,
+            width=2.5,
+            style=PipeEnum.DRAW_TYPE_DEFAULT.value
+        )
+
+    def active(self):
+        return self._active
+
+    def highlight(self):
+        self._highlight = True
+        self.set_pipe_styling(
+            color=PipeEnum.HIGHLIGHT_COLOR.value,
+            width=2.5,
+            style=PipeEnum.DRAW_TYPE_DEFAULT.value
+        )
+
+    def highlighted(self):
+        return self._highlight
+
+    def reset(self):
+        """
+        reset the pipe state and styling.
+        """
+        self._active = False
+        self._highlight = False
+        self.set_pipe_styling(color=self.color, width=1.2, style=self.style)
+        self._draw_direction_pointer()
+
+    def set_connections(self, port1, port2):
+        """
+        Args:
+            port1 (PortItem): port item object.
+            port2 (PortItem): port item object.
+        """
+        ports = {
+            port1.port_type: port1,
+            port2.port_type: port2
+        }
+        self.input_port = ports[PortTypeEnum.IN.value]
+        self.output_port = ports[PortTypeEnum.OUT.value]
+        ports[PortTypeEnum.IN.value].add_pipe(self)
+        ports[PortTypeEnum.OUT.value].add_pipe(self)
+
+    def disabled(self):
+        """
+        Returns:
+            bool: true if pipe is a disabled connection.
+        """
+        if self.input_port and self.input_port.node.disabled:
+            return True
+        if self.output_port and self.output_port.node.disabled:
+            return True
+        return False
+
+    @property
+    def input_port(self):
+        return self._input_port
+
+    @input_port.setter
+    def input_port(self, port):
+        if isinstance(port, PortItem) or not port:
+            self._input_port = port
+        else:
+            self._input_port = None
+
+    @property
+    def output_port(self):
+        return self._output_port
+
+    @output_port.setter
+    def output_port(self, port):
+        if isinstance(port, PortItem) or not port:
+            self._output_port = port
+        else:
+            self._output_port = None
+
+    @property
+    def color(self):
+        return self._color
+
+    @color.setter
+    def color(self, color):
+        self._color = color
+
+    @property
+    def style(self):
+        return self._style
+
+    @style.setter
+    def style(self, style):
+        self._style = style
+
+    def delete(self):
+        if self.input_port and self.input_port.connected_pipes:
+            self.input_port.remove_pipe(self)
+        if self.output_port and self.output_port.connected_pipes:
+            self.output_port.remove_pipe(self)
+        if self.scene():
+            self.scene().removeItem(self)
+
+
+class LivePipeItem(PipeItem):
+    """
+    Live Pipe item used for drawing the live connection with the cursor.
+    """
+
+    def __init__(self):
+        super(LivePipeItem, self).__init__()
+        self.setZValue(Z_VAL_NODE_WIDGET + 1)
+
+        self.color = PipeEnum.ACTIVE_COLOR.value
+        self.style = PipeEnum.DRAW_TYPE_DASHED.value
+        self.set_pipe_styling(color=self.color, width=2.8, style=self.style)
+
+        self.shift_selected = False
+
+        self._idx_pointer = LivePipePolygonItem(self)
+        self._idx_pointer.setPolygon(self._poly)
+        self._idx_pointer.setBrush(QtGui.QColor(*self.color).darker(300))
+        pen = self._idx_pointer.pen()
+        pen.setWidth(self.pen().width())
+        pen.setColor(self.pen().color())
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        self._idx_pointer.setPen(pen)
+
+        color = self.pen().color()
+        color.setAlpha(80)
+        self._idx_text = QtWidgets.QGraphicsTextItem(self)
+        self._idx_text.setDefaultTextColor(color)
+        font = self._idx_text.font()
+        font.setPointSize(7)
+        self._idx_text.setFont(font)
+
+    def hoverEnterEvent(self, event):
+        """
+        re-implemented back to the base default behaviour or the pipe will
+        lose it styling when another pipe is selected.
+        """
+        QtWidgets.QGraphicsPathItem.hoverEnterEvent(self, event)
+
+    def draw_path(self, start_port, end_port=None, cursor_pos=None, color=None):
+        """
+        re-implemented to also update the index pointer arrow position.
+
+        Args:
+            start_port (PortItem): port used to draw the starting point.
+            end_port (PortItem): port used to draw the end point.
+            cursor_pos (QtCore.QPointF): cursor position if specified this
+                will be the draw end point.
+            color (list[int]): override arrow index pointer color. (r, g, b)
+        """
+        super(LivePipeItem, self).draw_path(start_port, end_port, cursor_pos)
+        self.draw_index_pointer(start_port, cursor_pos, color)
+
+    def draw_index_pointer(self, start_port, cursor_pos, color=None):
+        """
+        Update the index pointer arrow position and direction when the
+        live pipe path is redrawn.
+
+        Args:
+            start_port (PortItem): start port item.
+            cursor_pos (QtCore.QPoint): cursor scene position.
+            color (list[int]): override arrow index pointer color. (r, g, b).
+        """
+        text_rect = self._idx_text.boundingRect()
+
+        transform = QtGui.QTransform()
+        transform.translate(cursor_pos.x(), cursor_pos.y())
+        if self.viewer_layout_direction() is LayoutDirectionEnum.VERTICAL.value:
+            text_pos = (
+                cursor_pos.x() + (text_rect.width() / 2.5),
+                cursor_pos.y() - (text_rect.height() / 2)
+            )
+            if start_port.port_type == PortTypeEnum.OUT.value:
+                transform.rotate(180)
+        elif self.viewer_layout_direction() is LayoutDirectionEnum.HORIZONTAL.value:
+            text_pos = (
+                cursor_pos.x() - (text_rect.width() / 2),
+                cursor_pos.y() - (text_rect.height() * 1.25)
+            )
+            if start_port.port_type == PortTypeEnum.IN.value:
+                transform.rotate(-90)
+            else:
+                transform.rotate(90)
+        self._idx_text.setPos(*text_pos)
+        self._idx_text.setPlainText('{}'.format(start_port.name))
+
+        self._idx_pointer.setPolygon(transform.map(self._poly))
+
+        pen_color = QtGui.QColor(*PipeEnum.HIGHLIGHT_COLOR.value)
+        if isinstance(color, (list, tuple)):
+            pen_color = QtGui.QColor(*color)
+
+        pen = self._idx_pointer.pen()
+        pen.setColor(pen_color)
+        self._idx_pointer.setBrush(pen_color.darker(300))
+        self._idx_pointer.setPen(pen)
+
+
+class LivePipePolygonItem(QtWidgets.QGraphicsPolygonItem):
+    """
+    Custom live pipe polygon shape.
+    """
+
+    def __init__(self, parent):
+        super(LivePipePolygonItem, self).__init__(parent)
+        self.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, True)
+
+    def paint(self, painter, option, widget):
+        """
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        painter.save()
+        painter.setBrush(self.brush())
+        painter.setPen(self.pen())
+        painter.drawPolygon(self.polygon())
+        painter.restore()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/port.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/port.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,325 +1,325 @@
-#!/usr/bin/python
-from Qt import QtGui, QtCore, QtWidgets
-
-from NodeGraphQt.constants import (
-    PortTypeEnum, PortEnum,
-    Z_VAL_PORT,
-    ITEM_CACHE_MODE)
-
-
-class PortItem(QtWidgets.QGraphicsItem):
-    """
-    Base Port Item.
-    """
-
-    def __init__(self, parent=None):
-        super(PortItem, self).__init__(parent)
-        self.setAcceptHoverEvents(True)
-        self.setCacheMode(ITEM_CACHE_MODE)
-        self.setFlag(self.ItemIsSelectable, False)
-        self.setFlag(self.ItemSendsScenePositionChanges, True)
-        self.setZValue(Z_VAL_PORT)
-        self._pipes = []
-        self._width = PortEnum.SIZE.value
-        self._height = PortEnum.SIZE.value
-        self._hovered = False
-        self._name = 'port'
-        self._display_name = True
-        self._color = PortEnum.COLOR.value
-        self._border_color = PortEnum.BORDER_COLOR.value
-        self._border_size = 1
-        self._port_type = None
-        self._multi_connection = False
-        self._locked = False
-
-    def __str__(self):
-        return '{}.PortItem("{}")'.format(self.__module__, self.name)
-
-    def __repr__(self):
-        return '{}.PortItem("{}")'.format(self.__module__, self.name)
-
-    def boundingRect(self):
-        return QtCore.QRectF(0.0, 0.0,
-                             self._width + PortEnum.CLICK_FALLOFF.value,
-                             self._height)
-
-    def paint(self, painter, option, widget):
-        """
-        Draws the circular port.
-
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        painter.save()
-
-        #  display falloff collision for debugging
-        # ----------------------------------------------------------------------
-        # pen = QtGui.QPen(QtGui.QColor(255, 255, 255, 80), 0.8)
-        # pen.setStyle(QtCore.Qt.DotLine)
-        # painter.setPen(pen)
-        # painter.drawRect(self.boundingRect())
-        # ----------------------------------------------------------------------
-
-        rect_w = self._width / 1.8
-        rect_h = self._height / 1.8
-        rect_x = self.boundingRect().center().x() - (rect_w / 2)
-        rect_y = self.boundingRect().center().y() - (rect_h / 2)
-        port_rect = QtCore.QRectF(rect_x, rect_y, rect_w, rect_h)
-
-        if self._hovered:
-            color = QtGui.QColor(*PortEnum.HOVER_COLOR.value)
-            border_color = QtGui.QColor(*PortEnum.HOVER_BORDER_COLOR.value)
-        elif self.connected_pipes:
-            color = QtGui.QColor(*PortEnum.ACTIVE_COLOR.value)
-            border_color = QtGui.QColor(*PortEnum.ACTIVE_BORDER_COLOR.value)
-        else:
-            color = QtGui.QColor(*self.color)
-            border_color = QtGui.QColor(*self.border_color)
-
-        pen = QtGui.QPen(border_color, 1.8)
-        painter.setPen(pen)
-        painter.setBrush(color)
-        painter.drawEllipse(port_rect)
-
-        if self.connected_pipes and not self._hovered:
-            painter.setBrush(border_color)
-            w = port_rect.width() / 2.5
-            h = port_rect.height() / 2.5
-            rect = QtCore.QRectF(port_rect.center().x() - w / 2,
-                                 port_rect.center().y() - h / 2,
-                                 w, h)
-            border_color = QtGui.QColor(*self.border_color)
-            pen = QtGui.QPen(border_color, 1.6)
-            painter.setPen(pen)
-            painter.setBrush(border_color)
-            painter.drawEllipse(rect)
-        elif self._hovered:
-            if self.multi_connection:
-                pen = QtGui.QPen(border_color, 1.4)
-                painter.setPen(pen)
-                painter.setBrush(color)
-                w = port_rect.width() / 1.8
-                h = port_rect.height() / 1.8
-            else:
-                painter.setBrush(border_color)
-                w = port_rect.width() / 3.5
-                h = port_rect.height() / 3.5
-            rect = QtCore.QRectF(port_rect.center().x() - w / 2,
-                                 port_rect.center().y() - h / 2,
-                                 w, h)
-            painter.drawEllipse(rect)
-        painter.restore()
-
-    def itemChange(self, change, value):
-        if change == self.ItemScenePositionHasChanged:
-            self.redraw_connected_pipes()
-        return super(PortItem, self).itemChange(change, value)
-
-    def mousePressEvent(self, event):
-        super(PortItem, self).mousePressEvent(event)
-        
-    def mouseReleaseEvent(self, event):
-        super(PortItem, self).mouseReleaseEvent(event)
-
-    def hoverEnterEvent(self, event):
-        self._hovered = True
-        super(PortItem, self).hoverEnterEvent(event)
-        
-    def hoverLeaveEvent(self, event):
-        self._hovered = False
-        super(PortItem, self).hoverLeaveEvent(event)
-
-    def viewer_start_connection(self):
-        viewer = self.scene().viewer()
-        viewer.start_live_connection(self)
-
-    def redraw_connected_pipes(self):
-        if not self.connected_pipes:
-            return
-        for pipe in self.connected_pipes:
-            if self.port_type == PortTypeEnum.IN.value:
-                pipe.draw_path(self, pipe.output_port)
-            elif self.port_type == PortTypeEnum.OUT.value:
-                pipe.draw_path(pipe.input_port, self)
-
-    def add_pipe(self, pipe):
-        self._pipes.append(pipe)
-
-    def remove_pipe(self, pipe):
-        self._pipes.remove(pipe)
-
-    @property
-    def connected_pipes(self):
-        return self._pipes
-
-    @property
-    def connected_ports(self):
-        ports = []
-        port_types = {
-            PortTypeEnum.IN.value: 'output_port',
-            PortTypeEnum.OUT.value: 'input_port'
-        }
-        for pipe in self.connected_pipes:
-            ports.append(getattr(pipe, port_types[self.port_type]))
-        return ports
-
-    @property
-    def hovered(self):
-        return self._hovered
-
-    @hovered.setter
-    def hovered(self, value=False):
-        self._hovered = value
-
-    @property
-    def node(self):
-        return self.parentItem()
-
-    @property
-    def name(self):
-        return self._name
-
-    @name.setter
-    def name(self, name=''):
-        self._name = name.strip()
-
-    @property
-    def display_name(self):
-        return self._display_name
-
-    @display_name.setter
-    def display_name(self, display=True):
-        self._display_name = display
-
-    @property
-    def color(self):
-        return self._color
-
-    @color.setter
-    def color(self, color=(0, 0, 0, 255)):
-        self._color = color
-        self.update()
-
-    @property
-    def border_color(self):
-        return self._border_color
-
-    @border_color.setter
-    def border_color(self, color=(0, 0, 0, 255)):
-        self._border_color = color
-
-    @property
-    def border_size(self):
-        return self._border_size
-
-    @border_size.setter
-    def border_size(self, size=2):
-        self._border_size = size
-
-    @property
-    def locked(self):
-        return self._locked
-
-    @locked.setter
-    def locked(self, value=False):
-        self._locked = value
-        conn_type = 'multi' if self.multi_connection else 'single'
-        tooltip = '{}: ({})'.format(self.name, conn_type)
-        if value:
-            tooltip += ' (L)'
-        self.setToolTip(tooltip)
-
-    @property
-    def multi_connection(self):
-        return self._multi_connection
-
-    @multi_connection.setter
-    def multi_connection(self, mode=False):
-        conn_type = 'multi' if mode else 'single'
-        self.setToolTip('{}: ({})'.format(self.name, conn_type))
-        self._multi_connection = mode
-
-    @property
-    def port_type(self):
-        return self._port_type
-
-    @port_type.setter
-    def port_type(self, port_type):
-        self._port_type = port_type
-
-    def connect_to(self, port):
-        if not port:
-            for pipe in self.connected_pipes:
-                pipe.delete()
-            return
-        if self.scene():
-            viewer = self.scene().viewer()
-            viewer.establish_connection(self, port)
-        # redraw the ports.
-        port.update()
-        self.update()
-
-    def disconnect_from(self, port):
-        port_types = {
-            PortTypeEnum.IN.value: 'output_port',
-            PortTypeEnum.OUT.value: 'input_port'
-        }
-        for pipe in self.connected_pipes:
-            connected_port = getattr(pipe, port_types[self.port_type])
-            if connected_port == port:
-                pipe.delete()
-                break
-        # redraw the ports.
-        port.update()
-        self.update()
-
-
-class CustomPortItem(PortItem):
-    """
-    Custom port item for drawing custom shape port.
-    """
-
-    def __init__(self, parent=None, paint_func=None):
-        super(CustomPortItem, self).__init__(parent)
-        self._port_painter = paint_func
-
-    def set_painter(self, func=None):
-        """
-        Set custom paint function for drawing.
-
-        Args:
-            func (function): paint function.
-        """
-        self._port_painter = func
-
-    def paint(self, painter, option, widget):
-        """
-        Draws the port item.
-
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        if self._port_painter:
-            rect_w = self._width / 1.8
-            rect_h = self._height / 1.8
-            rect_x = self.boundingRect().center().x() - (rect_w / 2)
-            rect_y = self.boundingRect().center().y() - (rect_h / 2)
-            port_rect = QtCore.QRectF(rect_x, rect_y, rect_w, rect_h)
-            port_info = {
-                'port_type': self.port_type,
-                'color': self.color,
-                'border_color': self.border_color,
-                'multi_connection': self.multi_connection,
-                'connected': bool(self.connected_pipes),
-                'hovered': self.hovered,
-                'locked': self.locked,
-            }
-            self._port_painter(painter, port_rect, port_info)
-        else:
-            super(CustomPortItem, self).paint(painter, option, widget)
+#!/usr/bin/python
+from Qt import QtGui, QtCore, QtWidgets
+
+from NodeGraphQt.constants import (
+    PortTypeEnum, PortEnum,
+    Z_VAL_PORT,
+    ITEM_CACHE_MODE)
+
+
+class PortItem(QtWidgets.QGraphicsItem):
+    """
+    Base Port Item.
+    """
+
+    def __init__(self, parent=None):
+        super(PortItem, self).__init__(parent)
+        self.setAcceptHoverEvents(True)
+        self.setCacheMode(ITEM_CACHE_MODE)
+        self.setFlag(self.ItemIsSelectable, False)
+        self.setFlag(self.ItemSendsScenePositionChanges, True)
+        self.setZValue(Z_VAL_PORT)
+        self._pipes = []
+        self._width = PortEnum.SIZE.value
+        self._height = PortEnum.SIZE.value
+        self._hovered = False
+        self._name = 'port'
+        self._display_name = True
+        self._color = PortEnum.COLOR.value
+        self._border_color = PortEnum.BORDER_COLOR.value
+        self._border_size = 1
+        self._port_type = None
+        self._multi_connection = False
+        self._locked = False
+
+    def __str__(self):
+        return '{}.PortItem("{}")'.format(self.__module__, self.name)
+
+    def __repr__(self):
+        return '{}.PortItem("{}")'.format(self.__module__, self.name)
+
+    def boundingRect(self):
+        return QtCore.QRectF(0.0, 0.0,
+                             self._width + PortEnum.CLICK_FALLOFF.value,
+                             self._height)
+
+    def paint(self, painter, option, widget):
+        """
+        Draws the circular port.
+
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        painter.save()
+
+        #  display falloff collision for debugging
+        # ----------------------------------------------------------------------
+        # pen = QtGui.QPen(QtGui.QColor(255, 255, 255, 80), 0.8)
+        # pen.setStyle(QtCore.Qt.DotLine)
+        # painter.setPen(pen)
+        # painter.drawRect(self.boundingRect())
+        # ----------------------------------------------------------------------
+
+        rect_w = self._width / 1.8
+        rect_h = self._height / 1.8
+        rect_x = self.boundingRect().center().x() - (rect_w / 2)
+        rect_y = self.boundingRect().center().y() - (rect_h / 2)
+        port_rect = QtCore.QRectF(rect_x, rect_y, rect_w, rect_h)
+
+        if self._hovered:
+            color = QtGui.QColor(*PortEnum.HOVER_COLOR.value)
+            border_color = QtGui.QColor(*PortEnum.HOVER_BORDER_COLOR.value)
+        elif self.connected_pipes:
+            color = QtGui.QColor(*PortEnum.ACTIVE_COLOR.value)
+            border_color = QtGui.QColor(*PortEnum.ACTIVE_BORDER_COLOR.value)
+        else:
+            color = QtGui.QColor(*self.color)
+            border_color = QtGui.QColor(*self.border_color)
+
+        pen = QtGui.QPen(border_color, 1.8)
+        painter.setPen(pen)
+        painter.setBrush(color)
+        painter.drawEllipse(port_rect)
+
+        if self.connected_pipes and not self._hovered:
+            painter.setBrush(border_color)
+            w = port_rect.width() / 2.5
+            h = port_rect.height() / 2.5
+            rect = QtCore.QRectF(port_rect.center().x() - w / 2,
+                                 port_rect.center().y() - h / 2,
+                                 w, h)
+            border_color = QtGui.QColor(*self.border_color)
+            pen = QtGui.QPen(border_color, 1.6)
+            painter.setPen(pen)
+            painter.setBrush(border_color)
+            painter.drawEllipse(rect)
+        elif self._hovered:
+            if self.multi_connection:
+                pen = QtGui.QPen(border_color, 1.4)
+                painter.setPen(pen)
+                painter.setBrush(color)
+                w = port_rect.width() / 1.8
+                h = port_rect.height() / 1.8
+            else:
+                painter.setBrush(border_color)
+                w = port_rect.width() / 3.5
+                h = port_rect.height() / 3.5
+            rect = QtCore.QRectF(port_rect.center().x() - w / 2,
+                                 port_rect.center().y() - h / 2,
+                                 w, h)
+            painter.drawEllipse(rect)
+        painter.restore()
+
+    def itemChange(self, change, value):
+        if change == self.ItemScenePositionHasChanged:
+            self.redraw_connected_pipes()
+        return super(PortItem, self).itemChange(change, value)
+
+    def mousePressEvent(self, event):
+        super(PortItem, self).mousePressEvent(event)
+        
+    def mouseReleaseEvent(self, event):
+        super(PortItem, self).mouseReleaseEvent(event)
+
+    def hoverEnterEvent(self, event):
+        self._hovered = True
+        super(PortItem, self).hoverEnterEvent(event)
+        
+    def hoverLeaveEvent(self, event):
+        self._hovered = False
+        super(PortItem, self).hoverLeaveEvent(event)
+
+    def viewer_start_connection(self):
+        viewer = self.scene().viewer()
+        viewer.start_live_connection(self)
+
+    def redraw_connected_pipes(self):
+        if not self.connected_pipes:
+            return
+        for pipe in self.connected_pipes:
+            if self.port_type == PortTypeEnum.IN.value:
+                pipe.draw_path(self, pipe.output_port)
+            elif self.port_type == PortTypeEnum.OUT.value:
+                pipe.draw_path(pipe.input_port, self)
+
+    def add_pipe(self, pipe):
+        self._pipes.append(pipe)
+
+    def remove_pipe(self, pipe):
+        self._pipes.remove(pipe)
+
+    @property
+    def connected_pipes(self):
+        return self._pipes
+
+    @property
+    def connected_ports(self):
+        ports = []
+        port_types = {
+            PortTypeEnum.IN.value: 'output_port',
+            PortTypeEnum.OUT.value: 'input_port'
+        }
+        for pipe in self.connected_pipes:
+            ports.append(getattr(pipe, port_types[self.port_type]))
+        return ports
+
+    @property
+    def hovered(self):
+        return self._hovered
+
+    @hovered.setter
+    def hovered(self, value=False):
+        self._hovered = value
+
+    @property
+    def node(self):
+        return self.parentItem()
+
+    @property
+    def name(self):
+        return self._name
+
+    @name.setter
+    def name(self, name=''):
+        self._name = name.strip()
+
+    @property
+    def display_name(self):
+        return self._display_name
+
+    @display_name.setter
+    def display_name(self, display=True):
+        self._display_name = display
+
+    @property
+    def color(self):
+        return self._color
+
+    @color.setter
+    def color(self, color=(0, 0, 0, 255)):
+        self._color = color
+        self.update()
+
+    @property
+    def border_color(self):
+        return self._border_color
+
+    @border_color.setter
+    def border_color(self, color=(0, 0, 0, 255)):
+        self._border_color = color
+
+    @property
+    def border_size(self):
+        return self._border_size
+
+    @border_size.setter
+    def border_size(self, size=2):
+        self._border_size = size
+
+    @property
+    def locked(self):
+        return self._locked
+
+    @locked.setter
+    def locked(self, value=False):
+        self._locked = value
+        conn_type = 'multi' if self.multi_connection else 'single'
+        tooltip = '{}: ({})'.format(self.name, conn_type)
+        if value:
+            tooltip += ' (L)'
+        self.setToolTip(tooltip)
+
+    @property
+    def multi_connection(self):
+        return self._multi_connection
+
+    @multi_connection.setter
+    def multi_connection(self, mode=False):
+        conn_type = 'multi' if mode else 'single'
+        self.setToolTip('{}: ({})'.format(self.name, conn_type))
+        self._multi_connection = mode
+
+    @property
+    def port_type(self):
+        return self._port_type
+
+    @port_type.setter
+    def port_type(self, port_type):
+        self._port_type = port_type
+
+    def connect_to(self, port):
+        if not port:
+            for pipe in self.connected_pipes:
+                pipe.delete()
+            return
+        if self.scene():
+            viewer = self.scene().viewer()
+            viewer.establish_connection(self, port)
+        # redraw the ports.
+        port.update()
+        self.update()
+
+    def disconnect_from(self, port):
+        port_types = {
+            PortTypeEnum.IN.value: 'output_port',
+            PortTypeEnum.OUT.value: 'input_port'
+        }
+        for pipe in self.connected_pipes:
+            connected_port = getattr(pipe, port_types[self.port_type])
+            if connected_port == port:
+                pipe.delete()
+                break
+        # redraw the ports.
+        port.update()
+        self.update()
+
+
+class CustomPortItem(PortItem):
+    """
+    Custom port item for drawing custom shape port.
+    """
+
+    def __init__(self, parent=None, paint_func=None):
+        super(CustomPortItem, self).__init__(parent)
+        self._port_painter = paint_func
+
+    def set_painter(self, func=None):
+        """
+        Set custom paint function for drawing.
+
+        Args:
+            func (function): paint function.
+        """
+        self._port_painter = func
+
+    def paint(self, painter, option, widget):
+        """
+        Draws the port item.
+
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        if self._port_painter:
+            rect_w = self._width / 1.8
+            rect_h = self._height / 1.8
+            rect_x = self.boundingRect().center().x() - (rect_w / 2)
+            rect_y = self.boundingRect().center().y() - (rect_h / 2)
+            port_rect = QtCore.QRectF(rect_x, rect_y, rect_w, rect_h)
+            port_info = {
+                'port_type': self.port_type,
+                'color': self.color,
+                'border_color': self.border_color,
+                'multi_connection': self.multi_connection,
+                'connected': bool(self.connected_pipes),
+                'hovered': self.hovered,
+                'locked': self.locked,
+            }
+            self._port_painter(painter, port_rect, port_info)
+        else:
+            super(CustomPortItem, self).paint(painter, option, widget)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/qgraphics/slicer.py` & `NodeGraphQt-0.6.3/NodeGraphQt/qgraphics/slicer.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,87 +1,87 @@
-#!/usr/bin/python
-import math
-
-from Qt import QtCore, QtGui, QtWidgets
-
-from NodeGraphQt.constants import Z_VAL_NODE_WIDGET, PipeSlicerEnum
-
-
-class SlicerPipeItem(QtWidgets.QGraphicsPathItem):
-    """
-    Base item used for drawing the pipe connection slicer.
-    """
-
-    def __init__(self):
-        super(SlicerPipeItem, self).__init__()
-        self.setZValue(Z_VAL_NODE_WIDGET + 2)
-
-    def paint(self, painter, option, widget):
-        """
-        Draws the slicer pipe.
-
-        Args:
-            painter (QtGui.QPainter): painter used for drawing the item.
-            option (QtGui.QStyleOptionGraphicsItem):
-                used to describe the parameters needed to draw.
-            widget (QtWidgets.QWidget): not used.
-        """
-        color = QtGui.QColor(*PipeSlicerEnum.COLOR.value)
-        p1 = self.path().pointAtPercent(0)
-        p2 = self.path().pointAtPercent(1)
-        size = 6.0
-        offset = size / 2
-        arrow_size = 4.0
-
-        painter.save()
-        painter.setRenderHint(painter.Antialiasing, True)
-
-        font = painter.font()
-        font.setPointSize(12)
-        painter.setFont(font)
-        text = 'slice'
-        text_x = painter.fontMetrics().width(text) / 2
-        text_y = painter.fontMetrics().height() / 1.5
-        text_pos = QtCore.QPointF(p1.x() - text_x, p1.y() - text_y)
-        text_color = QtGui.QColor(*PipeSlicerEnum.COLOR.value)
-        text_color.setAlpha(80)
-        painter.setPen(QtGui.QPen(
-            text_color, PipeSlicerEnum.WIDTH.value, QtCore.Qt.SolidLine
-        ))
-        painter.drawText(text_pos, text)
-
-        painter.setPen(QtGui.QPen(
-            color, PipeSlicerEnum.WIDTH.value, QtCore.Qt.DashDotLine
-        ))
-        painter.drawPath(self.path())
-
-        pen = QtGui.QPen(
-            color, PipeSlicerEnum.WIDTH.value, QtCore.Qt.SolidLine
-        )
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        pen.setJoinStyle(QtCore.Qt.MiterJoin)
-        painter.setPen(pen)
-        painter.setBrush(color)
-
-        rect = QtCore.QRectF(p1.x() - offset, p1.y() - offset, size, size)
-        painter.drawEllipse(rect)
-
-        arrow = QtGui.QPolygonF()
-        arrow.append(QtCore.QPointF(-arrow_size, arrow_size))
-        arrow.append(QtCore.QPointF(0.0, -arrow_size * 0.9))
-        arrow.append(QtCore.QPointF(arrow_size, arrow_size))
-
-        transform = QtGui.QTransform()
-        transform.translate(p2.x(), p2.y())
-        radians = math.atan2(p2.y() - p1.y(),
-                             p2.x() - p1.x())
-        degrees = math.degrees(radians) - 90
-        transform.rotate(degrees)
-
-        painter.drawPolygon(transform.map(arrow))
-        painter.restore()
-
-    def draw_path(self, p1, p2):
-        path = QtGui.QPainterPath()
-        path.moveTo(p1)
-        path.lineTo(p2)
-        self.setPath(path)
+#!/usr/bin/python
+import math
+
+from Qt import QtCore, QtGui, QtWidgets
+
+from NodeGraphQt.constants import Z_VAL_NODE_WIDGET, PipeSlicerEnum
+
+
+class SlicerPipeItem(QtWidgets.QGraphicsPathItem):
+    """
+    Base item used for drawing the pipe connection slicer.
+    """
+
+    def __init__(self):
+        super(SlicerPipeItem, self).__init__()
+        self.setZValue(Z_VAL_NODE_WIDGET + 2)
+
+    def paint(self, painter, option, widget):
+        """
+        Draws the slicer pipe.
+
+        Args:
+            painter (QtGui.QPainter): painter used for drawing the item.
+            option (QtGui.QStyleOptionGraphicsItem):
+                used to describe the parameters needed to draw.
+            widget (QtWidgets.QWidget): not used.
+        """
+        color = QtGui.QColor(*PipeSlicerEnum.COLOR.value)
+        p1 = self.path().pointAtPercent(0)
+        p2 = self.path().pointAtPercent(1)
+        size = 6.0
+        offset = size / 2
+        arrow_size = 4.0
+
+        painter.save()
+        painter.setRenderHint(painter.Antialiasing, True)
+
+        font = painter.font()
+        font.setPointSize(12)
+        painter.setFont(font)
+        text = 'slice'
+        text_x = painter.fontMetrics().width(text) / 2
+        text_y = painter.fontMetrics().height() / 1.5
+        text_pos = QtCore.QPointF(p1.x() - text_x, p1.y() - text_y)
+        text_color = QtGui.QColor(*PipeSlicerEnum.COLOR.value)
+        text_color.setAlpha(80)
+        painter.setPen(QtGui.QPen(
+            text_color, PipeSlicerEnum.WIDTH.value, QtCore.Qt.SolidLine
+        ))
+        painter.drawText(text_pos, text)
+
+        painter.setPen(QtGui.QPen(
+            color, PipeSlicerEnum.WIDTH.value, QtCore.Qt.DashDotLine
+        ))
+        painter.drawPath(self.path())
+
+        pen = QtGui.QPen(
+            color, PipeSlicerEnum.WIDTH.value, QtCore.Qt.SolidLine
+        )
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        pen.setJoinStyle(QtCore.Qt.MiterJoin)
+        painter.setPen(pen)
+        painter.setBrush(color)
+
+        rect = QtCore.QRectF(p1.x() - offset, p1.y() - offset, size, size)
+        painter.drawEllipse(rect)
+
+        arrow = QtGui.QPolygonF()
+        arrow.append(QtCore.QPointF(-arrow_size, arrow_size))
+        arrow.append(QtCore.QPointF(0.0, -arrow_size * 0.9))
+        arrow.append(QtCore.QPointF(arrow_size, arrow_size))
+
+        transform = QtGui.QTransform()
+        transform.translate(p2.x(), p2.y())
+        radians = math.atan2(p2.y() - p1.y(),
+                             p2.x() - p1.x())
+        degrees = math.degrees(radians) - 90
+        transform.rotate(degrees)
+
+        painter.drawPolygon(transform.map(arrow))
+        painter.restore()
+
+    def draw_path(self, p1, p2):
+        path = QtGui.QPainterPath()
+        path.moveTo(p1)
+        path.lineTo(p2)
+        self.setPath(path)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/actions.py` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/actions.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,107 +1,107 @@
-#!/usr/bin/python
-from Qt import QtCore, QtWidgets
-
-from NodeGraphQt.constants import ViewerEnum
-
-
-class BaseMenu(QtWidgets.QMenu):
-
-    def __init__(self, *args, **kwargs):
-        super(BaseMenu, self).__init__(*args, **kwargs)
-        # text_color = self.palette().text().color().getRgb()
-        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
-                               ViewerEnum.BACKGROUND_COLOR.value))
-        selected_color = self.palette().highlight().color().getRgb()
-        style_dict = {
-            'QMenu': {
-                'color': 'rgb({0},{1},{2})'.format(*text_color),
-                'background-color': 'rgb({0},{1},{2})'.format(
-                    *ViewerEnum.BACKGROUND_COLOR.value
-                ),
-                'border': '1px solid rgba({0},{1},{2},30)'.format(*text_color),
-                'border-radius': '3px',
-            },
-            'QMenu::item': {
-                'padding': '5px 18px 2px',
-                'background-color': 'transparent',
-            },
-            'QMenu::item:selected': {
-                'color': 'rgb({0},{1},{2})'.format(*text_color),
-                'background-color': 'rgba({0},{1},{2},200)'
-                                    .format(*selected_color),
-            },
-            'QMenu::separator': {
-                'height': '1px',
-                'background': 'rgba({0},{1},{2}, 50)'.format(*text_color),
-                'margin': '4px 8px',
-            }
-        }
-        stylesheet = ''
-        for css_class, css in style_dict.items():
-            style = '{} {{\n'.format(css_class)
-            for elm_name, elm_val in css.items():
-                style += '  {}:{};\n'.format(elm_name, elm_val)
-            style += '}\n'
-            stylesheet += style
-        self.setStyleSheet(stylesheet)
-        self.node_class = None
-        self.graph = None
-
-    # disable for issue #142
-    # def hideEvent(self, event):
-    #     super(BaseMenu, self).hideEvent(event)
-    #     for a in self.actions():
-    #         if hasattr(a, 'node_id'):
-    #             a.node_id = None
-
-    def get_menu(self, name, node_id=None):
-        for action in self.actions():
-            menu = action.menu()
-            if not menu:
-                continue
-            if menu.title() == name:
-                return menu
-            if node_id and menu.node_class:
-                node = menu.graph.get_node_by_id(node_id)
-                if isinstance(node, menu.node_class):
-                    return menu
-
-    def get_menus(self, node_class):
-        menus = []
-        for action in self.actions():
-            menu = action.menu()
-            if menu.node_class:
-                if issubclass(menu.node_class, node_class):
-                    menus.append(menu)
-        return menus
-
-
-class GraphAction(QtWidgets.QAction):
-
-    executed = QtCore.Signal(object)
-
-    def __init__(self, *args, **kwargs):
-        super(GraphAction, self).__init__(*args, **kwargs)
-        self.graph = None
-        self.triggered.connect(self._on_triggered)
-
-    def _on_triggered(self):
-        self.executed.emit(self.graph)
-
-    def get_action(self, name):
-        for action in self.qmenu.actions():
-            if not action.menu() and action.text() == name:
-                return action
-
-
-class NodeAction(GraphAction):
-
-    executed = QtCore.Signal(object, object)
-
-    def __init__(self, *args, **kwargs):
-        super(NodeAction, self).__init__(*args, **kwargs)
-        self.node_id = None
-
-    def _on_triggered(self):
-        node = self.graph.get_node_by_id(self.node_id)
-        self.executed.emit(self.graph, node)
+#!/usr/bin/python
+from Qt import QtCore, QtWidgets
+
+from NodeGraphQt.constants import ViewerEnum
+
+
+class BaseMenu(QtWidgets.QMenu):
+
+    def __init__(self, *args, **kwargs):
+        super(BaseMenu, self).__init__(*args, **kwargs)
+        # text_color = self.palette().text().color().getRgb()
+        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
+                               ViewerEnum.BACKGROUND_COLOR.value))
+        selected_color = self.palette().highlight().color().getRgb()
+        style_dict = {
+            'QMenu': {
+                'color': 'rgb({0},{1},{2})'.format(*text_color),
+                'background-color': 'rgb({0},{1},{2})'.format(
+                    *ViewerEnum.BACKGROUND_COLOR.value
+                ),
+                'border': '1px solid rgba({0},{1},{2},30)'.format(*text_color),
+                'border-radius': '3px',
+            },
+            'QMenu::item': {
+                'padding': '5px 18px 2px',
+                'background-color': 'transparent',
+            },
+            'QMenu::item:selected': {
+                'color': 'rgb({0},{1},{2})'.format(*text_color),
+                'background-color': 'rgba({0},{1},{2},200)'
+                                    .format(*selected_color),
+            },
+            'QMenu::separator': {
+                'height': '1px',
+                'background': 'rgba({0},{1},{2}, 50)'.format(*text_color),
+                'margin': '4px 8px',
+            }
+        }
+        stylesheet = ''
+        for css_class, css in style_dict.items():
+            style = '{} {{\n'.format(css_class)
+            for elm_name, elm_val in css.items():
+                style += '  {}:{};\n'.format(elm_name, elm_val)
+            style += '}\n'
+            stylesheet += style
+        self.setStyleSheet(stylesheet)
+        self.node_class = None
+        self.graph = None
+
+    # disable for issue #142
+    # def hideEvent(self, event):
+    #     super(BaseMenu, self).hideEvent(event)
+    #     for a in self.actions():
+    #         if hasattr(a, 'node_id'):
+    #             a.node_id = None
+
+    def get_menu(self, name, node_id=None):
+        for action in self.actions():
+            menu = action.menu()
+            if not menu:
+                continue
+            if menu.title() == name:
+                return menu
+            if node_id and menu.node_class:
+                node = menu.graph.get_node_by_id(node_id)
+                if isinstance(node, menu.node_class):
+                    return menu
+
+    def get_menus(self, node_class):
+        menus = []
+        for action in self.actions():
+            menu = action.menu()
+            if menu.node_class:
+                if issubclass(menu.node_class, node_class):
+                    menus.append(menu)
+        return menus
+
+
+class GraphAction(QtWidgets.QAction):
+
+    executed = QtCore.Signal(object)
+
+    def __init__(self, *args, **kwargs):
+        super(GraphAction, self).__init__(*args, **kwargs)
+        self.graph = None
+        self.triggered.connect(self._on_triggered)
+
+    def _on_triggered(self):
+        self.executed.emit(self.graph)
+
+    def get_action(self, name):
+        for action in self.qmenu.actions():
+            if not action.menu() and action.text() == name:
+                return action
+
+
+class NodeAction(GraphAction):
+
+    executed = QtCore.Signal(object, object)
+
+    def __init__(self, *args, **kwargs):
+        super(NodeAction, self).__init__(*args, **kwargs)
+        self.node_id = None
+
+    def _on_triggered(self):
+        node = self.graph.get_node_by_id(self.node_id)
+        self.executed.emit(self.graph, node)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/dialogs.py` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/dialogs.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-import os
-
-from Qt import QtWidgets
-
-_current_user_directory = os.path.expanduser('~')
-
-
-def set_dir(file):
-    global _current_user_directory
-    if os.path.isdir(file):
-        _current_user_directory = file
-    elif os.path.isfile(file):
-        _current_user_directory = os.path.split(file)[0]
-
-
-class FileDialog(object):
-
-    @staticmethod
-    def getSaveFileName(parent=None, title='Save File', file_dir=None,
-                        ext_filter='*'):
-        if not file_dir:
-            file_dir = _current_user_directory
-        file_dlg = QtWidgets.QFileDialog.getSaveFileName(
-            parent, title, file_dir, ext_filter)
-        file = file_dlg[0] or None
-        if file:
-            set_dir(file)
-        return file_dlg
-
-    @staticmethod
-    def getOpenFileName(parent=None, title='Open File', file_dir=None,
-                        ext_filter='*'):
-        if not file_dir:
-            file_dir = _current_user_directory
-        file_dlg = QtWidgets.QFileDialog.getOpenFileName(
-            parent, title, file_dir, ext_filter)
-        file = file_dlg[0] or None
-        if file:
-            set_dir(file)
-        return file_dlg
-
-
-class BaseDialog(object):
-
-    @staticmethod
-    def message_dialog(text='', title='Message'):
-        dlg = QtWidgets.QMessageBox()
-        dlg.setWindowTitle(title)
-        dlg.setInformativeText(text)
-        dlg.setStandardButtons(QtWidgets.QMessageBox.Ok)
-        dlg.exec_()
-
-    @staticmethod
-    def question_dialog(text='', title='Are you sure?'):
-        dlg = QtWidgets.QMessageBox()
-        dlg.setWindowTitle(title)
-        dlg.setInformativeText(text)
-        dlg.setStandardButtons(
-            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
-        )
-        result = dlg.exec_()
-        return bool(result == QtWidgets.QMessageBox.Yes)
+import os
+
+from Qt import QtWidgets
+
+_current_user_directory = os.path.expanduser('~')
+
+
+def set_dir(file):
+    global _current_user_directory
+    if os.path.isdir(file):
+        _current_user_directory = file
+    elif os.path.isfile(file):
+        _current_user_directory = os.path.split(file)[0]
+
+
+class FileDialog(object):
+
+    @staticmethod
+    def getSaveFileName(parent=None, title='Save File', file_dir=None,
+                        ext_filter='*'):
+        if not file_dir:
+            file_dir = _current_user_directory
+        file_dlg = QtWidgets.QFileDialog.getSaveFileName(
+            parent, title, file_dir, ext_filter)
+        file = file_dlg[0] or None
+        if file:
+            set_dir(file)
+        return file_dlg
+
+    @staticmethod
+    def getOpenFileName(parent=None, title='Open File', file_dir=None,
+                        ext_filter='*'):
+        if not file_dir:
+            file_dir = _current_user_directory
+        file_dlg = QtWidgets.QFileDialog.getOpenFileName(
+            parent, title, file_dir, ext_filter)
+        file = file_dlg[0] or None
+        if file:
+            set_dir(file)
+        return file_dlg
+
+
+class BaseDialog(object):
+
+    @staticmethod
+    def message_dialog(text='', title='Message'):
+        dlg = QtWidgets.QMessageBox()
+        dlg.setWindowTitle(title)
+        dlg.setInformativeText(text)
+        dlg.setStandardButtons(QtWidgets.QMessageBox.Ok)
+        dlg.exec_()
+
+    @staticmethod
+    def question_dialog(text='', title='Are you sure?'):
+        dlg = QtWidgets.QMessageBox()
+        dlg.setWindowTitle(title)
+        dlg.setInformativeText(text)
+        dlg.setStandardButtons(
+            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
+        )
+        result = dlg.exec_()
+        return bool(result == QtWidgets.QMessageBox.Yes)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/icons/node_base.png` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/icons/node_base.png`

 * *Files identical despite different names*

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/node_graph.py` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/node_graph.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,125 +1,125 @@
-from Qt import QtWidgets, QtGui
-
-from NodeGraphQt.constants import (
-    NodeEnum, ViewerEnum, ViewerNavEnum
-)
-
-from NodeGraphQt.widgets.viewer_nav import NodeNavigationWidget
-
-
-class NodeGraphWidget(QtWidgets.QTabWidget):
-
-    def __init__(self, parent=None):
-        super(NodeGraphWidget, self).__init__(parent)
-        self.setTabsClosable(True)
-        self.setTabBarAutoHide(True)
-        bg_color = QtGui.QColor(
-            *ViewerEnum.BACKGROUND_COLOR.value).darker(120).getRgb()
-        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255), bg_color))
-        style_dict = {
-            'QWidget': {
-                'background-color': 'rgb({0},{1},{2})'.format(
-                    *ViewerEnum.BACKGROUND_COLOR.value
-                ),
-            },
-            'QTabWidget::pane': {
-                'background': 'rgb({0},{1},{2})'.format(
-                    *ViewerEnum.BACKGROUND_COLOR.value
-                ),
-                'border': '0px',
-                'border-top': '0px solid rgb({0},{1},{2})'.format(*bg_color),
-            },
-            'QTabBar::tab': {
-                'background': 'rgb({0},{1},{2})'.format(*bg_color),
-                'border': '0px solid black',
-                'color': 'rgba({0},{1},{2},30)'.format(*text_color),
-                'min-width': '10px',
-                'padding': '10px 20px',
-            },
-            'QTabBar::tab:selected': {
-                'color': 'rgb({0},{1},{2})'.format(*text_color),
-                'background': 'rgb({0},{1},{2})'.format(
-                    *ViewerNavEnum.BACKGROUND_COLOR.value
-                ),
-                'border-top': '1px solid rgb({0},{1},{2})'
-                              .format(*NodeEnum.SELECTED_BORDER_COLOR.value),
-            },
-            'QTabBar::tab:hover': {
-                'color': 'rgb({0},{1},{2})'.format(*text_color),
-                'border-top': '1px solid rgb({0},{1},{2})'
-                              .format(*NodeEnum.SELECTED_BORDER_COLOR.value),
-            }
-        }
-        stylesheet = ''
-        for css_class, css in style_dict.items():
-            style = '{} {{\n'.format(css_class)
-            for elm_name, elm_val in css.items():
-                style += '  {}:{};\n'.format(elm_name, elm_val)
-            style += '}\n'
-            stylesheet += style
-        self.setStyleSheet(stylesheet)
-
-    def add_viewer(self, viewer, name, node_id):
-        self.addTab(viewer, name)
-        index = self.indexOf(viewer)
-        self.setTabToolTip(index, node_id)
-        self.setCurrentIndex(index)
-
-    def remove_viewer(self, viewer):
-        index = self.indexOf(viewer)
-        self.removeTab(index)
-
-
-class SubGraphWidget(QtWidgets.QWidget):
-
-    def __init__(self, parent=None, graph=None):
-        super(SubGraphWidget, self).__init__(parent)
-        self._graph = graph
-        self._navigator = NodeNavigationWidget()
-        self._layout = QtWidgets.QVBoxLayout(self)
-        self._layout.setContentsMargins(0, 0, 0, 0)
-        self._layout.setSpacing(1)
-        self._layout.addWidget(self._navigator)
-
-        self._viewer_widgets = {}
-        self._viewer_current = None
-
-    @property
-    def navigator(self):
-        return self._navigator
-
-    def add_viewer(self, viewer, name, node_id):
-        if viewer in self._viewer_widgets:
-            return
-
-        if self._viewer_current:
-            self.hide_viewer(self._viewer_current)
-
-        self._navigator.add_label_item(name, node_id)
-        self._layout.addWidget(viewer)
-        self._viewer_widgets[viewer] = node_id
-        self._viewer_current = viewer
-        self._viewer_current.show()
-
-    def remove_viewer(self, viewer=None):
-        if viewer is None and self._viewer_current:
-            viewer = self._viewer_current
-        node_id = self._viewer_widgets.pop(viewer)
-        self._navigator.remove_label_item(node_id)
-        self._layout.removeWidget(viewer)
-        viewer.deleteLater()
-
-    def hide_viewer(self, viewer):
-        self._layout.removeWidget(viewer)
-        viewer.hide()
-
-    def show_viewer(self, viewer):
-        if viewer == self._viewer_current:
-            self._viewer_current.show()
-            return
-        if viewer in self._viewer_widgets:
-            if self._viewer_current:
-                self.hide_viewer(self._viewer_current)
-            self._layout.addWidget(viewer)
-            self._viewer_current = viewer
-            self._viewer_current.show()
+from Qt import QtWidgets, QtGui
+
+from NodeGraphQt.constants import (
+    NodeEnum, ViewerEnum, ViewerNavEnum
+)
+
+from NodeGraphQt.widgets.viewer_nav import NodeNavigationWidget
+
+
+class NodeGraphWidget(QtWidgets.QTabWidget):
+
+    def __init__(self, parent=None):
+        super(NodeGraphWidget, self).__init__(parent)
+        self.setTabsClosable(True)
+        self.setTabBarAutoHide(True)
+        bg_color = QtGui.QColor(
+            *ViewerEnum.BACKGROUND_COLOR.value).darker(120).getRgb()
+        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255), bg_color))
+        style_dict = {
+            'QWidget': {
+                'background-color': 'rgb({0},{1},{2})'.format(
+                    *ViewerEnum.BACKGROUND_COLOR.value
+                ),
+            },
+            'QTabWidget::pane': {
+                'background': 'rgb({0},{1},{2})'.format(
+                    *ViewerEnum.BACKGROUND_COLOR.value
+                ),
+                'border': '0px',
+                'border-top': '0px solid rgb({0},{1},{2})'.format(*bg_color),
+            },
+            'QTabBar::tab': {
+                'background': 'rgb({0},{1},{2})'.format(*bg_color),
+                'border': '0px solid black',
+                'color': 'rgba({0},{1},{2},30)'.format(*text_color),
+                'min-width': '10px',
+                'padding': '10px 20px',
+            },
+            'QTabBar::tab:selected': {
+                'color': 'rgb({0},{1},{2})'.format(*text_color),
+                'background': 'rgb({0},{1},{2})'.format(
+                    *ViewerNavEnum.BACKGROUND_COLOR.value
+                ),
+                'border-top': '1px solid rgb({0},{1},{2})'
+                              .format(*NodeEnum.SELECTED_BORDER_COLOR.value),
+            },
+            'QTabBar::tab:hover': {
+                'color': 'rgb({0},{1},{2})'.format(*text_color),
+                'border-top': '1px solid rgb({0},{1},{2})'
+                              .format(*NodeEnum.SELECTED_BORDER_COLOR.value),
+            }
+        }
+        stylesheet = ''
+        for css_class, css in style_dict.items():
+            style = '{} {{\n'.format(css_class)
+            for elm_name, elm_val in css.items():
+                style += '  {}:{};\n'.format(elm_name, elm_val)
+            style += '}\n'
+            stylesheet += style
+        self.setStyleSheet(stylesheet)
+
+    def add_viewer(self, viewer, name, node_id):
+        self.addTab(viewer, name)
+        index = self.indexOf(viewer)
+        self.setTabToolTip(index, node_id)
+        self.setCurrentIndex(index)
+
+    def remove_viewer(self, viewer):
+        index = self.indexOf(viewer)
+        self.removeTab(index)
+
+
+class SubGraphWidget(QtWidgets.QWidget):
+
+    def __init__(self, parent=None, graph=None):
+        super(SubGraphWidget, self).__init__(parent)
+        self._graph = graph
+        self._navigator = NodeNavigationWidget()
+        self._layout = QtWidgets.QVBoxLayout(self)
+        self._layout.setContentsMargins(0, 0, 0, 0)
+        self._layout.setSpacing(1)
+        self._layout.addWidget(self._navigator)
+
+        self._viewer_widgets = {}
+        self._viewer_current = None
+
+    @property
+    def navigator(self):
+        return self._navigator
+
+    def add_viewer(self, viewer, name, node_id):
+        if viewer in self._viewer_widgets:
+            return
+
+        if self._viewer_current:
+            self.hide_viewer(self._viewer_current)
+
+        self._navigator.add_label_item(name, node_id)
+        self._layout.addWidget(viewer)
+        self._viewer_widgets[viewer] = node_id
+        self._viewer_current = viewer
+        self._viewer_current.show()
+
+    def remove_viewer(self, viewer=None):
+        if viewer is None and self._viewer_current:
+            viewer = self._viewer_current
+        node_id = self._viewer_widgets.pop(viewer)
+        self._navigator.remove_label_item(node_id)
+        self._layout.removeWidget(viewer)
+        viewer.deleteLater()
+
+    def hide_viewer(self, viewer):
+        self._layout.removeWidget(viewer)
+        viewer.hide()
+
+    def show_viewer(self, viewer):
+        if viewer == self._viewer_current:
+            self._viewer_current.show()
+            return
+        if viewer in self._viewer_widgets:
+            if self._viewer_current:
+                self.hide_viewer(self._viewer_current)
+            self._layout.addWidget(viewer)
+            self._viewer_current = viewer
+            self._viewer_current.show()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/node_widgets.py` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/node_widgets.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,447 +1,447 @@
-#!/usr/bin/python
-from Qt import QtCore, QtWidgets
-
-from NodeGraphQt.constants import ViewerEnum, Z_VAL_NODE_WIDGET
-from NodeGraphQt.errors import NodeWidgetError
-
-
-class _NodeGroupBox(QtWidgets.QGroupBox):
-
-    def __init__(self, label, parent=None):
-        super(_NodeGroupBox, self).__init__(parent)
-        layout = QtWidgets.QVBoxLayout(self)
-        layout.setSpacing(1)
-        self.setTitle(label)
-
-    def setTitle(self, text):
-        margin = (0, 2, 0, 0) if text else (0, 0, 0, 0)
-        self.layout().setContentsMargins(*margin)
-        super(_NodeGroupBox, self).setTitle(text)
-
-    def setTitleAlign(self, align='center'):
-        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
-                               ViewerEnum.BACKGROUND_COLOR.value))
-        style_dict = {
-            'QGroupBox': {
-                'background-color': 'rgba(0, 0, 0, 0)',
-                'border': '0px solid rgba(0, 0, 0, 0)',
-                'margin-top': '1px',
-                'padding-bottom': '2px',
-                'padding-left': '1px',
-                'padding-right': '1px',
-                'font-size': '8pt',
-            },
-            'QGroupBox::title': {
-                'subcontrol-origin': 'margin',
-                'subcontrol-position': 'top center',
-                'color': 'rgba({0}, {1}, {2}, 100)'.format(*text_color),
-                'padding': '0px',
-            }
-        }
-        if self.title():
-            style_dict['QGroupBox']['padding-top'] = '14px'
-        else:
-            style_dict['QGroupBox']['padding-top'] = '2px'
-
-        if align == 'center':
-            style_dict['QGroupBox::title']['subcontrol-position'] = 'top center'
-        elif align == 'left':
-            style_dict['QGroupBox::title']['subcontrol-position'] += 'top left'
-            style_dict['QGroupBox::title']['margin-left'] = '4px'
-        elif align == 'right':
-            style_dict['QGroupBox::title']['subcontrol-position'] += 'top right'
-            style_dict['QGroupBox::title']['margin-right'] = '4px'
-        stylesheet = ''
-        for css_class, css in style_dict.items():
-            style = '{} {{\n'.format(css_class)
-            for elm_name, elm_val in css.items():
-                style += '  {}:{};\n'.format(elm_name, elm_val)
-            style += '}\n'
-            stylesheet += style
-        self.setStyleSheet(stylesheet)
-
-    def add_node_widget(self, widget):
-        self.layout().addWidget(widget)
-
-    def get_node_widget(self):
-        return self.layout().itemAt(0).widget()
-
-
-class NodeBaseWidget(QtWidgets.QGraphicsProxyWidget):
-    """
-    This is the main wrapper class that allows a ``QtWidgets.QWidget`` to be
-    added in a :class:`NodeGraphQt.BaseNode` object.
-
-    .. inheritance-diagram:: NodeGraphQt.NodeBaseWidget
-        :parts: 1
-
-    Args:
-        parent (NodeGraphQt.BaseNode.view): parent node view.
-        name (str): property name for the parent node.
-        label (str): label text above the embedded widget.
-    """
-
-    value_changed = QtCore.Signal(str, object)
-    """
-    Signal triggered when the ``value`` attribute has changed.
-    
-    (This is connected to the :meth: `BaseNode.set_property` function when the 
-    widget is added into the node.)
-
-    :parameters: str, object
-    :emits: property name, propety value
-    """
-
-    def __init__(self, parent=None, name=None, label=''):
-        super(NodeBaseWidget, self).__init__(parent)
-        self.setZValue(Z_VAL_NODE_WIDGET)
-        self._name = name
-        self._label = label
-        self._node = None
-
-    def setToolTip(self, tooltip):
-        tooltip = tooltip.replace('\n', '<br/>')
-        tooltip = '<b>{}</b><br/>{}'.format(self.name, tooltip)
-        super(NodeBaseWidget, self).setToolTip(tooltip)
-
-    def on_value_changed(self, *args, **kwargs):
-        """
-        This is the slot function that
-        Emits the widgets current :meth:`NodeBaseWidget.value` with the
-        :attr:`NodeBaseWidget.value_changed` signal.
-
-        Args:
-            args: not used.
-            kwargs: not used.
-
-        Emits:
-            str, object: <node_property_name>, <node_property_value>
-        """
-        self.value_changed.emit(self.get_name(), self.get_value())
-
-    @property
-    def type_(self):
-        """
-        Returns the node widget type.
-
-        Returns:
-            str: widget type.
-        """
-        return str(self.__class__.__name__)
-
-    @property
-    def node(self):
-        """
-        Returns the node object this widget is embedded in.
-        (This will return ``None`` if the widget has not been added to
-        the node yet.)
-
-        Returns:
-            NodeGraphQt.BaseNode: parent node.
-        """
-        return self._node
-
-    def get_icon(self, name):
-        """
-        Returns the default icon from the Qt framework.
-
-        Returns:
-            str: icon name.
-        """
-        return self.style().standardIcon(QtWidgets.QStyle.StandardPixmap(name))
-
-    def get_name(self):
-        """
-        Returns the parent node property name.
-
-        Returns:
-            str: property name.
-        """
-        return self._name
-
-    def set_name(self, name):
-        """
-        Set the property name for the parent node.
-
-        Important:
-            The property name must be set before the widget is added to
-            the node.
-
-        Args:
-            name (str): property name.
-        """
-        if not name:
-            return
-        if self.node:
-            raise NodeWidgetError(
-                'Can\'t set property name widget already added to a Node'
-            )
-        self._name = name
-
-    def get_value(self):
-        """
-        Returns the widgets current value.
-
-        You must re-implement this property to if you're using a custom widget.
-
-        Returns:
-            str: current property value.
-        """
-        raise NotImplementedError
-
-    def set_value(self, text):
-        """
-        Sets the widgets current value.
-
-        You must re-implement this property to if you're using a custom widget.
-
-        Args:
-            text (str): new text value.
-        """
-        raise NotImplementedError
-
-    def get_custom_widget(self):
-        """
-        Returns the embedded QWidget used in the node.
-
-        Returns:
-            QtWidgets.QWidget: nested QWidget
-        """
-        widget = self.widget()
-        return widget.get_node_widget()
-
-    def set_custom_widget(self, widget):
-        """
-        Set the custom QWidget used in the node.
-
-        Args:
-            widget (QtWidgets.QWidget): custom.
-        """
-        if self.widget():
-            raise NodeWidgetError('Custom node widget already set.')
-        group = _NodeGroupBox(self._label)
-        group.add_node_widget(widget)
-        self.setWidget(group)
-
-    def get_label(self):
-        """
-        Returns the label text displayed above the embedded node widget.
-
-        Returns:
-            str: label text.
-        """
-        return self._label
-
-    def set_label(self, label=''):
-        """
-        Sets the label text above the embedded widget.
-
-        Args:
-            label (str): new label ext.
-        """
-        if self.widget():
-            self.widget().setTitle(label)
-        self._label = label
-
-
-class NodeComboBox(NodeBaseWidget):
-    """
-    Displays as a ``QComboBox`` in a node.
-
-    .. inheritance-diagram:: NodeGraphQt.widgets.node_widgets.NodeComboBox
-        :parts: 1
-
-    .. note::
-        `To embed a` ``QComboBox`` `in a node see func:`
-        :meth:`NodeGraphQt.BaseNode.add_combo_menu`
-    """
-
-    def __init__(self, parent=None, name='', label='', items=None):
-        super(NodeComboBox, self).__init__(parent, name, label)
-        self.setZValue(Z_VAL_NODE_WIDGET + 1)
-        combo = QtWidgets.QComboBox()
-        combo.setMinimumHeight(24)
-        combo.addItems(items or [])
-        combo.currentIndexChanged.connect(self.on_value_changed)
-        combo.clearFocus()
-        self.set_custom_widget(combo)
-
-    @property
-    def type_(self):
-        return 'ComboNodeWidget'
-
-    def get_value(self):
-        """
-        Returns the widget current text.
-
-        Returns:
-            str: current text.
-        """
-        combo_widget = self.get_custom_widget()
-        return str(combo_widget.currentText())
-
-    def set_value(self, text=''):
-        combo_widget = self.get_custom_widget()
-        if type(text) is list:
-            combo_widget.clear()
-            combo_widget.addItems(text)
-            return
-        if text != self.get_value():
-            index = combo_widget.findText(text, QtCore.Qt.MatchExactly)
-            combo_widget.setCurrentIndex(index)
-
-    def add_item(self, item):
-        combo_widget = self.get_custom_widget()
-        combo_widget.addItem(item)
-
-    def add_items(self, items=None):
-        if items:
-            combo_widget = self.get_custom_widget()
-            combo_widget.addItems(items)
-
-    def all_items(self):
-        combo_widget = self.get_custom_widget()
-        return [combo_widget.itemText(i) for i in range(combo_widget.count())]
-
-    def sort_items(self, reversed=False):
-        items = sorted(self.all_items(), reverse=reversed)
-        combo_widget = self.get_custom_widget()
-        combo_widget.clear()
-        combo_widget.addItems(items)
-
-    def clear(self):
-        combo_widget = self.get_custom_widget()
-        combo_widget.clear()
-
-
-class NodeLineEdit(NodeBaseWidget):
-    """
-    Displays as a ``QLineEdit`` in a node.
-
-    .. inheritance-diagram:: NodeGraphQt.widgets.node_widgets.NodeLineEdit
-        :parts: 1
-
-    .. note::
-        `To embed a` ``QLineEdit`` `in a node see func:`
-        :meth:`NodeGraphQt.BaseNode.add_text_input`
-    """
-
-    def __init__(self, parent=None, name='', label='', text=''):
-        super(NodeLineEdit, self).__init__(parent, name, label)
-        bg_color = ViewerEnum.BACKGROUND_COLOR.value
-        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
-                               bg_color))
-        text_sel_color = text_color
-        style_dict = {
-            'QLineEdit': {
-                'background': 'rgba({0},{1},{2},20)'.format(*bg_color),
-                'border': '1px solid rgb({0},{1},{2})'
-                          .format(*ViewerEnum.GRID_COLOR.value),
-                'border-radius': '3px',
-                'color': 'rgba({0},{1},{2},150)'.format(*text_color),
-                'selection-background-color': 'rgba({0},{1},{2},100)'
-                                              .format(*text_sel_color),
-            }
-        }
-        stylesheet = ''
-        for css_class, css in style_dict.items():
-            style = '{} {{\n'.format(css_class)
-            for elm_name, elm_val in css.items():
-                style += '  {}:{};\n'.format(elm_name, elm_val)
-            style += '}\n'
-            stylesheet += style
-        ledit = QtWidgets.QLineEdit()
-        ledit.setText(text)
-        ledit.setStyleSheet(stylesheet)
-        ledit.setAlignment(QtCore.Qt.AlignCenter)
-        ledit.editingFinished.connect(self.on_value_changed)
-        ledit.clearFocus()
-        self.set_custom_widget(ledit)
-        self.widget().setMaximumWidth(140)
-
-    @property
-    def type_(self):
-        return 'LineEditNodeWidget'
-
-    def get_value(self):
-        """
-        Returns the widgets current text.
-
-        Returns:
-            str: current text.
-        """
-        return str(self.get_custom_widget().text())
-
-    def set_value(self, text=''):
-        """
-        Sets the widgets current text.
-
-        Args:
-            text (str): new text.
-        """
-        if text != self.get_value():
-            self.get_custom_widget().setText(text)
-            self.on_value_changed()
-
-
-class NodeCheckBox(NodeBaseWidget):
-    """
-    Displays as a ``QCheckBox`` in a node.
-
-    .. inheritance-diagram:: NodeGraphQt.widgets.node_widgets.NodeCheckBox
-        :parts: 1
-
-    .. note::
-        `To embed a` ``QCheckBox`` `in a node see func:`
-        :meth:`NodeGraphQt.BaseNode.add_checkbox`
-    """
-
-    def __init__(self, parent=None, name='', label='', text='', state=False):
-        super(NodeCheckBox, self).__init__(parent, name, label)
-        _cbox = QtWidgets.QCheckBox(text)
-        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
-                               ViewerEnum.BACKGROUND_COLOR.value))
-        style_dict = {
-            'QCheckBox': {
-                'color': 'rgba({0},{1},{2},150)'.format(*text_color),
-            }
-        }
-        stylesheet = ''
-        for css_class, css in style_dict.items():
-            style = '{} {{\n'.format(css_class)
-            for elm_name, elm_val in css.items():
-                style += '  {}:{};\n'.format(elm_name, elm_val)
-            style += '}\n'
-            stylesheet += style
-        _cbox.setStyleSheet(stylesheet)
-        _cbox.setChecked(state)
-        _cbox.setMinimumWidth(80)
-        font = _cbox.font()
-        font.setPointSize(11)
-        _cbox.setFont(font)
-        _cbox.stateChanged.connect(self.on_value_changed)
-        self.set_custom_widget(_cbox)
-        self.widget().setMaximumWidth(140)
-
-    @property
-    def type_(self):
-        return 'CheckboxNodeWidget'
-
-    def get_value(self):
-        """
-        Returns the widget checked state.
-
-        Returns:
-            bool: checked state.
-        """
-        return self.get_custom_widget().isChecked()
-
-    def set_value(self, state=False):
-        """
-        Sets the widget checked state.
-
-        Args:
-            state (bool): check state.
-        """
-        if state != self.get_value():
-            self.get_custom_widget().setChecked(state)
+#!/usr/bin/python
+from Qt import QtCore, QtWidgets
+
+from NodeGraphQt.constants import ViewerEnum, Z_VAL_NODE_WIDGET
+from NodeGraphQt.errors import NodeWidgetError
+
+
+class _NodeGroupBox(QtWidgets.QGroupBox):
+
+    def __init__(self, label, parent=None):
+        super(_NodeGroupBox, self).__init__(parent)
+        layout = QtWidgets.QVBoxLayout(self)
+        layout.setSpacing(1)
+        self.setTitle(label)
+
+    def setTitle(self, text):
+        margin = (0, 2, 0, 0) if text else (0, 0, 0, 0)
+        self.layout().setContentsMargins(*margin)
+        super(_NodeGroupBox, self).setTitle(text)
+
+    def setTitleAlign(self, align='center'):
+        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
+                               ViewerEnum.BACKGROUND_COLOR.value))
+        style_dict = {
+            'QGroupBox': {
+                'background-color': 'rgba(0, 0, 0, 0)',
+                'border': '0px solid rgba(0, 0, 0, 0)',
+                'margin-top': '1px',
+                'padding-bottom': '2px',
+                'padding-left': '1px',
+                'padding-right': '1px',
+                'font-size': '8pt',
+            },
+            'QGroupBox::title': {
+                'subcontrol-origin': 'margin',
+                'subcontrol-position': 'top center',
+                'color': 'rgba({0}, {1}, {2}, 100)'.format(*text_color),
+                'padding': '0px',
+            }
+        }
+        if self.title():
+            style_dict['QGroupBox']['padding-top'] = '14px'
+        else:
+            style_dict['QGroupBox']['padding-top'] = '2px'
+
+        if align == 'center':
+            style_dict['QGroupBox::title']['subcontrol-position'] = 'top center'
+        elif align == 'left':
+            style_dict['QGroupBox::title']['subcontrol-position'] += 'top left'
+            style_dict['QGroupBox::title']['margin-left'] = '4px'
+        elif align == 'right':
+            style_dict['QGroupBox::title']['subcontrol-position'] += 'top right'
+            style_dict['QGroupBox::title']['margin-right'] = '4px'
+        stylesheet = ''
+        for css_class, css in style_dict.items():
+            style = '{} {{\n'.format(css_class)
+            for elm_name, elm_val in css.items():
+                style += '  {}:{};\n'.format(elm_name, elm_val)
+            style += '}\n'
+            stylesheet += style
+        self.setStyleSheet(stylesheet)
+
+    def add_node_widget(self, widget):
+        self.layout().addWidget(widget)
+
+    def get_node_widget(self):
+        return self.layout().itemAt(0).widget()
+
+
+class NodeBaseWidget(QtWidgets.QGraphicsProxyWidget):
+    """
+    This is the main wrapper class that allows a ``QtWidgets.QWidget`` to be
+    added in a :class:`NodeGraphQt.BaseNode` object.
+
+    .. inheritance-diagram:: NodeGraphQt.NodeBaseWidget
+        :parts: 1
+
+    Args:
+        parent (NodeGraphQt.BaseNode.view): parent node view.
+        name (str): property name for the parent node.
+        label (str): label text above the embedded widget.
+    """
+
+    value_changed = QtCore.Signal(str, object)
+    """
+    Signal triggered when the ``value`` attribute has changed.
+    
+    (This is connected to the :meth: `BaseNode.set_property` function when the 
+    widget is added into the node.)
+
+    :parameters: str, object
+    :emits: property name, propety value
+    """
+
+    def __init__(self, parent=None, name=None, label=''):
+        super(NodeBaseWidget, self).__init__(parent)
+        self.setZValue(Z_VAL_NODE_WIDGET)
+        self._name = name
+        self._label = label
+        self._node = None
+
+    def setToolTip(self, tooltip):
+        tooltip = tooltip.replace('\n', '<br/>')
+        tooltip = '<b>{}</b><br/>{}'.format(self.name, tooltip)
+        super(NodeBaseWidget, self).setToolTip(tooltip)
+
+    def on_value_changed(self, *args, **kwargs):
+        """
+        This is the slot function that
+        Emits the widgets current :meth:`NodeBaseWidget.value` with the
+        :attr:`NodeBaseWidget.value_changed` signal.
+
+        Args:
+            args: not used.
+            kwargs: not used.
+
+        Emits:
+            str, object: <node_property_name>, <node_property_value>
+        """
+        self.value_changed.emit(self.get_name(), self.get_value())
+
+    @property
+    def type_(self):
+        """
+        Returns the node widget type.
+
+        Returns:
+            str: widget type.
+        """
+        return str(self.__class__.__name__)
+
+    @property
+    def node(self):
+        """
+        Returns the node object this widget is embedded in.
+        (This will return ``None`` if the widget has not been added to
+        the node yet.)
+
+        Returns:
+            NodeGraphQt.BaseNode: parent node.
+        """
+        return self._node
+
+    def get_icon(self, name):
+        """
+        Returns the default icon from the Qt framework.
+
+        Returns:
+            str: icon name.
+        """
+        return self.style().standardIcon(QtWidgets.QStyle.StandardPixmap(name))
+
+    def get_name(self):
+        """
+        Returns the parent node property name.
+
+        Returns:
+            str: property name.
+        """
+        return self._name
+
+    def set_name(self, name):
+        """
+        Set the property name for the parent node.
+
+        Important:
+            The property name must be set before the widget is added to
+            the node.
+
+        Args:
+            name (str): property name.
+        """
+        if not name:
+            return
+        if self.node:
+            raise NodeWidgetError(
+                'Can\'t set property name widget already added to a Node'
+            )
+        self._name = name
+
+    def get_value(self):
+        """
+        Returns the widgets current value.
+
+        You must re-implement this property to if you're using a custom widget.
+
+        Returns:
+            str: current property value.
+        """
+        raise NotImplementedError
+
+    def set_value(self, text):
+        """
+        Sets the widgets current value.
+
+        You must re-implement this property to if you're using a custom widget.
+
+        Args:
+            text (str): new text value.
+        """
+        raise NotImplementedError
+
+    def get_custom_widget(self):
+        """
+        Returns the embedded QWidget used in the node.
+
+        Returns:
+            QtWidgets.QWidget: nested QWidget
+        """
+        widget = self.widget()
+        return widget.get_node_widget()
+
+    def set_custom_widget(self, widget):
+        """
+        Set the custom QWidget used in the node.
+
+        Args:
+            widget (QtWidgets.QWidget): custom.
+        """
+        if self.widget():
+            raise NodeWidgetError('Custom node widget already set.')
+        group = _NodeGroupBox(self._label)
+        group.add_node_widget(widget)
+        self.setWidget(group)
+
+    def get_label(self):
+        """
+        Returns the label text displayed above the embedded node widget.
+
+        Returns:
+            str: label text.
+        """
+        return self._label
+
+    def set_label(self, label=''):
+        """
+        Sets the label text above the embedded widget.
+
+        Args:
+            label (str): new label ext.
+        """
+        if self.widget():
+            self.widget().setTitle(label)
+        self._label = label
+
+
+class NodeComboBox(NodeBaseWidget):
+    """
+    Displays as a ``QComboBox`` in a node.
+
+    .. inheritance-diagram:: NodeGraphQt.widgets.node_widgets.NodeComboBox
+        :parts: 1
+
+    .. note::
+        `To embed a` ``QComboBox`` `in a node see func:`
+        :meth:`NodeGraphQt.BaseNode.add_combo_menu`
+    """
+
+    def __init__(self, parent=None, name='', label='', items=None):
+        super(NodeComboBox, self).__init__(parent, name, label)
+        self.setZValue(Z_VAL_NODE_WIDGET + 1)
+        combo = QtWidgets.QComboBox()
+        combo.setMinimumHeight(24)
+        combo.addItems(items or [])
+        combo.currentIndexChanged.connect(self.on_value_changed)
+        combo.clearFocus()
+        self.set_custom_widget(combo)
+
+    @property
+    def type_(self):
+        return 'ComboNodeWidget'
+
+    def get_value(self):
+        """
+        Returns the widget current text.
+
+        Returns:
+            str: current text.
+        """
+        combo_widget = self.get_custom_widget()
+        return str(combo_widget.currentText())
+
+    def set_value(self, text=''):
+        combo_widget = self.get_custom_widget()
+        if type(text) is list:
+            combo_widget.clear()
+            combo_widget.addItems(text)
+            return
+        if text != self.get_value():
+            index = combo_widget.findText(text, QtCore.Qt.MatchExactly)
+            combo_widget.setCurrentIndex(index)
+
+    def add_item(self, item):
+        combo_widget = self.get_custom_widget()
+        combo_widget.addItem(item)
+
+    def add_items(self, items=None):
+        if items:
+            combo_widget = self.get_custom_widget()
+            combo_widget.addItems(items)
+
+    def all_items(self):
+        combo_widget = self.get_custom_widget()
+        return [combo_widget.itemText(i) for i in range(combo_widget.count())]
+
+    def sort_items(self, reversed=False):
+        items = sorted(self.all_items(), reverse=reversed)
+        combo_widget = self.get_custom_widget()
+        combo_widget.clear()
+        combo_widget.addItems(items)
+
+    def clear(self):
+        combo_widget = self.get_custom_widget()
+        combo_widget.clear()
+
+
+class NodeLineEdit(NodeBaseWidget):
+    """
+    Displays as a ``QLineEdit`` in a node.
+
+    .. inheritance-diagram:: NodeGraphQt.widgets.node_widgets.NodeLineEdit
+        :parts: 1
+
+    .. note::
+        `To embed a` ``QLineEdit`` `in a node see func:`
+        :meth:`NodeGraphQt.BaseNode.add_text_input`
+    """
+
+    def __init__(self, parent=None, name='', label='', text=''):
+        super(NodeLineEdit, self).__init__(parent, name, label)
+        bg_color = ViewerEnum.BACKGROUND_COLOR.value
+        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
+                               bg_color))
+        text_sel_color = text_color
+        style_dict = {
+            'QLineEdit': {
+                'background': 'rgba({0},{1},{2},20)'.format(*bg_color),
+                'border': '1px solid rgb({0},{1},{2})'
+                          .format(*ViewerEnum.GRID_COLOR.value),
+                'border-radius': '3px',
+                'color': 'rgba({0},{1},{2},150)'.format(*text_color),
+                'selection-background-color': 'rgba({0},{1},{2},100)'
+                                              .format(*text_sel_color),
+            }
+        }
+        stylesheet = ''
+        for css_class, css in style_dict.items():
+            style = '{} {{\n'.format(css_class)
+            for elm_name, elm_val in css.items():
+                style += '  {}:{};\n'.format(elm_name, elm_val)
+            style += '}\n'
+            stylesheet += style
+        ledit = QtWidgets.QLineEdit()
+        ledit.setText(text)
+        ledit.setStyleSheet(stylesheet)
+        ledit.setAlignment(QtCore.Qt.AlignCenter)
+        ledit.editingFinished.connect(self.on_value_changed)
+        ledit.clearFocus()
+        self.set_custom_widget(ledit)
+        self.widget().setMaximumWidth(140)
+
+    @property
+    def type_(self):
+        return 'LineEditNodeWidget'
+
+    def get_value(self):
+        """
+        Returns the widgets current text.
+
+        Returns:
+            str: current text.
+        """
+        return str(self.get_custom_widget().text())
+
+    def set_value(self, text=''):
+        """
+        Sets the widgets current text.
+
+        Args:
+            text (str): new text.
+        """
+        if text != self.get_value():
+            self.get_custom_widget().setText(text)
+            self.on_value_changed()
+
+
+class NodeCheckBox(NodeBaseWidget):
+    """
+    Displays as a ``QCheckBox`` in a node.
+
+    .. inheritance-diagram:: NodeGraphQt.widgets.node_widgets.NodeCheckBox
+        :parts: 1
+
+    .. note::
+        `To embed a` ``QCheckBox`` `in a node see func:`
+        :meth:`NodeGraphQt.BaseNode.add_checkbox`
+    """
+
+    def __init__(self, parent=None, name='', label='', text='', state=False):
+        super(NodeCheckBox, self).__init__(parent, name, label)
+        _cbox = QtWidgets.QCheckBox(text)
+        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
+                               ViewerEnum.BACKGROUND_COLOR.value))
+        style_dict = {
+            'QCheckBox': {
+                'color': 'rgba({0},{1},{2},150)'.format(*text_color),
+            }
+        }
+        stylesheet = ''
+        for css_class, css in style_dict.items():
+            style = '{} {{\n'.format(css_class)
+            for elm_name, elm_val in css.items():
+                style += '  {}:{};\n'.format(elm_name, elm_val)
+            style += '}\n'
+            stylesheet += style
+        _cbox.setStyleSheet(stylesheet)
+        _cbox.setChecked(state)
+        _cbox.setMinimumWidth(80)
+        font = _cbox.font()
+        font.setPointSize(11)
+        _cbox.setFont(font)
+        _cbox.stateChanged.connect(self.on_value_changed)
+        self.set_custom_widget(_cbox)
+        self.widget().setMaximumWidth(140)
+
+    @property
+    def type_(self):
+        return 'CheckboxNodeWidget'
+
+    def get_value(self):
+        """
+        Returns the widget checked state.
+
+        Returns:
+            bool: checked state.
+        """
+        return self.get_custom_widget().isChecked()
+
+    def set_value(self, state=False):
+        """
+        Sets the widget checked state.
+
+        Args:
+            state (bool): check state.
+        """
+        if state != self.get_value():
+            self.get_custom_widget().setChecked(state)
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/scene.py` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/scene.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,171 +1,171 @@
-#!/usr/bin/python
-from Qt import QtGui, QtCore, QtWidgets
-
-from NodeGraphQt.constants import ViewerEnum
-
-
-class NodeScene(QtWidgets.QGraphicsScene):
-
-    def __init__(self, parent=None):
-        super(NodeScene, self).__init__(parent)
-        self._grid_mode = ViewerEnum.GRID_DISPLAY_LINES.value
-        self._grid_color = ViewerEnum.GRID_COLOR.value
-        self._bg_color = ViewerEnum.BACKGROUND_COLOR.value
-        self.setBackgroundBrush(QtGui.QColor(*self._bg_color))
-
-    def __repr__(self):
-        cls_name = str(self.__class__.__name__)
-        return '<{}("{}") object at {}>'.format(
-            cls_name, self.viewer(), hex(id(self)))
-
-    # def _draw_text(self, painter, pen):
-    #     font = QtGui.QFont()
-    #     font.setPixelSize(48)
-    #     painter.setFont(font)
-    #     parent = self.viewer()
-    #     pos = QtCore.QPoint(20, parent.height() - 20)
-    #     painter.setPen(pen)
-    #     painter.drawText(parent.mapToScene(pos), 'Not Editable')
-
-    def _draw_grid(self, painter, rect, pen, grid_size):
-        """
-        draws the grid lines in the scene.
-
-        Args:
-            painter (QtGui.QPainter): painter object.
-            rect (QtCore.QRectF): rect object.
-            pen (QtGui.QPen): pen object.
-            grid_size (int): grid size.
-        """
-        left = int(rect.left())
-        right = int(rect.right())
-        top = int(rect.top())
-        bottom = int(rect.bottom())
-
-        first_left = left - (left % grid_size)
-        first_top = top - (top % grid_size)
-
-        lines = []
-        lines.extend([
-            QtCore.QLineF(x, top, x, bottom)
-            for x in range(first_left, right, grid_size)
-        ])
-        lines.extend([
-            QtCore.QLineF(left, y, right, y)
-            for y in range(first_top, bottom, grid_size)]
-        )
-
-        painter.setPen(pen)
-        painter.drawLines(lines)
-
-    def _draw_dots(self, painter, rect, pen, grid_size):
-        """
-        draws the grid dots in the scene.
-
-        Args:
-            painter (QtGui.QPainter): painter object.
-            rect (QtCore.QRectF): rect object.
-            pen (QtGui.QPen): pen object.
-            grid_size (int): grid size.
-        """
-        zoom = self.viewer().get_zoom()
-        if zoom < 0:
-            grid_size = int(abs(zoom) / 0.3 + 1) * grid_size
-
-        left = int(rect.left())
-        right = int(rect.right())
-        top = int(rect.top())
-        bottom = int(rect.bottom())
-
-        first_left = left - (left % grid_size)
-        first_top = top - (top % grid_size)
-
-        pen.setWidth(grid_size / 10)
-        painter.setPen(pen)
-
-        [painter.drawPoint(int(x), int(y))
-         for x in range(first_left, right, grid_size)
-         for y in range(first_top, bottom, grid_size)]
-
-    def drawBackground(self, painter, rect):
-        super(NodeScene, self).drawBackground(painter, rect)
-
-        painter.save()
-        painter.setRenderHint(QtGui.QPainter.Antialiasing, False)
-        painter.setBrush(self.backgroundBrush())
-
-        if self._grid_mode is ViewerEnum.GRID_DISPLAY_DOTS.value:
-            pen = QtGui.QPen(QtGui.QColor(*self.grid_color), 0.65)
-            self._draw_dots(painter, rect, pen, ViewerEnum.GRID_SIZE.value)
-
-        elif self._grid_mode is ViewerEnum.GRID_DISPLAY_LINES.value:
-            zoom = self.viewer().get_zoom()
-            if zoom > -0.5:
-                pen = QtGui.QPen(QtGui.QColor(*self.grid_color), 0.65)
-                self._draw_grid(
-                    painter, rect, pen, ViewerEnum.GRID_SIZE.value
-                )
-
-            color = QtGui.QColor(*self._bg_color).darker(150)
-            if zoom < -0.0:
-                color = color.darker(100 - int(zoom * 110))
-            pen = QtGui.QPen(color, 0.65)
-            self._draw_grid(
-                painter, rect, pen, ViewerEnum.GRID_SIZE.value * 8
-            )
-
-        painter.restore()
-
-    def mousePressEvent(self, event):
-        selected_nodes = self.viewer().selected_nodes()
-        if self.viewer():
-            self.viewer().sceneMousePressEvent(event)
-        super(NodeScene, self).mousePressEvent(event)
-        keep_selection = any([
-            event.button() == QtCore.Qt.MiddleButton,
-            event.button() == QtCore.Qt.RightButton,
-            event.modifiers() == QtCore.Qt.AltModifier
-        ])
-        if keep_selection:
-            for node in selected_nodes:
-                node.setSelected(True)
-
-    def mouseMoveEvent(self, event):
-        if self.viewer():
-            self.viewer().sceneMouseMoveEvent(event)
-        super(NodeScene, self).mouseMoveEvent(event)
-
-    def mouseReleaseEvent(self, event):
-        if self.viewer():
-            self.viewer().sceneMouseReleaseEvent(event)
-        super(NodeScene, self).mouseReleaseEvent(event)
-
-    def viewer(self):
-        return self.views()[0] if self.views() else None
-
-    @property
-    def grid_mode(self):
-        return self._grid_mode
-
-    @grid_mode.setter
-    def grid_mode(self, mode=None):
-        if mode is None:
-            mode = ViewerEnum.GRID_DISPLAY_LINES.value
-        self._grid_mode = mode
-
-    @property
-    def grid_color(self):
-        return self._grid_color
-
-    @grid_color.setter
-    def grid_color(self, color=(0, 0, 0)):
-        self._grid_color = color
-
-    @property
-    def background_color(self):
-        return self._bg_color
-
-    @background_color.setter
-    def background_color(self, color=(0, 0, 0)):
-        self._bg_color = color
-        self.setBackgroundBrush(QtGui.QColor(*self._bg_color))
+#!/usr/bin/python
+from Qt import QtGui, QtCore, QtWidgets
+
+from NodeGraphQt.constants import ViewerEnum
+
+
+class NodeScene(QtWidgets.QGraphicsScene):
+
+    def __init__(self, parent=None):
+        super(NodeScene, self).__init__(parent)
+        self._grid_mode = ViewerEnum.GRID_DISPLAY_LINES.value
+        self._grid_color = ViewerEnum.GRID_COLOR.value
+        self._bg_color = ViewerEnum.BACKGROUND_COLOR.value
+        self.setBackgroundBrush(QtGui.QColor(*self._bg_color))
+
+    def __repr__(self):
+        cls_name = str(self.__class__.__name__)
+        return '<{}("{}") object at {}>'.format(
+            cls_name, self.viewer(), hex(id(self)))
+
+    # def _draw_text(self, painter, pen):
+    #     font = QtGui.QFont()
+    #     font.setPixelSize(48)
+    #     painter.setFont(font)
+    #     parent = self.viewer()
+    #     pos = QtCore.QPoint(20, parent.height() - 20)
+    #     painter.setPen(pen)
+    #     painter.drawText(parent.mapToScene(pos), 'Not Editable')
+
+    def _draw_grid(self, painter, rect, pen, grid_size):
+        """
+        draws the grid lines in the scene.
+
+        Args:
+            painter (QtGui.QPainter): painter object.
+            rect (QtCore.QRectF): rect object.
+            pen (QtGui.QPen): pen object.
+            grid_size (int): grid size.
+        """
+        left = int(rect.left())
+        right = int(rect.right())
+        top = int(rect.top())
+        bottom = int(rect.bottom())
+
+        first_left = left - (left % grid_size)
+        first_top = top - (top % grid_size)
+
+        lines = []
+        lines.extend([
+            QtCore.QLineF(x, top, x, bottom)
+            for x in range(first_left, right, grid_size)
+        ])
+        lines.extend([
+            QtCore.QLineF(left, y, right, y)
+            for y in range(first_top, bottom, grid_size)]
+        )
+
+        painter.setPen(pen)
+        painter.drawLines(lines)
+
+    def _draw_dots(self, painter, rect, pen, grid_size):
+        """
+        draws the grid dots in the scene.
+
+        Args:
+            painter (QtGui.QPainter): painter object.
+            rect (QtCore.QRectF): rect object.
+            pen (QtGui.QPen): pen object.
+            grid_size (int): grid size.
+        """
+        zoom = self.viewer().get_zoom()
+        if zoom < 0:
+            grid_size = int(abs(zoom) / 0.3 + 1) * grid_size
+
+        left = int(rect.left())
+        right = int(rect.right())
+        top = int(rect.top())
+        bottom = int(rect.bottom())
+
+        first_left = left - (left % grid_size)
+        first_top = top - (top % grid_size)
+
+        pen.setWidth(grid_size / 10)
+        painter.setPen(pen)
+
+        [painter.drawPoint(int(x), int(y))
+         for x in range(first_left, right, grid_size)
+         for y in range(first_top, bottom, grid_size)]
+
+    def drawBackground(self, painter, rect):
+        super(NodeScene, self).drawBackground(painter, rect)
+
+        painter.save()
+        painter.setRenderHint(QtGui.QPainter.Antialiasing, False)
+        painter.setBrush(self.backgroundBrush())
+
+        if self._grid_mode is ViewerEnum.GRID_DISPLAY_DOTS.value:
+            pen = QtGui.QPen(QtGui.QColor(*self.grid_color), 0.65)
+            self._draw_dots(painter, rect, pen, ViewerEnum.GRID_SIZE.value)
+
+        elif self._grid_mode is ViewerEnum.GRID_DISPLAY_LINES.value:
+            zoom = self.viewer().get_zoom()
+            if zoom > -0.5:
+                pen = QtGui.QPen(QtGui.QColor(*self.grid_color), 0.65)
+                self._draw_grid(
+                    painter, rect, pen, ViewerEnum.GRID_SIZE.value
+                )
+
+            color = QtGui.QColor(*self._bg_color).darker(150)
+            if zoom < -0.0:
+                color = color.darker(100 - int(zoom * 110))
+            pen = QtGui.QPen(color, 0.65)
+            self._draw_grid(
+                painter, rect, pen, ViewerEnum.GRID_SIZE.value * 8
+            )
+
+        painter.restore()
+
+    def mousePressEvent(self, event):
+        selected_nodes = self.viewer().selected_nodes()
+        if self.viewer():
+            self.viewer().sceneMousePressEvent(event)
+        super(NodeScene, self).mousePressEvent(event)
+        keep_selection = any([
+            event.button() == QtCore.Qt.MiddleButton,
+            event.button() == QtCore.Qt.RightButton,
+            event.modifiers() == QtCore.Qt.AltModifier
+        ])
+        if keep_selection:
+            for node in selected_nodes:
+                node.setSelected(True)
+
+    def mouseMoveEvent(self, event):
+        if self.viewer():
+            self.viewer().sceneMouseMoveEvent(event)
+        super(NodeScene, self).mouseMoveEvent(event)
+
+    def mouseReleaseEvent(self, event):
+        if self.viewer():
+            self.viewer().sceneMouseReleaseEvent(event)
+        super(NodeScene, self).mouseReleaseEvent(event)
+
+    def viewer(self):
+        return self.views()[0] if self.views() else None
+
+    @property
+    def grid_mode(self):
+        return self._grid_mode
+
+    @grid_mode.setter
+    def grid_mode(self, mode=None):
+        if mode is None:
+            mode = ViewerEnum.GRID_DISPLAY_LINES.value
+        self._grid_mode = mode
+
+    @property
+    def grid_color(self):
+        return self._grid_color
+
+    @grid_color.setter
+    def grid_color(self, color=(0, 0, 0)):
+        self._grid_color = color
+
+    @property
+    def background_color(self):
+        return self._bg_color
+
+    @background_color.setter
+    def background_color(self, color=(0, 0, 0)):
+        self._bg_color = color
+        self.setBackgroundBrush(QtGui.QColor(*self._bg_color))
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/tab_search.py` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/tab_search.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,308 +1,308 @@
-#!/usr/bin/python
-import re
-from collections import OrderedDict
-
-from Qt import QtCore, QtWidgets, QtGui
-
-from NodeGraphQt.constants import ViewerEnum, ViewerNavEnum
-
-
-class TabSearchCompleter(QtWidgets.QCompleter):
-    """
-    QCompleter adapted from:
-    https://stackoverflow.com/questions/5129211/qcompleter-custom-completion-rules
-    """
-
-    def __init__(self, nodes=None, parent=None):
-        super(TabSearchCompleter, self).__init__(nodes, parent)
-        self.setCompletionMode(self.PopupCompletion)
-        self.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
-        self._local_completion_prefix = ''
-        self._using_orig_model = False
-        self._source_model = None
-        self._filter_model = None
-
-    def splitPath(self, path):
-        self._local_completion_prefix = path
-        self.updateModel()
-
-        if self._filter_model.rowCount() == 0:
-            self._using_orig_model = False
-            self._filter_model.setSourceModel(QtCore.QStringListModel([]))
-            return []
-        return []
-
-    def updateModel(self):
-        if not self._using_orig_model:
-            self._filter_model.setSourceModel(self._source_model)
-
-        pattern = QtCore.QRegExp(self._local_completion_prefix,
-                                 QtCore.Qt.CaseInsensitive,
-                                 QtCore.QRegExp.FixedString)
-        self._filter_model.setFilterRegExp(pattern)
-
-    def setModel(self, model):
-        self._source_model = model
-        self._filter_model = QtCore.QSortFilterProxyModel(self)
-        self._filter_model.setSourceModel(self._source_model)
-        super(TabSearchCompleter, self).setModel(self._filter_model)
-        self._using_orig_model = True
-
-
-class TabSearchLineEditWidget(QtWidgets.QLineEdit):
-
-    tab_pressed = QtCore.Signal()
-
-    def __init__(self, parent=None):
-        super(TabSearchLineEditWidget, self).__init__(parent)
-        self.setAttribute(QtCore.Qt.WA_MacShowFocusRect, 0)
-        self.setMinimumSize(200, 22)
-        # text_color = self.palette().text().color().getRgb()
-        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
-                               ViewerEnum.BACKGROUND_COLOR.value))
-        selected_color = self.palette().highlight().color().getRgb()
-        style_dict = {
-            'QLineEdit': {
-                'color': 'rgb({0},{1},{2})'.format(*text_color),
-                'border': '1px solid rgb({0},{1},{2})'.format(
-                    *selected_color
-                ),
-                'border-radius': '3px',
-                'padding': '2px 4px',
-                'margin': '2px 4px 8px 4px',
-                'background': 'rgb({0},{1},{2})'.format(
-                    *ViewerNavEnum.BACKGROUND_COLOR.value
-                ),
-                'selection-background-color': 'rgba({0},{1},{2},200)'
-                                              .format(*selected_color),
-            }
-        }
-        stylesheet = ''
-        for css_class, css in style_dict.items():
-            style = '{} {{\n'.format(css_class)
-            for elm_name, elm_val in css.items():
-                style += '  {}:{};\n'.format(elm_name, elm_val)
-            style += '}\n'
-            stylesheet += style
-        self.setStyleSheet(stylesheet)
-
-    def keyPressEvent(self, event):
-        super(TabSearchLineEditWidget, self).keyPressEvent(event)
-        if event.key() == QtCore.Qt.Key_Tab:
-            self.tab_pressed.emit()
-
-
-class TabSearchMenuWidget(QtWidgets.QMenu):
-
-    search_submitted = QtCore.Signal(str)
-
-    def __init__(self, node_dict=None):
-        super(TabSearchMenuWidget, self).__init__()
-
-        self.line_edit = TabSearchLineEditWidget()
-        self.line_edit.tab_pressed.connect(self._close)
-
-        self._node_dict = node_dict or {}
-        if self._node_dict:
-            self._generate_items_from_node_dict()
-
-        search_widget = QtWidgets.QWidgetAction(self)
-        search_widget.setDefaultWidget(self.line_edit)
-        self.addAction(search_widget)
-
-        # text_color = self.palette().text().color().getRgb()
-        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
-                               ViewerEnum.BACKGROUND_COLOR.value))
-        selected_color = self.palette().highlight().color().getRgb()
-        style_dict = {
-            'QMenu': {
-                'color': 'rgb({0},{1},{2})'.format(*text_color),
-                'background-color': 'rgb({0},{1},{2})'.format(
-                    *ViewerEnum.BACKGROUND_COLOR.value
-                ),
-                'border': '1px solid rgba({0},{1},{2},30)'.format(*text_color),
-                'border-radius': '3px',
-            },
-            'QMenu::item': {
-                'padding': '5px 18px 2px',
-                'background-color': 'transparent',
-            },
-            'QMenu::item:selected': {
-                'color': 'rgb({0},{1},{2})'.format(*text_color),
-                'background-color': 'rgba({0},{1},{2},200)'
-                                    .format(*selected_color),
-            },
-            'QMenu::separator': {
-                'height': '1px',
-                'background': 'rgba({0},{1},{2}, 50)'.format(*text_color),
-                'margin': '4px 8px',
-            }
-        }
-        self._menu_stylesheet = ''
-        for css_class, css in style_dict.items():
-            style = '{} {{\n'.format(css_class)
-            for elm_name, elm_val in css.items():
-                style += '  {}:{};\n'.format(elm_name, elm_val)
-            style += '}\n'
-            self._menu_stylesheet += style
-        self.setStyleSheet(self._menu_stylesheet)
-
-        self._actions = {}
-        self._menus = {}
-        self._searched_actions = []
-
-        self._block_submit = False
-
-        self.rebuild = False
-
-        self._wire_signals()
-
-    def __repr__(self):
-        return '<{} at {}>'.format(self.__class__.__name__, hex(id(self)))
-
-    def keyPressEvent(self, event):
-        super(TabSearchMenuWidget, self).keyPressEvent(event)
-        self.line_edit.keyPressEvent(event)
-
-    @staticmethod
-    def _fuzzy_finder(key, collection):
-        suggestions = []
-        pattern = '.*?'.join(key.lower())
-        regex = re.compile(pattern)
-        for item in collection:
-            match = regex.search(item.lower())
-            if match:
-                suggestions.append((len(match.group()), match.start(), item))
-
-        return [x for _, _, x in sorted(suggestions)]
-
-    def _wire_signals(self):
-        self.line_edit.returnPressed.connect(self._on_search_submitted)
-        self.line_edit.textChanged.connect(self._on_text_changed)
-
-    def _on_text_changed(self, text):
-        self._clear_actions()
-
-        if not text:
-            self._set_menu_visible(True)
-            return
-
-        self._set_menu_visible(False)
-
-        action_names = self._fuzzy_finder(text, self._actions.keys())
-
-        self._searched_actions = [self._actions[name] for name in action_names]
-        self.addActions(self._searched_actions)
-
-        if self._searched_actions:
-            self.setActiveAction(self._searched_actions[0])
-
-    def _clear_actions(self):
-        for action in self._searched_actions:
-            self.removeAction(action)
-            action.triggered.connect(self._on_search_submitted)
-        del self._searched_actions[:]
-
-    def _set_menu_visible(self, visible):
-        for menu in self._menus.values():
-            menu.menuAction().setVisible(visible)
-
-    def _close(self):
-        self._set_menu_visible(False)
-        self.setVisible(False)
-        self.menuAction().setVisible(False)
-        self._block_submit = True
-
-    def _show(self):
-        self.line_edit.setText("")
-        self.line_edit.setFocus()
-        self._set_menu_visible(True)
-        self._block_submit = False
-        self.exec_(QtGui.QCursor.pos())
-
-    def _on_search_submitted(self):
-        if not self._block_submit:
-            action = self.sender()
-            if type(action) is not QtWidgets.QAction:
-                if len(self._searched_actions) > 0:
-                    action = self._searched_actions[0]
-                else:
-                    self._close()
-                    return
-
-            text = action.text()
-            node_type = self._node_dict.get(text)
-            if node_type:
-                self.search_submitted.emit(node_type)
-
-        self._close()
-
-    def build_menu_tree(self):
-        node_types = sorted(self._node_dict.values())
-        node_names = sorted(self._node_dict.keys())
-        menu_tree = OrderedDict()
-
-        max_depth = 0
-        for node_type in node_types:
-            trees = '.'.join(node_type.split('.')[:-1]).split('::')
-            for depth, menu_name in enumerate(trees):
-                new_menu = None
-                menu_path = '::'.join(trees[:depth + 1])
-                if depth in menu_tree.keys():
-                    if menu_name not in menu_tree[depth].keys():
-                        new_menu = QtWidgets.QMenu(menu_name)
-                        new_menu.keyPressEvent = self.keyPressEvent
-                        new_menu.setStyleSheet(self._menu_stylesheet)
-                        menu_tree[depth][menu_path] = new_menu
-                else:
-                    new_menu = QtWidgets.QMenu(menu_name)
-                    new_menu.setStyleSheet(self._menu_stylesheet)
-                    menu_tree[depth] = {menu_path: new_menu}
-                if depth > 0 and new_menu:
-                    new_menu.parentPath = '::'.join(trees[:depth])
-
-                max_depth = max(max_depth, depth)
-
-        for i in range(max_depth+1):
-            menus = menu_tree[i]
-            for menu_path, menu in menus.items():
-                self._menus[menu_path] = menu
-                if i == 0:
-                    self.addMenu(menu)
-                else:
-                    parent_menu = self._menus[menu.parentPath]
-                    parent_menu.addMenu(menu)
-
-        for name in node_names:
-            action = QtWidgets.QAction(name, self)
-            action.setText(name)
-            action.triggered.connect(self._on_search_submitted)
-            self._actions[name] = action
-
-            menu_name = self._node_dict[name]
-            menu_path = '.'.join(menu_name.split('.')[:-1])
-
-            if menu_path in self._menus.keys():
-                self._menus[menu_path].addAction(action)
-            else:
-                self.addAction(action)
-
-    def set_nodes(self, node_dict=None):
-        if not self._node_dict or self.rebuild:
-            self._node_dict.clear()
-            self._clear_actions()
-            self._set_menu_visible(False)
-            for menu in self._menus.values():
-                self.removeAction(menu.menuAction())
-            self._actions.clear()
-            self._menus.clear()
-            for name, node_types in node_dict.items():
-                if len(node_types) == 1:
-                    self._node_dict[name] = node_types[0]
-                    continue
-                for node_id in node_types:
-                    self._node_dict['{} ({})'.format(name, node_id)] = node_id
-            self.build_menu_tree()
-            self.rebuild = False
-
-        self._show()
+#!/usr/bin/python
+import re
+from collections import OrderedDict
+
+from Qt import QtCore, QtWidgets, QtGui
+
+from NodeGraphQt.constants import ViewerEnum, ViewerNavEnum
+
+
+class TabSearchCompleter(QtWidgets.QCompleter):
+    """
+    QCompleter adapted from:
+    https://stackoverflow.com/questions/5129211/qcompleter-custom-completion-rules
+    """
+
+    def __init__(self, nodes=None, parent=None):
+        super(TabSearchCompleter, self).__init__(nodes, parent)
+        self.setCompletionMode(self.PopupCompletion)
+        self.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
+        self._local_completion_prefix = ''
+        self._using_orig_model = False
+        self._source_model = None
+        self._filter_model = None
+
+    def splitPath(self, path):
+        self._local_completion_prefix = path
+        self.updateModel()
+
+        if self._filter_model.rowCount() == 0:
+            self._using_orig_model = False
+            self._filter_model.setSourceModel(QtCore.QStringListModel([]))
+            return []
+        return []
+
+    def updateModel(self):
+        if not self._using_orig_model:
+            self._filter_model.setSourceModel(self._source_model)
+
+        pattern = QtCore.QRegExp(self._local_completion_prefix,
+                                 QtCore.Qt.CaseInsensitive,
+                                 QtCore.QRegExp.FixedString)
+        self._filter_model.setFilterRegExp(pattern)
+
+    def setModel(self, model):
+        self._source_model = model
+        self._filter_model = QtCore.QSortFilterProxyModel(self)
+        self._filter_model.setSourceModel(self._source_model)
+        super(TabSearchCompleter, self).setModel(self._filter_model)
+        self._using_orig_model = True
+
+
+class TabSearchLineEditWidget(QtWidgets.QLineEdit):
+
+    tab_pressed = QtCore.Signal()
+
+    def __init__(self, parent=None):
+        super(TabSearchLineEditWidget, self).__init__(parent)
+        self.setAttribute(QtCore.Qt.WA_MacShowFocusRect, 0)
+        self.setMinimumSize(200, 22)
+        # text_color = self.palette().text().color().getRgb()
+        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
+                               ViewerEnum.BACKGROUND_COLOR.value))
+        selected_color = self.palette().highlight().color().getRgb()
+        style_dict = {
+            'QLineEdit': {
+                'color': 'rgb({0},{1},{2})'.format(*text_color),
+                'border': '1px solid rgb({0},{1},{2})'.format(
+                    *selected_color
+                ),
+                'border-radius': '3px',
+                'padding': '2px 4px',
+                'margin': '2px 4px 8px 4px',
+                'background': 'rgb({0},{1},{2})'.format(
+                    *ViewerNavEnum.BACKGROUND_COLOR.value
+                ),
+                'selection-background-color': 'rgba({0},{1},{2},200)'
+                                              .format(*selected_color),
+            }
+        }
+        stylesheet = ''
+        for css_class, css in style_dict.items():
+            style = '{} {{\n'.format(css_class)
+            for elm_name, elm_val in css.items():
+                style += '  {}:{};\n'.format(elm_name, elm_val)
+            style += '}\n'
+            stylesheet += style
+        self.setStyleSheet(stylesheet)
+
+    def keyPressEvent(self, event):
+        super(TabSearchLineEditWidget, self).keyPressEvent(event)
+        if event.key() == QtCore.Qt.Key_Tab:
+            self.tab_pressed.emit()
+
+
+class TabSearchMenuWidget(QtWidgets.QMenu):
+
+    search_submitted = QtCore.Signal(str)
+
+    def __init__(self, node_dict=None):
+        super(TabSearchMenuWidget, self).__init__()
+
+        self.line_edit = TabSearchLineEditWidget()
+        self.line_edit.tab_pressed.connect(self._close)
+
+        self._node_dict = node_dict or {}
+        if self._node_dict:
+            self._generate_items_from_node_dict()
+
+        search_widget = QtWidgets.QWidgetAction(self)
+        search_widget.setDefaultWidget(self.line_edit)
+        self.addAction(search_widget)
+
+        # text_color = self.palette().text().color().getRgb()
+        text_color = tuple(map(lambda i, j: i - j, (255, 255, 255),
+                               ViewerEnum.BACKGROUND_COLOR.value))
+        selected_color = self.palette().highlight().color().getRgb()
+        style_dict = {
+            'QMenu': {
+                'color': 'rgb({0},{1},{2})'.format(*text_color),
+                'background-color': 'rgb({0},{1},{2})'.format(
+                    *ViewerEnum.BACKGROUND_COLOR.value
+                ),
+                'border': '1px solid rgba({0},{1},{2},30)'.format(*text_color),
+                'border-radius': '3px',
+            },
+            'QMenu::item': {
+                'padding': '5px 18px 2px',
+                'background-color': 'transparent',
+            },
+            'QMenu::item:selected': {
+                'color': 'rgb({0},{1},{2})'.format(*text_color),
+                'background-color': 'rgba({0},{1},{2},200)'
+                                    .format(*selected_color),
+            },
+            'QMenu::separator': {
+                'height': '1px',
+                'background': 'rgba({0},{1},{2}, 50)'.format(*text_color),
+                'margin': '4px 8px',
+            }
+        }
+        self._menu_stylesheet = ''
+        for css_class, css in style_dict.items():
+            style = '{} {{\n'.format(css_class)
+            for elm_name, elm_val in css.items():
+                style += '  {}:{};\n'.format(elm_name, elm_val)
+            style += '}\n'
+            self._menu_stylesheet += style
+        self.setStyleSheet(self._menu_stylesheet)
+
+        self._actions = {}
+        self._menus = {}
+        self._searched_actions = []
+
+        self._block_submit = False
+
+        self.rebuild = False
+
+        self._wire_signals()
+
+    def __repr__(self):
+        return '<{} at {}>'.format(self.__class__.__name__, hex(id(self)))
+
+    def keyPressEvent(self, event):
+        super(TabSearchMenuWidget, self).keyPressEvent(event)
+        self.line_edit.keyPressEvent(event)
+
+    @staticmethod
+    def _fuzzy_finder(key, collection):
+        suggestions = []
+        pattern = '.*?'.join(key.lower())
+        regex = re.compile(pattern)
+        for item in collection:
+            match = regex.search(item.lower())
+            if match:
+                suggestions.append((len(match.group()), match.start(), item))
+
+        return [x for _, _, x in sorted(suggestions)]
+
+    def _wire_signals(self):
+        self.line_edit.returnPressed.connect(self._on_search_submitted)
+        self.line_edit.textChanged.connect(self._on_text_changed)
+
+    def _on_text_changed(self, text):
+        self._clear_actions()
+
+        if not text:
+            self._set_menu_visible(True)
+            return
+
+        self._set_menu_visible(False)
+
+        action_names = self._fuzzy_finder(text, self._actions.keys())
+
+        self._searched_actions = [self._actions[name] for name in action_names]
+        self.addActions(self._searched_actions)
+
+        if self._searched_actions:
+            self.setActiveAction(self._searched_actions[0])
+
+    def _clear_actions(self):
+        for action in self._searched_actions:
+            self.removeAction(action)
+            action.triggered.connect(self._on_search_submitted)
+        del self._searched_actions[:]
+
+    def _set_menu_visible(self, visible):
+        for menu in self._menus.values():
+            menu.menuAction().setVisible(visible)
+
+    def _close(self):
+        self._set_menu_visible(False)
+        self.setVisible(False)
+        self.menuAction().setVisible(False)
+        self._block_submit = True
+
+    def _show(self):
+        self.line_edit.setText("")
+        self.line_edit.setFocus()
+        self._set_menu_visible(True)
+        self._block_submit = False
+        self.exec_(QtGui.QCursor.pos())
+
+    def _on_search_submitted(self):
+        if not self._block_submit:
+            action = self.sender()
+            if type(action) is not QtWidgets.QAction:
+                if len(self._searched_actions) > 0:
+                    action = self._searched_actions[0]
+                else:
+                    self._close()
+                    return
+
+            text = action.text()
+            node_type = self._node_dict.get(text)
+            if node_type:
+                self.search_submitted.emit(node_type)
+
+        self._close()
+
+    def build_menu_tree(self):
+        node_types = sorted(self._node_dict.values())
+        node_names = sorted(self._node_dict.keys())
+        menu_tree = OrderedDict()
+
+        max_depth = 0
+        for node_type in node_types:
+            trees = '.'.join(node_type.split('.')[:-1]).split('::')
+            for depth, menu_name in enumerate(trees):
+                new_menu = None
+                menu_path = '::'.join(trees[:depth + 1])
+                if depth in menu_tree.keys():
+                    if menu_name not in menu_tree[depth].keys():
+                        new_menu = QtWidgets.QMenu(menu_name)
+                        new_menu.keyPressEvent = self.keyPressEvent
+                        new_menu.setStyleSheet(self._menu_stylesheet)
+                        menu_tree[depth][menu_path] = new_menu
+                else:
+                    new_menu = QtWidgets.QMenu(menu_name)
+                    new_menu.setStyleSheet(self._menu_stylesheet)
+                    menu_tree[depth] = {menu_path: new_menu}
+                if depth > 0 and new_menu:
+                    new_menu.parentPath = '::'.join(trees[:depth])
+
+                max_depth = max(max_depth, depth)
+
+        for i in range(max_depth+1):
+            menus = menu_tree[i]
+            for menu_path, menu in menus.items():
+                self._menus[menu_path] = menu
+                if i == 0:
+                    self.addMenu(menu)
+                else:
+                    parent_menu = self._menus[menu.parentPath]
+                    parent_menu.addMenu(menu)
+
+        for name in node_names:
+            action = QtWidgets.QAction(name, self)
+            action.setText(name)
+            action.triggered.connect(self._on_search_submitted)
+            self._actions[name] = action
+
+            menu_name = self._node_dict[name]
+            menu_path = '.'.join(menu_name.split('.')[:-1])
+
+            if menu_path in self._menus.keys():
+                self._menus[menu_path].addAction(action)
+            else:
+                self.addAction(action)
+
+    def set_nodes(self, node_dict=None):
+        if not self._node_dict or self.rebuild:
+            self._node_dict.clear()
+            self._clear_actions()
+            self._set_menu_visible(False)
+            for menu in self._menus.values():
+                self.removeAction(menu.menuAction())
+            self._actions.clear()
+            self._menus.clear()
+            for name, node_types in node_dict.items():
+                if len(node_types) == 1:
+                    self._node_dict[name] = node_types[0]
+                    continue
+                for node_id in node_types:
+                    self._node_dict['{} ({})'.format(name, node_id)] = node_id
+            self.build_menu_tree()
+            self.rebuild = False
+
+        self._show()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/viewer.py` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/viewer.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,1598 +1,1598 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-import math
-from distutils.version import LooseVersion
-
-from Qt import QtGui, QtCore, QtWidgets
-
-from NodeGraphQt.base.menu import BaseMenu
-from NodeGraphQt.constants import (
-    LayoutDirectionEnum,
-    PortTypeEnum,
-    PipeEnum,
-    PipeLayoutEnum,
-    ViewerEnum,
-    Z_VAL_PIPE,
-)
-from NodeGraphQt.qgraphics.node_abstract import AbstractNodeItem
-from NodeGraphQt.qgraphics.node_backdrop import BackdropNodeItem
-from NodeGraphQt.qgraphics.pipe import PipeItem, LivePipeItem
-from NodeGraphQt.qgraphics.port import PortItem
-from NodeGraphQt.qgraphics.slicer import SlicerPipeItem
-from NodeGraphQt.widgets.dialogs import BaseDialog, FileDialog
-from NodeGraphQt.widgets.scene import NodeScene
-from NodeGraphQt.widgets.tab_search import TabSearchMenuWidget
-
-ZOOM_MIN = -0.95
-ZOOM_MAX = 2.0
-
-
-class NodeViewer(QtWidgets.QGraphicsView):
-    """
-    The widget interface used for displaying the scene and nodes.
-
-    functions in this class should mainly be called by the
-    class:`NodeGraphQt.NodeGraph` class.
-    """
-
-    # node viewer signals.
-    # (some of these signals are called by port & node items and connected
-    # to the node graph slot functions)
-    moved_nodes = QtCore.Signal(dict)
-    search_triggered = QtCore.Signal(str, tuple)
-    connection_sliced = QtCore.Signal(list)
-    connection_changed = QtCore.Signal(list, list)
-    insert_node = QtCore.Signal(object, str, dict)
-    node_name_changed = QtCore.Signal(str, str)
-    node_backdrop_updated = QtCore.Signal(str, str, object)
-
-    # pass through signals that are translated into "NodeGraph()" signals.
-    node_selected = QtCore.Signal(str)
-    node_selection_changed = QtCore.Signal(list, list)
-    node_double_clicked = QtCore.Signal(str)
-    data_dropped = QtCore.Signal(QtCore.QMimeData, QtCore.QPoint)
-
-    def __init__(self, parent=None, undo_stack=None):
-        """
-        Args:
-            parent:
-            undo_stack (QtWidgets.QUndoStack): undo stack from the parent
-                                               graph controller.
-        """
-        super(NodeViewer, self).__init__(parent)
-
-        self.setScene(NodeScene(self))
-        self.setRenderHint(QtGui.QPainter.Antialiasing, True)
-        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
-        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
-        self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)
-        self.setCacheMode(QtWidgets.QGraphicsView.CacheBackground)
-        self.setOptimizationFlag(
-            QtWidgets.QGraphicsView.DontAdjustForAntialiasing)
-
-        self.setAcceptDrops(True)
-        self.resize(850, 800)
-
-        self._scene_range = QtCore.QRectF(
-            0, 0, self.size().width(), self.size().height())
-        self._update_scene()
-        self._last_size = self.size()
-
-        self._layout_direction = LayoutDirectionEnum.HORIZONTAL.value
-
-        self._pipe_layout = PipeLayoutEnum.CURVED.value
-        self._detached_port = None
-        self._start_port = None
-        self._origin_pos = None
-        self._previous_pos = QtCore.QPoint(int(self.width() / 2),
-                                           int(self.height() / 2))
-        self._prev_selection_nodes = []
-        self._prev_selection_pipes = []
-        self._node_positions = {}
-
-        self._rubber_band = QtWidgets.QRubberBand(
-            QtWidgets.QRubberBand.Rectangle, self
-        )
-        self._rubber_band.isActive = False
-
-        text_color = QtGui.QColor(*tuple(map(
-            lambda i, j: i - j, (255, 255, 255),
-            ViewerEnum.BACKGROUND_COLOR.value
-        )))
-        text_color.setAlpha(50)
-        self._cursor_text = QtWidgets.QGraphicsTextItem()
-        self._cursor_text.setFlag(self._cursor_text.ItemIsSelectable, False)
-        self._cursor_text.setDefaultTextColor(text_color)
-        self._cursor_text.setZValue(Z_VAL_PIPE - 1)
-        font = self._cursor_text.font()
-        font.setPointSize(7)
-        self._cursor_text.setFont(font)
-        self.scene().addItem(self._cursor_text)
-
-        self._LIVE_PIPE = LivePipeItem()
-        self._LIVE_PIPE.setVisible(False)
-        self.scene().addItem(self._LIVE_PIPE)
-
-        self._SLICER_PIPE = SlicerPipeItem()
-        self._SLICER_PIPE.setVisible(False)
-        self.scene().addItem(self._SLICER_PIPE)
-
-        self._search_widget = TabSearchMenuWidget()
-        self._search_widget.search_submitted.connect(self._on_search_submitted)
-
-        # workaround fix for shortcuts from the non-native menu.
-        # actions don't seem to trigger so we create a hidden menu bar.
-        self._ctx_menu_bar = QtWidgets.QMenuBar(self)
-        self._ctx_menu_bar.setNativeMenuBar(False)
-        # shortcuts don't work with "setVisibility(False)".
-        self._ctx_menu_bar.setMaximumSize(0, 0)
-
-        # context menus.
-        self._ctx_graph_menu = BaseMenu('NodeGraph', self)
-        self._ctx_node_menu = BaseMenu('Nodes', self)
-
-        if undo_stack:
-            self._undo_action = undo_stack.createUndoAction(self, '&Undo')
-            self._redo_action = undo_stack.createRedoAction(self, '&Redo')
-        else:
-            self._undo_action = None
-            self._redo_action = None
-
-        self._build_context_menus()
-
-        self.acyclic = True
-        self.pipe_collision = False
-        self.pipe_slicing = True
-
-        self.LMB_state = False
-        self.RMB_state = False
-        self.MMB_state = False
-        self.ALT_state = False
-        self.CTRL_state = False
-        self.SHIFT_state = False
-        self.COLLIDING_state = False
-
-        # connection constrains.
-        # TODO: maybe this should be a reference to the graph model instead?
-        self.accept_connection_types = None
-        self.reject_connection_types = None
-
-    def __repr__(self):
-        return '<{}() object at {}>'.format(
-            self.__class__.__name__, hex(id(self)))
-
-    def focusInEvent(self, event):
-        """
-        Args:
-            event (QtGui.QFocusEvent): focus event.
-        """
-        # workaround fix: Re-populate the QMenuBar so the QAction shotcuts don't
-        #                 conflict with parent existing host app.
-        self._ctx_menu_bar.addMenu(self._ctx_graph_menu)
-        self._ctx_menu_bar.addMenu(self._ctx_node_menu)
-        return super(NodeViewer, self).focusInEvent(event)
-
-    def focusOutEvent(self, event):
-        """
-        Args:
-            event (QtGui.QFocusEvent): focus event.
-        """
-        # workaround fix: Clear the QMenuBar so the QAction shotcuts don't
-        #                 conflict with existing parent host app.
-        self._ctx_menu_bar.clear()
-        return super(NodeViewer, self).focusOutEvent(event)
-
-    # --- private ---
-
-    def _build_context_menus(self):
-        """
-        Build context menu for the node graph.
-        """
-        # "node context menu" disabled by default and enabled when a action
-        # is added through the "NodesMenu" interface.
-        self._ctx_node_menu.setDisabled(True)
-
-        # add the base menus.
-        self._ctx_menu_bar.addMenu(self._ctx_graph_menu)
-        self._ctx_menu_bar.addMenu(self._ctx_node_menu)
-
-        # setup the undo and redo actions.
-        if self._undo_action and self._redo_action:
-            self._undo_action.setShortcuts(QtGui.QKeySequence.Undo)
-            self._redo_action.setShortcuts(QtGui.QKeySequence.Redo)
-            if LooseVersion(QtCore.qVersion()) >= LooseVersion('5.10'):
-                self._undo_action.setShortcutVisibleInContextMenu(True)
-                self._redo_action.setShortcutVisibleInContextMenu(True)
-
-            # undo & redo always at the top of the "node graph context menu".
-            self._ctx_graph_menu.addAction(self._undo_action)
-            self._ctx_graph_menu.addAction(self._redo_action)
-            self._ctx_graph_menu.addSeparator()
-
-    def _set_viewer_zoom(self, value, sensitivity=None, pos=None):
-        """
-        Sets the zoom level.
-
-        Args:
-            value (float): zoom factor.
-            sensitivity (float): zoom sensitivity.
-            pos (QtCore.QPoint): mapped position.
-        """
-        if pos:
-            pos = self.mapToScene(pos)
-        if sensitivity is None:
-            scale = 1.001 ** value
-            self.scale(scale, scale, pos)
-            return
-
-        if value == 0.0:
-            return
-
-        scale = (0.9 + sensitivity) if value < 0.0 else (1.1 - sensitivity)
-        zoom = self.get_zoom()
-        if ZOOM_MIN >= zoom:
-            if scale == 0.9:
-                return
-        if ZOOM_MAX <= zoom:
-            if scale == 1.1:
-                return
-        self.scale(scale, scale, pos)
-
-    def _set_viewer_pan(self, pos_x, pos_y):
-        """
-        Set the viewer in panning mode.
-
-        Args:
-            pos_x (float): x pos.
-            pos_y (float): y pos.
-        """
-        self._scene_range.adjust(pos_x, pos_y, pos_x, pos_y)
-        self._update_scene()
-
-    def scale(self, sx, sy, pos=None):
-        scale = [sx, sx]
-        center = pos or self._scene_range.center()
-        w = self._scene_range.width() / scale[0]
-        h = self._scene_range.height() / scale[1]
-        self._scene_range = QtCore.QRectF(
-            center.x() - (center.x() - self._scene_range.left()) / scale[0],
-            center.y() - (center.y() - self._scene_range.top()) / scale[1],
-            w, h
-        )
-        self._update_scene()
-
-    def _update_scene(self):
-        """
-        Redraw the scene.
-        """
-        self.setSceneRect(self._scene_range)
-        self.fitInView(self._scene_range, QtCore.Qt.KeepAspectRatio)
-
-    def _combined_rect(self, nodes):
-        """
-        Returns a QRectF with the combined size of the provided node items.
-
-        Args:
-            nodes (list[AbstractNodeItem]): list of node qgraphics items.
-
-        Returns:
-            QtCore.QRectF: combined rect
-        """
-        group = self.scene().createItemGroup(nodes)
-        rect = group.boundingRect()
-        self.scene().destroyItemGroup(group)
-        return rect
-
-    def _items_near(self, pos, item_type=None, width=20, height=20):
-        """
-        Filter node graph items from the specified position, width and
-        height area.
-
-        Args:
-            pos (QtCore.QPoint): scene pos.
-            item_type: filter item type. (optional)
-            width (int): width area.
-            height (int): height area.
-
-        Returns:
-            list: qgraphics items from the scene.
-        """
-        x, y = pos.x() - width, pos.y() - height
-        rect = QtCore.QRectF(x, y, width, height)
-        items = []
-        excl = [self._LIVE_PIPE, self._SLICER_PIPE]
-        for item in self.scene().items(rect):
-            if item in excl:
-                continue
-            if not item_type or isinstance(item, item_type):
-                items.append(item)
-        return items
-
-    def _on_search_submitted(self, node_type):
-        """
-        Slot function triggered when the ``TabSearchMenuWidget`` has
-        submitted a search.
-
-        This will emit the "search_triggered" signal and tell the parent node
-        graph to create a new node object.
-
-        Args:
-            node_type (str): node type identifier.
-        """
-        pos = self.mapToScene(self._previous_pos)
-        self.search_triggered.emit(node_type, (pos.x(), pos.y()))
-
-    def _on_pipes_sliced(self, path):
-        """
-        Triggered when the slicer pipe is active
-
-        Args:
-            path (QtGui.QPainterPath): slicer path.
-        """
-        ports = []
-        for i in self.scene().items(path):
-            if isinstance(i, PipeItem) and i != self._LIVE_PIPE:
-                if any([i.input_port.locked, i.output_port.locked]):
-                    continue
-                ports.append([i.input_port, i.output_port])
-        self.connection_sliced.emit(ports)
-
-    # --- reimplemented events ---
-
-    def resizeEvent(self, event):
-        w, h = self.size().width(), self.size().height()
-        if 0 in [w, h]:
-            self.resize(self._last_size)
-        delta = max(w / self._last_size.width(), h / self._last_size.height())
-        self._set_viewer_zoom(delta)
-        self._last_size = self.size()
-        super(NodeViewer, self).resizeEvent(event)
-
-    def contextMenuEvent(self, event):
-        self.RMB_state = False
-
-        ctx_menu = None
-        ctx_menus = self.context_menus()
-
-        if ctx_menus['nodes'].isEnabled():
-            pos = self.mapToScene(self._previous_pos)
-            items = self._items_near(pos)
-            nodes = [i for i in items if isinstance(i, AbstractNodeItem)]
-            if nodes:
-                node = nodes[0]
-                ctx_menu = ctx_menus['nodes'].get_menu(node.type_, node.id)
-                if ctx_menu:
-                    for action in ctx_menu.actions():
-                        if not action.menu():
-                            action.node_id = node.id
-
-        ctx_menu = ctx_menu or ctx_menus['graph']
-        if len(ctx_menu.actions()) > 0:
-            if ctx_menu.isEnabled():
-                ctx_menu.exec_(event.globalPos())
-            else:
-                return super(NodeViewer, self).contextMenuEvent(event)
-
-        return super(NodeViewer, self).contextMenuEvent(event)
-
-    def mousePressEvent(self, event):
-        if event.button() == QtCore.Qt.LeftButton:
-            self.LMB_state = True
-        elif event.button() == QtCore.Qt.RightButton:
-            self.RMB_state = True
-        elif event.button() == QtCore.Qt.MiddleButton:
-            self.MMB_state = True
-
-        self._origin_pos = event.pos()
-        self._previous_pos = event.pos()
-        (self._prev_selection_nodes,
-         self._prev_selection_pipes) = self.selected_items()
-
-        # close tab search
-        if self._search_widget.isVisible():
-            self.tab_search_toggle()
-
-        # cursor pos.
-        map_pos = self.mapToScene(event.pos())
-
-        # pipe slicer enabled.
-        if self.pipe_slicing:
-            slicer_mode = all([
-                self.ALT_state, self.SHIFT_state, self.LMB_state
-            ])
-            if slicer_mode:
-                self._SLICER_PIPE.draw_path(map_pos, map_pos)
-                self._SLICER_PIPE.setVisible(True)
-                return
-
-        # pan mode.
-        if self.ALT_state:
-            return
-
-        items = self._items_near(map_pos, None, 20, 20)
-        pipes = []
-        nodes = []
-        backdrop = None
-        for itm in items:
-            if isinstance(itm, PipeItem):
-                pipes.append(itm)
-            elif isinstance(itm, AbstractNodeItem):
-                if isinstance(itm, BackdropNodeItem):
-                    backdrop = itm
-                    continue
-                nodes.append(itm)
-
-        if nodes:
-            self.MMB_state = False
-
-        # record the node selection as "self.selected_nodes()" is not updated
-        # here on the mouse press event.
-        selection = set([])
-
-        if self.LMB_state:
-            # toggle extend node selection.
-            if self.SHIFT_state:
-                if items and backdrop == items[0]:
-                    backdrop.selected = not backdrop.selected
-                    if backdrop.selected:
-                        selection.add(backdrop)
-                    for n in backdrop.get_nodes():
-                        n.selected = backdrop.selected
-                        if backdrop.selected:
-                            selection.add(n)
-                else:
-                    for node in nodes:
-                        node.selected = not node.selected
-                        if node.selected:
-                            selection.add(node)
-            # unselected nodes with the "ctrl" key.
-            elif self.CTRL_state:
-                if items and backdrop == items[0]:
-                    backdrop.selected = False
-                else:
-                    for node in nodes:
-                        node.selected = False
-            # if no modifier keys then add to selection set.
-            else:
-                if backdrop:
-                    selection.add(backdrop)
-                    for n in backdrop.get_nodes():
-                        selection.add(n)
-                for node in nodes:
-                    if node.selected:
-                        selection.add(node)
-
-        selection.update(self.selected_nodes())
-
-        # update the recorded node positions.
-        self._node_positions.update({n: n.xy_pos for n in selection})
-
-        # show selection marquee.
-        if self.LMB_state and not items:
-            rect = QtCore.QRect(self._previous_pos, QtCore.QSize())
-            rect = rect.normalized()
-            map_rect = self.mapToScene(rect).boundingRect()
-            self.scene().update(map_rect)
-            self._rubber_band.setGeometry(rect)
-            self._rubber_band.isActive = True
-
-        # stop here so we don't select a node.
-        # (ctrl modifier can be used for something else in future.)
-        if self.CTRL_state:
-            return
-
-        # allow new live pipe with the shift modifier on port that allow
-        # for multi connection.
-        if self.SHIFT_state:
-            if pipes:
-                pipes[0].reset()
-                port = pipes[0].port_from_pos(map_pos, reverse=True)
-                if not port.locked and port.multi_connection:
-                    self._cursor_text.setPlainText('')
-                    self._cursor_text.setVisible(False)
-                    self.start_live_connection(port)
-
-            # return here as the default behaviour unselects nodes with
-            # the shift modifier.
-            return
-
-        if not self._LIVE_PIPE.isVisible():
-            super(NodeViewer, self).mousePressEvent(event)
-
-    def mouseReleaseEvent(self, event):
-        if event.button() == QtCore.Qt.LeftButton:
-            self.LMB_state = False
-        elif event.button() == QtCore.Qt.RightButton:
-            self.RMB_state = False
-        elif event.button() == QtCore.Qt.MiddleButton:
-            self.MMB_state = False
-
-        # hide pipe slicer.
-        if self._SLICER_PIPE.isVisible():
-            self._on_pipes_sliced(self._SLICER_PIPE.path())
-            p = QtCore.QPointF(0.0, 0.0)
-            self._SLICER_PIPE.draw_path(p, p)
-            self._SLICER_PIPE.setVisible(False)
-
-        # hide selection marquee
-        if self._rubber_band.isActive:
-            self._rubber_band.isActive = False
-            if self._rubber_band.isVisible():
-                rect = self._rubber_band.rect()
-                map_rect = self.mapToScene(rect).boundingRect()
-                self._rubber_band.hide()
-
-                rect = QtCore.QRect(self._origin_pos, event.pos()).normalized()
-                rect_items = self.scene().items(
-                    self.mapToScene(rect).boundingRect()
-                )
-                node_ids = []
-                for item in rect_items:
-                    if isinstance(item, AbstractNodeItem):
-                        node_ids.append(item.id)
-
-                # emit the node selection signals.
-                if node_ids:
-                    prev_ids = [
-                        n.id for n in self._prev_selection_nodes
-                        if not n.selected
-                    ]
-                    self.node_selected.emit(node_ids[0])
-                    self.node_selection_changed.emit(node_ids, prev_ids)
-
-                self.scene().update(map_rect)
-                return
-
-        # find position changed nodes and emit signal.
-        moved_nodes = {
-            n: xy_pos for n, xy_pos in self._node_positions.items()
-            if n.xy_pos != xy_pos
-        }
-        # only emit of node is not colliding with a pipe.
-        if moved_nodes and not self.COLLIDING_state:
-            self.moved_nodes.emit(moved_nodes)
-
-        # reset recorded positions.
-        self._node_positions = {}
-
-        # emit signal if selected node collides with pipe.
-        # Note: if collide state is true then only 1 node is selected.
-        nodes, pipes = self.selected_items()
-        if self.COLLIDING_state and nodes and pipes:
-            self.insert_node.emit(pipes[0], nodes[0].id, moved_nodes)
-
-        # emit node selection changed signal.
-        prev_ids = [n.id for n in self._prev_selection_nodes if not n.selected]
-        node_ids = [n.id for n in nodes if n not in self._prev_selection_nodes]
-        self.node_selection_changed.emit(node_ids, prev_ids)
-
-        super(NodeViewer, self).mouseReleaseEvent(event)
-
-    def mouseMoveEvent(self, event):
-        if self.ALT_state and self.SHIFT_state:
-            if self.pipe_slicing:
-                if self.LMB_state and self._SLICER_PIPE.isVisible():
-                    p1 = self._SLICER_PIPE.path().pointAtPercent(0)
-                    p2 = self.mapToScene(self._previous_pos)
-                    self._SLICER_PIPE.draw_path(p1, p2)
-                    self._SLICER_PIPE.show()
-            self._previous_pos = event.pos()
-            super(NodeViewer, self).mouseMoveEvent(event)
-            return
-
-        if self.MMB_state and self.ALT_state:
-            pos_x = (event.x() - self._previous_pos.x())
-            zoom = 0.1 if pos_x > 0 else -0.1
-            self._set_viewer_zoom(zoom, 0.05, pos=event.pos())
-        elif self.MMB_state or (self.LMB_state and self.ALT_state):
-            previous_pos = self.mapToScene(self._previous_pos)
-            current_pos = self.mapToScene(event.pos())
-            delta = previous_pos - current_pos
-            self._set_viewer_pan(delta.x(), delta.y())
-
-        if not self.ALT_state:
-            if self.SHIFT_state or self.CTRL_state:
-                if not self._LIVE_PIPE.isVisible():
-                    self._cursor_text.setPos(self.mapToScene(event.pos()))
-
-        if self.LMB_state and self._rubber_band.isActive:
-            rect = QtCore.QRect(self._origin_pos, event.pos()).normalized()
-            # if the rubber band is too small, do not show it.
-            if max(rect.width(), rect.height()) > 5:
-                if not self._rubber_band.isVisible():
-                    self._rubber_band.show()
-                map_rect = self.mapToScene(rect).boundingRect()
-                path = QtGui.QPainterPath()
-                path.addRect(map_rect)
-                self._rubber_band.setGeometry(rect)
-                self.scene().setSelectionArea(
-                    path, QtCore.Qt.IntersectsItemShape
-                )
-                self.scene().update(map_rect)
-
-                if self.SHIFT_state or self.CTRL_state:
-                    nodes, pipes = self.selected_items()
-
-                    for node in self._prev_selection_nodes:
-                        node.selected = True
-
-                    if self.CTRL_state:
-                        for pipe in pipes:
-                            pipe.setSelected(False)
-                        for node in nodes:
-                            node.selected = False
-
-        elif self.LMB_state:
-            self.COLLIDING_state = False
-            nodes, pipes = self.selected_items()
-            if len(nodes) == 1:
-                node = nodes[0]
-                [p.setSelected(False) for p in pipes]
-
-                if self.pipe_collision:
-                    colliding_pipes = [
-                        i for i in node.collidingItems()
-                        if isinstance(i, PipeItem) and i.isVisible()
-                    ]
-                    for pipe in colliding_pipes:
-                        if not pipe.input_port:
-                            continue
-                        port_node_check = all([
-                            not pipe.input_port.node is node,
-                            not pipe.output_port.node is node
-                        ])
-                        if port_node_check:
-                            pipe.setSelected(True)
-                            self.COLLIDING_state = True
-                            break
-
-        self._previous_pos = event.pos()
-        super(NodeViewer, self).mouseMoveEvent(event)
-
-    def wheelEvent(self, event):
-        try:
-            delta = event.delta()
-        except AttributeError:
-            # For PyQt5
-            delta = event.angleDelta().y()
-            if delta == 0:
-                delta = event.angleDelta().x()
-        self._set_viewer_zoom(delta, pos=event.pos())
-
-    def dropEvent(self, event):
-        pos = self.mapToScene(event.pos())
-        event.setDropAction(QtCore.Qt.CopyAction)
-        self.data_dropped.emit(
-            event.mimeData(), QtCore.QPoint(pos.x(), pos.y()))
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat('text/uri-list'):
-            event.accept()
-        else:
-            event.ignore()
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat('text/uri-list'):
-            event.accept()
-        else:
-            event.ignore()
-
-    def dragLeaveEvent(self, event):
-        event.ignore()
-
-    def keyPressEvent(self, event):
-        """
-        Key press event re-implemented to update the states for attributes:
-        - ALT_state
-        - CTRL_state
-        - SHIFT_state
-
-        Args:
-            event (QtGui.QKeyEvent): key event.
-        """
-        self.ALT_state = event.modifiers() == QtCore.Qt.AltModifier
-        self.CTRL_state = event.modifiers() == QtCore.Qt.ControlModifier
-        self.SHIFT_state = event.modifiers() == QtCore.Qt.ShiftModifier
-
-        # Todo: find a better solution to catch modifier keys.
-        if event.modifiers() == (QtCore.Qt.AltModifier | QtCore.Qt.ShiftModifier):
-            self.ALT_state = True
-            self.SHIFT_state = True
-
-        if self._LIVE_PIPE.isVisible():
-            super(NodeViewer, self).keyPressEvent(event)
-            return
-
-        # show cursor text
-        overlay_text = None
-        self._cursor_text.setVisible(False)
-        if not self.ALT_state:
-            if self.SHIFT_state:
-                overlay_text = '\n    SHIFT:\n    Toggle/Extend Selection'
-            elif self.CTRL_state:
-                overlay_text = '\n    CTRL:\n    Deselect Nodes'
-        elif self.ALT_state and self.SHIFT_state:
-            if self.pipe_slicing:
-                overlay_text = '\n    ALT + SHIFT:\n    Pipe Slicer Enabled'
-        if overlay_text:
-            self._cursor_text.setPlainText(overlay_text)
-            self._cursor_text.setPos(self.mapToScene(self._previous_pos))
-            self._cursor_text.setVisible(True)
-
-        super(NodeViewer, self).keyPressEvent(event)
-
-    def keyReleaseEvent(self, event):
-        """
-        Key release event re-implemented to update the states for attributes:
-        - ALT_state
-        - CTRL_state
-        - SHIFT_state
-
-        Args:
-            event (QtGui.QKeyEvent): key event.
-        """
-        self.ALT_state = event.modifiers() == QtCore.Qt.AltModifier
-        self.CTRL_state = event.modifiers() == QtCore.Qt.ControlModifier
-        self.SHIFT_state = event.modifiers() == QtCore.Qt.ShiftModifier
-        super(NodeViewer, self).keyReleaseEvent(event)
-
-        # hide and reset cursor text.
-        self._cursor_text.setPlainText('')
-        self._cursor_text.setVisible(False)
-
-    # --- scene events ---
-
-    def sceneMouseMoveEvent(self, event):
-        """
-        triggered mouse move event for the scene.
-         - redraw the live connection pipe.
-
-        Args:
-            event (QtWidgets.QGraphicsSceneMouseEvent):
-                The event handler from the QtWidgets.QGraphicsScene
-        """
-        if not self._LIVE_PIPE.isVisible():
-            return
-        if not self._start_port:
-            return
-
-        pos = event.scenePos()
-        pointer_color = None
-        for item in self.scene().items(pos):
-            if not isinstance(item, PortItem):
-                continue
-
-            x = item.boundingRect().width() / 2
-            y = item.boundingRect().height() / 2
-            pos = item.scenePos()
-            pos.setX(pos.x() + x)
-            pos.setY(pos.y() + y)
-            if item == self._start_port:
-                break
-            pointer_color = PipeEnum.HIGHLIGHT_COLOR.value
-            accept = self._validate_accept_connection(self._start_port, item)
-            if not accept:
-                pointer_color = [150, 60, 255]
-                break
-            reject = self._validate_reject_connection(self._start_port, item)
-            if reject:
-                pointer_color = [150, 60, 255]
-                break
-
-            if self.acyclic:
-                if item.node == self._start_port.node:
-                    pointer_color = PipeEnum.DISABLED_COLOR.value
-                elif item.port_type == self._start_port.port_type:
-                    pointer_color = PipeEnum.DISABLED_COLOR.value
-            break
-
-        self._LIVE_PIPE.draw_path(
-            self._start_port, cursor_pos=pos, color=pointer_color
-        )
-
-    def sceneMousePressEvent(self, event):
-        """
-        triggered mouse press event for the scene (takes priority over viewer event).
-         - detect selected pipe and start connection.
-         - remap Shift and Ctrl modifier.
-
-        Args:
-            event (QtWidgets.QGraphicsScenePressEvent):
-                The event handler from the QtWidgets.QGraphicsScene
-        """
-        # pipe slicer enabled.
-        if self.ALT_state and self.SHIFT_state:
-            return
-
-        # viewer pan mode.
-        if self.ALT_state:
-            return
-
-        if self._LIVE_PIPE.isVisible():
-            self.apply_live_connection(event)
-            return
-
-        pos = event.scenePos()
-        items = self._items_near(pos, None, 5, 5)
-
-        # filter from the selection stack in the following order
-        # "node, port, pipe" this is to avoid selecting items under items.
-        node, port, pipe = None, None, None
-        for item in items:
-            if isinstance(item, AbstractNodeItem):
-                node = item
-            elif isinstance(item, PortItem):
-                port = item
-            elif isinstance(item, PipeItem):
-                pipe = item
-            if any([node, port, pipe]):
-                break
-
-        if port:
-            if port.locked:
-                return
-
-            if not port.multi_connection and port.connected_ports:
-                self._detached_port = port.connected_ports[0]
-            self.start_live_connection(port)
-            if not port.multi_connection:
-                [p.delete() for p in port.connected_pipes]
-            return
-
-        if node:
-            node_items = self._items_near(pos, AbstractNodeItem, 3, 3)
-
-            # record the node positions at selection time.
-            for n in node_items:
-                self._node_positions[n] = n.xy_pos
-
-            # emit selected node id with LMB.
-            if event.button() == QtCore.Qt.LeftButton:
-                self.node_selected.emit(node.id)
-
-            if not isinstance(node, BackdropNodeItem):
-                return
-
-        if pipe:
-            if not self.LMB_state:
-                return
-
-            from_port = pipe.port_from_pos(pos, True)
-
-            if from_port.locked:
-                return
-
-            from_port.hovered = True
-
-            attr = {
-                PortTypeEnum.IN.value: 'output_port',
-                PortTypeEnum.OUT.value: 'input_port'
-            }
-            self._detached_port = getattr(pipe, attr[from_port.port_type])
-            self.start_live_connection(from_port)
-            self._LIVE_PIPE.draw_path(self._start_port, cursor_pos=pos)
-
-            if self.SHIFT_state:
-                self._LIVE_PIPE.shift_selected = True
-                return
-
-            pipe.delete()
-
-    def sceneMouseReleaseEvent(self, event):
-        """
-        triggered mouse release event for the scene.
-
-        Args:
-            event (QtWidgets.QGraphicsSceneMouseEvent):
-                The event handler from the QtWidgets.QGraphicsScene
-        """
-        if event.button() != QtCore.Qt.MiddleButton:
-            self.apply_live_connection(event)
-
-    # --- port connections ---
-
-    def _validate_accept_connection(self, from_port, to_port):
-        """
-        Check if a pipe connection is allowed if there are a constraints set
-        on the ports.
-
-        Args:
-            from_port (PortItem):
-            to_port (PortItem):
-
-        Returns:
-            bool: true to allow connection.
-        """
-        accept_validation = []
-
-        to_ptype = to_port.port_type
-        from_ptype = from_port.port_type
-
-        # validate the start.
-        from_data = self.accept_connection_types.get(from_port.node.type_) or {}
-        constraints = from_data.get(from_ptype, {}).get(from_port.name, {})
-        accept_data = constraints.get(to_port.node.type_, {})
-        accepted_pnames = accept_data.get(to_ptype, {})
-        if constraints:
-            if to_port.name in accepted_pnames:
-                accept_validation.append(True)
-            else:
-                accept_validation.append(False)
-
-        # validate the end.
-        to_data = self.accept_connection_types.get(to_port.node.type_) or {}
-        constraints = to_data.get(to_ptype, {}).get(to_port.name, {})
-        accept_data = constraints.get(from_port.node.type_, {})
-        accepted_pnames = accept_data.get(from_ptype, {})
-        if constraints:
-            if from_port.name in accepted_pnames:
-                accept_validation.append(True)
-            else:
-                accept_validation.append(False)
-
-        if False in accept_validation:
-            return False
-        return True
-
-    def _validate_reject_connection(self, from_port, to_port):
-        """
-        Check if a pipe connection is NOT allowed if there are a constrains set
-        on the ports.
-
-        Args:
-            from_port (PortItem):
-            to_port (PortItem):
-
-        Returns:
-            bool: true to reject connection.
-        """
-        to_ptype = to_port.port_type
-        from_ptype = from_port.port_type
-
-        to_data = self.reject_connection_types.get(to_port.node.type_) or {}
-        constraints = to_data.get(to_ptype, {}).get(to_port.name, {})
-        reject_data = constraints.get(from_port.node.type_, {})
-
-        rejected_pnames = reject_data.get(from_ptype)
-        if rejected_pnames:
-            if from_port.name in rejected_pnames:
-                return True
-            return False
-
-        from_data = self.reject_connection_types.get(from_port.node.type_) or {}
-        constraints = from_data.get(from_ptype, {}).get(from_port.name, {})
-        reject_data = constraints.get(to_port.node.type_, {})
-
-        rejected_pnames = reject_data.get(to_ptype)
-        if rejected_pnames:
-            if to_port.name in rejected_pnames:
-                return True
-            return False
-        return False
-
-    def apply_live_connection(self, event):
-        """
-        triggered mouse press/release event for the scene.
-        - verifies the live connection pipe.
-        - makes a connection pipe if valid.
-        - emits the "connection changed" signal.
-
-        Args:
-            event (QtWidgets.QGraphicsSceneMouseEvent):
-                The event handler from the QtWidgets.QGraphicsScene
-        """
-        if not self._LIVE_PIPE.isVisible():
-            return
-
-        self._start_port.hovered = False
-
-        # find the end port.
-        end_port = None
-        for item in self.scene().items(event.scenePos()):
-            if isinstance(item, PortItem):
-                end_port = item
-                break
-
-        connected = []
-        disconnected = []
-
-        # if port disconnected from existing pipe.
-        if end_port is None:
-            if self._detached_port and not self._LIVE_PIPE.shift_selected:
-                dist = math.hypot(self._previous_pos.x() - self._origin_pos.x(),
-                                  self._previous_pos.y() - self._origin_pos.y())
-                if dist <= 2.0:  # cursor pos threshold.
-                    self.establish_connection(self._start_port,
-                                              self._detached_port)
-                    self._detached_port = None
-                else:
-                    disconnected.append((self._start_port, self._detached_port))
-                    self.connection_changed.emit(disconnected, connected)
-
-            self._detached_port = None
-            self.end_live_connection()
-            return
-
-        else:
-            if self._start_port is end_port:
-                return
-
-        # if connection to itself
-        same_node_connection = end_port.node == self._start_port.node
-        if not self.acyclic:
-            # allow a node cycle connection.
-            same_node_connection = False
-
-        # constrain check
-        accept_connection = self._validate_accept_connection(
-            self._start_port, end_port
-        )
-        reject_connection = self._validate_reject_connection(
-            self._start_port, end_port
-        )
-
-        # restore connection check.
-        restore_connection = any([
-            # if the end port is locked.
-            end_port.locked,
-            # if same port type.
-            end_port.port_type == self._start_port.port_type,
-            # if connection to itself.
-            same_node_connection,
-            # if end port is the start port.
-            end_port == self._start_port,
-            # if detached port is the end port.
-            self._detached_port == end_port,
-            # if a port has a accept port type constrain.
-            not accept_connection,
-            # if a port has a reject port type constrain.
-            reject_connection
-        ])
-        if restore_connection:
-            if self._detached_port:
-                to_port = self._detached_port or end_port
-                self.establish_connection(self._start_port, to_port)
-                self._detached_port = None
-            self.end_live_connection()
-            return
-
-        # end connection if starting port is already connected.
-        if self._start_port.multi_connection and \
-                self._start_port in end_port.connected_ports:
-            self._detached_port = None
-            self.end_live_connection()
-            return
-
-        # register as disconnected if not acyclic.
-        if self.acyclic and not self.acyclic_check(self._start_port, end_port):
-            if self._detached_port:
-                disconnected.append((self._start_port, self._detached_port))
-
-            self.connection_changed.emit(disconnected, connected)
-
-            self._detached_port = None
-            self.end_live_connection()
-            return
-
-        # make connection.
-        if not end_port.multi_connection and end_port.connected_ports:
-            dettached_end = end_port.connected_ports[0]
-            disconnected.append((end_port, dettached_end))
-
-        if self._detached_port:
-            disconnected.append((self._start_port, self._detached_port))
-
-        connected.append((self._start_port, end_port))
-
-        self.connection_changed.emit(disconnected, connected)
-
-        self._detached_port = None
-        self.end_live_connection()
-
-    def start_live_connection(self, selected_port):
-        """
-        create new pipe for the connection.
-        (show the live pipe visibility from the port following the cursor position)
-        """
-        if not selected_port:
-            return
-        self._start_port = selected_port
-        if self._start_port.type == PortTypeEnum.IN.value:
-            self._LIVE_PIPE.input_port = self._start_port
-        elif self._start_port == PortTypeEnum.OUT.value:
-            self._LIVE_PIPE.output_port = self._start_port
-        self._LIVE_PIPE.setVisible(True)
-        self._LIVE_PIPE.draw_index_pointer(
-            selected_port,
-            self.mapToScene(self._origin_pos)
-        )
-
-    def end_live_connection(self):
-        """
-        delete live connection pipe and reset start port.
-        (hides the pipe item used for drawing the live connection)
-        """
-        self._LIVE_PIPE.reset_path()
-        self._LIVE_PIPE.setVisible(False)
-        self._LIVE_PIPE.shift_selected = False
-        self._start_port = None
-
-    def establish_connection(self, start_port, end_port):
-        """
-        establish a new pipe connection.
-        (adds a new pipe item to draw between 2 ports)
-        """
-        pipe = PipeItem()
-        self.scene().addItem(pipe)
-        pipe.set_connections(start_port, end_port)
-        pipe.draw_path(pipe.input_port, pipe.output_port)
-        if start_port.node.selected or end_port.node.selected:
-            pipe.highlight()
-        if not start_port.node.visible or not end_port.node.visible:
-            pipe.hide()
-
-    @staticmethod
-    def acyclic_check(start_port, end_port):
-        """
-        Validate the node connections so it doesn't loop itself.
-
-        Args:
-            start_port (PortItem): port item.
-            end_port (PortItem): port item.
-
-        Returns:
-            bool: True if port connection is valid.
-        """
-        start_node = start_port.node
-        check_nodes = [end_port.node]
-        io_types = {
-            PortTypeEnum.IN.value: 'outputs',
-            PortTypeEnum.OUT.value: 'inputs'
-        }
-        while check_nodes:
-            check_node = check_nodes.pop(0)
-            for check_port in getattr(check_node, io_types[end_port.port_type]):
-                if check_port.connected_ports:
-                    for port in check_port.connected_ports:
-                        if port.node != start_node:
-                            check_nodes.append(port.node)
-                        else:
-                            return False
-        return True
-
-    # --- viewer ---
-
-    def tab_search_set_nodes(self, nodes):
-        self._search_widget.set_nodes(nodes)
-
-    def tab_search_toggle(self):
-        state = self._search_widget.isVisible()
-        if not state:
-            self._search_widget.setVisible(state)
-            self.setFocus()
-            return
-
-        pos = self._previous_pos
-        rect = self._search_widget.rect()
-        new_pos = QtCore.QPoint(int(pos.x() - rect.width() / 2),
-                                int(pos.y() - rect.height() / 2))
-        self._search_widget.move(new_pos)
-        self._search_widget.setVisible(state)
-        self._search_widget.setFocus()
-
-        rect = self.mapToScene(rect).boundingRect()
-        self.scene().update(rect)
-
-    def rebuild_tab_search(self):
-        if isinstance(self._search_widget, TabSearchMenuWidget):
-            self._search_widget.rebuild = True
-
-    def qaction_for_undo(self):
-        """
-        Get the undo QAction from the parent undo stack.
-
-        Returns:
-            QtWidgets.QAction: undo action.
-        """
-        return self._undo_action
-
-    def qaction_for_redo(self):
-        """
-        Get the redo QAction from the parent undo stack.
-
-        Returns:
-            QtWidgets.QAction: redo action.
-        """
-        return self._redo_action
-
-    def context_menus(self):
-        """
-        All the available context menus for the viewer.
-
-        Returns:
-            dict: viewer context menu.
-        """
-        return {'graph': self._ctx_graph_menu, 'nodes': self._ctx_node_menu}
-
-    def question_dialog(self, text, title='Node Graph'):
-        """
-        Prompt node viewer question dialog widget with "yes", "no" buttons.
-
-        Args:
-            text (str): dialog text.
-            title (str): dialog window title.
-
-        Returns:
-            bool: true if user click yes.
-        """
-        self.clear_key_state()
-        return BaseDialog.question_dialog(text, title)
-
-    def message_dialog(self, text, title='Node Graph'):
-        """
-        Prompt node viewer message dialog widget with "ok" button.
-
-        Args:
-            text (str): dialog text.
-            title (str): dialog window title.
-        """
-        self.clear_key_state()
-        BaseDialog.message_dialog(text, title)
-
-    def load_dialog(self, current_dir=None, ext=None):
-        """
-        Prompt node viewer file load dialog widget.
-
-        Args:
-            current_dir (str): directory path starting point. (optional)
-            ext (str): custom file extension filter type. (optional)
-
-        Returns:
-            str: selected file path.
-        """
-        self.clear_key_state()
-        ext = '*{} '.format(ext) if ext else ''
-        ext_filter = ';;'.join([
-            'Node Graph ({}*json)'.format(ext), 'All Files (*)'
-        ])
-        file_dlg = FileDialog.getOpenFileName(
-            self, 'Open File', current_dir, ext_filter)
-        file = file_dlg[0] or None
-        return file
-
-    def save_dialog(self, current_dir=None, ext=None):
-        """
-        Prompt node viewer file save dialog widget.
-
-        Args:
-            current_dir (str): directory path starting point. (optional)
-            ext (str): custom file extension filter type. (optional)
-
-        Returns:
-            str: selected file path.
-        """
-        self.clear_key_state()
-        ext_label = '*{} '.format(ext) if ext else ''
-        ext_type = '.{}'.format(ext) if ext else '.json'
-        ext_map = {'Node Graph ({}*json)'.format(ext_label): ext_type,
-                   'All Files (*)': ''}
-        file_dlg = FileDialog.getSaveFileName(
-            self, 'Save Session', current_dir, ';;'.join(ext_map.keys()))
-        file_path = file_dlg[0]
-        if not file_path:
-            return
-        ext = ext_map[file_dlg[1]]
-        if ext and not file_path.endswith(ext):
-            file_path += ext
-
-        return file_path
-
-    def all_pipes(self):
-        """
-        Returns all pipe qgraphic items.
-
-        Returns:
-            list[PipeItem]: instances of pipe items.
-        """
-        excl = [self._LIVE_PIPE, self._SLICER_PIPE]
-        return [i for i in self.scene().items()
-                if isinstance(i, PipeItem) and i not in excl]
-
-    def all_nodes(self):
-        """
-        Returns all node qgraphic items.
-
-        Returns:
-            list[AbstractNodeItem]: instances of node items.
-        """
-        return [i for i in self.scene().items()
-                if isinstance(i, AbstractNodeItem)]
-
-    def selected_nodes(self):
-        """
-        Returns selected node qgraphic items.
-
-        Returns:
-            list[AbstractNodeItem]: instances of node items.
-        """
-        return [i for i in self.scene().selectedItems()
-                if isinstance(i, AbstractNodeItem)]
-
-    def selected_pipes(self):
-        """
-        Returns selected pipe qgraphic items.
-
-        Returns:
-            list[Pipe]: pipe items.
-        """
-        pipes = [i for i in self.scene().selectedItems()
-                 if isinstance(i, PipeItem)]
-        return pipes
-
-    def selected_items(self):
-        """
-        Return selected graphic items in the scene.
-
-        Returns:
-            tuple(list[AbstractNodeItem], list[Pipe]):
-                selected (node items, pipe items).
-        """
-        nodes = []
-        pipes = []
-        for item in self.scene().selectedItems():
-            if isinstance(item, AbstractNodeItem):
-                nodes.append(item)
-            elif isinstance(item, PipeItem):
-                pipes.append(item)
-        return nodes, pipes
-
-    def add_node(self, node, pos=None):
-        """
-        Add node item into the scene.
-
-        Args:
-            node (AbstractNodeItem): node item instance.
-            pos (tuple or list): node scene position.
-        """
-        pos = pos or (self._previous_pos.x(), self._previous_pos.y())
-        node.pre_init(self, pos)
-        self.scene().addItem(node)
-        node.post_init(self, pos)
-
-    @staticmethod
-    def remove_node(node):
-        """
-        Remove node item from the scene.
-
-        Args:
-            node (AbstractNodeItem): node item instance.
-        """
-        if isinstance(node, AbstractNodeItem):
-            node.delete()
-
-    def move_nodes(self, nodes, pos=None, offset=None):
-        """
-        Globally move specified nodes.
-
-        Args:
-            nodes (list[AbstractNodeItem]): node items.
-            pos (tuple or list): custom x, y position.
-            offset (tuple or list): x, y position offset.
-        """
-        group = self.scene().createItemGroup(nodes)
-        group_rect = group.boundingRect()
-        if pos:
-            x, y = pos
-        else:
-            pos = self.mapToScene(self._previous_pos)
-            x = pos.x() - group_rect.center().x()
-            y = pos.y() - group_rect.center().y()
-        if offset:
-            x += offset[0]
-            y += offset[1]
-        group.setPos(x, y)
-        self.scene().destroyItemGroup(group)
-
-    def get_pipes_from_nodes(self, nodes=None):
-        nodes = nodes or self.selected_nodes()
-        if not nodes:
-            return
-        pipes = []
-        for node in nodes:
-            n_inputs = node.inputs if hasattr(node, 'inputs') else []
-            n_outputs = node.outputs if hasattr(node, 'outputs') else []
-
-            for port in n_inputs:
-                for pipe in port.connected_pipes:
-                    connected_node = pipe.output_port.node
-                    if connected_node in nodes:
-                        pipes.append(pipe)
-            for port in n_outputs:
-                for pipe in port.connected_pipes:
-                    connected_node = pipe.input_port.node
-                    if connected_node in nodes:
-                        pipes.append(pipe)
-        return pipes
-
-    def center_selection(self, nodes=None):
-        """
-        Center on the given nodes or all nodes by default.
-
-        Args:
-            nodes (list[AbstractNodeItem]): a list of node items.
-        """
-        if not nodes:
-            if self.selected_nodes():
-                nodes = self.selected_nodes()
-            elif self.all_nodes():
-                nodes = self.all_nodes()
-            if not nodes:
-                return
-
-        rect = self._combined_rect(nodes)
-        self._scene_range.translate(rect.center() - self._scene_range.center())
-        self.setSceneRect(self._scene_range)
-
-    def get_pipe_layout(self):
-        """
-        Returns the pipe layout mode.
-
-        Returns:
-            int: pipe layout mode.
-        """
-        return self._pipe_layout
-
-    def set_pipe_layout(self, layout):
-        """
-        Sets the pipe layout mode and redraw all pipe items in the scene.
-
-        Args:
-            layout (int): pipe layout mode. (see the constants module)
-        """
-        self._pipe_layout = layout
-        for pipe in self.all_pipes():
-            pipe.draw_path(pipe.input_port, pipe.output_port)
-
-    def get_layout_direction(self):
-        """
-        Returns the layout direction set on the the node graph viewer
-        used by the pipe items for drawing.
-
-        Returns:
-            int: graph layout mode.
-        """
-        return self._layout_direction
-
-    def set_layout_direction(self, direction):
-        """
-        Sets the node graph viewer layout direction for re-drawing
-        the pipe items.
-
-        Args:
-            direction (int): graph layout direction.
-        """
-        self._layout_direction = direction
-        for pipe_item in self.all_pipes():
-            pipe_item.draw_path(pipe_item.input_port, pipe_item.output_port)
-
-    def reset_zoom(self, cent=None):
-        """
-        Reset the viewer zoom level.
-
-        Args:
-            cent (QtCore.QPoint): specified center.
-        """
-        self._scene_range = QtCore.QRectF(0, 0,
-                                          self.size().width(),
-                                          self.size().height())
-        if cent:
-            self._scene_range.translate(cent - self._scene_range.center())
-        self._update_scene()
-
-    def get_zoom(self):
-        """
-        Returns the viewer zoom level.
-
-        Returns:
-            float: zoom level.
-        """
-        transform = self.transform()
-        cur_scale = (transform.m11(), transform.m22())
-        return float('{:0.2f}'.format(cur_scale[0] - 1.0))
-
-    def set_zoom(self, value=0.0):
-        """
-        Set the viewer zoom level.
-
-        Args:
-            value (float): zoom level
-        """
-        if value == 0.0:
-            self.reset_zoom()
-            return
-        zoom = self.get_zoom()
-        if zoom < 0.0:
-            if not (ZOOM_MIN <= zoom <= ZOOM_MAX):
-                return
-        else:
-            if not (ZOOM_MIN <= value <= ZOOM_MAX):
-                return
-        value = value - zoom
-        self._set_viewer_zoom(value, 0.0)
-
-    def zoom_to_nodes(self, nodes):
-        self._scene_range = self._combined_rect(nodes)
-        self._update_scene()
-
-        if self.get_zoom() > 0.1:
-            self.reset_zoom(self._scene_range.center())
-
-    def force_update(self):
-        """
-        Redraw the current node graph scene.
-        """
-        self._update_scene()
-
-    def scene_rect(self):
-        """
-        Returns the scene rect size.
-
-        Returns:
-            list[float]: x, y, width, height
-        """
-        return [self._scene_range.x(), self._scene_range.y(),
-                self._scene_range.width(), self._scene_range.height()]
-
-    def set_scene_rect(self, rect):
-        """
-        Sets the scene rect and redraws the scene.
-
-        Args:
-            rect (list[float]): x, y, width, height
-        """
-        self._scene_range = QtCore.QRectF(*rect)
-        self._update_scene()
-
-    def scene_center(self):
-        """
-        Get the center x,y pos from the scene.
-
-        Returns:
-            list[float]: x, y position.
-        """
-        cent = self._scene_range.center()
-        return [cent.x(), cent.y()]
-
-    def nodes_rect_center(self, nodes):
-        """
-        Get the center x,y pos from the specified nodes.
-
-        Args:
-            nodes (list[AbstractNodeItem]): list of node qgrphics items.
-
-        Returns:
-            list[float]: x, y position.
-        """
-        cent = self._combined_rect(nodes).center()
-        return [cent.x(), cent.y()]
-
-    def clear_key_state(self):
-        """
-        Resets the Ctrl, Shift, Alt modifiers key states.
-        """
-        self.CTRL_state = False
-        self.SHIFT_state = False
-        self.ALT_state = False
-
-    def use_OpenGL(self):
-        """
-        Use QOpenGLWidget as the viewer.
-        """
-        # use QOpenGLWidget instead of the deprecated QGLWidget to avoid
-        # problems with Wayland.
-        import Qt
-        if Qt.IsPySide2:
-            from PySide2.QtWidgets import QOpenGLWidget
-        elif Qt.IsPyQt5:
-            from PyQt5.QtWidgets import QOpenGLWidget
-        self.setViewport(QOpenGLWidget())
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+import math
+from distutils.version import LooseVersion
+
+from Qt import QtGui, QtCore, QtWidgets
+
+from NodeGraphQt.base.menu import BaseMenu
+from NodeGraphQt.constants import (
+    LayoutDirectionEnum,
+    PortTypeEnum,
+    PipeEnum,
+    PipeLayoutEnum,
+    ViewerEnum,
+    Z_VAL_PIPE,
+)
+from NodeGraphQt.qgraphics.node_abstract import AbstractNodeItem
+from NodeGraphQt.qgraphics.node_backdrop import BackdropNodeItem
+from NodeGraphQt.qgraphics.pipe import PipeItem, LivePipeItem
+from NodeGraphQt.qgraphics.port import PortItem
+from NodeGraphQt.qgraphics.slicer import SlicerPipeItem
+from NodeGraphQt.widgets.dialogs import BaseDialog, FileDialog
+from NodeGraphQt.widgets.scene import NodeScene
+from NodeGraphQt.widgets.tab_search import TabSearchMenuWidget
+
+ZOOM_MIN = -0.95
+ZOOM_MAX = 2.0
+
+
+class NodeViewer(QtWidgets.QGraphicsView):
+    """
+    The widget interface used for displaying the scene and nodes.
+
+    functions in this class should mainly be called by the
+    class:`NodeGraphQt.NodeGraph` class.
+    """
+
+    # node viewer signals.
+    # (some of these signals are called by port & node items and connected
+    # to the node graph slot functions)
+    moved_nodes = QtCore.Signal(dict)
+    search_triggered = QtCore.Signal(str, tuple)
+    connection_sliced = QtCore.Signal(list)
+    connection_changed = QtCore.Signal(list, list)
+    insert_node = QtCore.Signal(object, str, dict)
+    node_name_changed = QtCore.Signal(str, str)
+    node_backdrop_updated = QtCore.Signal(str, str, object)
+
+    # pass through signals that are translated into "NodeGraph()" signals.
+    node_selected = QtCore.Signal(str)
+    node_selection_changed = QtCore.Signal(list, list)
+    node_double_clicked = QtCore.Signal(str)
+    data_dropped = QtCore.Signal(QtCore.QMimeData, QtCore.QPoint)
+
+    def __init__(self, parent=None, undo_stack=None):
+        """
+        Args:
+            parent:
+            undo_stack (QtWidgets.QUndoStack): undo stack from the parent
+                                               graph controller.
+        """
+        super(NodeViewer, self).__init__(parent)
+
+        self.setScene(NodeScene(self))
+        self.setRenderHint(QtGui.QPainter.Antialiasing, True)
+        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
+        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
+        self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)
+        self.setCacheMode(QtWidgets.QGraphicsView.CacheBackground)
+        self.setOptimizationFlag(
+            QtWidgets.QGraphicsView.DontAdjustForAntialiasing)
+
+        self.setAcceptDrops(True)
+        self.resize(850, 800)
+
+        self._scene_range = QtCore.QRectF(
+            0, 0, self.size().width(), self.size().height())
+        self._update_scene()
+        self._last_size = self.size()
+
+        self._layout_direction = LayoutDirectionEnum.HORIZONTAL.value
+
+        self._pipe_layout = PipeLayoutEnum.CURVED.value
+        self._detached_port = None
+        self._start_port = None
+        self._origin_pos = None
+        self._previous_pos = QtCore.QPoint(int(self.width() / 2),
+                                           int(self.height() / 2))
+        self._prev_selection_nodes = []
+        self._prev_selection_pipes = []
+        self._node_positions = {}
+
+        self._rubber_band = QtWidgets.QRubberBand(
+            QtWidgets.QRubberBand.Rectangle, self
+        )
+        self._rubber_band.isActive = False
+
+        text_color = QtGui.QColor(*tuple(map(
+            lambda i, j: i - j, (255, 255, 255),
+            ViewerEnum.BACKGROUND_COLOR.value
+        )))
+        text_color.setAlpha(50)
+        self._cursor_text = QtWidgets.QGraphicsTextItem()
+        self._cursor_text.setFlag(self._cursor_text.ItemIsSelectable, False)
+        self._cursor_text.setDefaultTextColor(text_color)
+        self._cursor_text.setZValue(Z_VAL_PIPE - 1)
+        font = self._cursor_text.font()
+        font.setPointSize(7)
+        self._cursor_text.setFont(font)
+        self.scene().addItem(self._cursor_text)
+
+        self._LIVE_PIPE = LivePipeItem()
+        self._LIVE_PIPE.setVisible(False)
+        self.scene().addItem(self._LIVE_PIPE)
+
+        self._SLICER_PIPE = SlicerPipeItem()
+        self._SLICER_PIPE.setVisible(False)
+        self.scene().addItem(self._SLICER_PIPE)
+
+        self._search_widget = TabSearchMenuWidget()
+        self._search_widget.search_submitted.connect(self._on_search_submitted)
+
+        # workaround fix for shortcuts from the non-native menu.
+        # actions don't seem to trigger so we create a hidden menu bar.
+        self._ctx_menu_bar = QtWidgets.QMenuBar(self)
+        self._ctx_menu_bar.setNativeMenuBar(False)
+        # shortcuts don't work with "setVisibility(False)".
+        self._ctx_menu_bar.setMaximumSize(0, 0)
+
+        # context menus.
+        self._ctx_graph_menu = BaseMenu('NodeGraph', self)
+        self._ctx_node_menu = BaseMenu('Nodes', self)
+
+        if undo_stack:
+            self._undo_action = undo_stack.createUndoAction(self, '&Undo')
+            self._redo_action = undo_stack.createRedoAction(self, '&Redo')
+        else:
+            self._undo_action = None
+            self._redo_action = None
+
+        self._build_context_menus()
+
+        self.acyclic = True
+        self.pipe_collision = False
+        self.pipe_slicing = True
+
+        self.LMB_state = False
+        self.RMB_state = False
+        self.MMB_state = False
+        self.ALT_state = False
+        self.CTRL_state = False
+        self.SHIFT_state = False
+        self.COLLIDING_state = False
+
+        # connection constrains.
+        # TODO: maybe this should be a reference to the graph model instead?
+        self.accept_connection_types = None
+        self.reject_connection_types = None
+
+    def __repr__(self):
+        return '<{}() object at {}>'.format(
+            self.__class__.__name__, hex(id(self)))
+
+    def focusInEvent(self, event):
+        """
+        Args:
+            event (QtGui.QFocusEvent): focus event.
+        """
+        # workaround fix: Re-populate the QMenuBar so the QAction shotcuts don't
+        #                 conflict with parent existing host app.
+        self._ctx_menu_bar.addMenu(self._ctx_graph_menu)
+        self._ctx_menu_bar.addMenu(self._ctx_node_menu)
+        return super(NodeViewer, self).focusInEvent(event)
+
+    def focusOutEvent(self, event):
+        """
+        Args:
+            event (QtGui.QFocusEvent): focus event.
+        """
+        # workaround fix: Clear the QMenuBar so the QAction shotcuts don't
+        #                 conflict with existing parent host app.
+        self._ctx_menu_bar.clear()
+        return super(NodeViewer, self).focusOutEvent(event)
+
+    # --- private ---
+
+    def _build_context_menus(self):
+        """
+        Build context menu for the node graph.
+        """
+        # "node context menu" disabled by default and enabled when a action
+        # is added through the "NodesMenu" interface.
+        self._ctx_node_menu.setDisabled(True)
+
+        # add the base menus.
+        self._ctx_menu_bar.addMenu(self._ctx_graph_menu)
+        self._ctx_menu_bar.addMenu(self._ctx_node_menu)
+
+        # setup the undo and redo actions.
+        if self._undo_action and self._redo_action:
+            self._undo_action.setShortcuts(QtGui.QKeySequence.Undo)
+            self._redo_action.setShortcuts(QtGui.QKeySequence.Redo)
+            if LooseVersion(QtCore.qVersion()) >= LooseVersion('5.10'):
+                self._undo_action.setShortcutVisibleInContextMenu(True)
+                self._redo_action.setShortcutVisibleInContextMenu(True)
+
+            # undo & redo always at the top of the "node graph context menu".
+            self._ctx_graph_menu.addAction(self._undo_action)
+            self._ctx_graph_menu.addAction(self._redo_action)
+            self._ctx_graph_menu.addSeparator()
+
+    def _set_viewer_zoom(self, value, sensitivity=None, pos=None):
+        """
+        Sets the zoom level.
+
+        Args:
+            value (float): zoom factor.
+            sensitivity (float): zoom sensitivity.
+            pos (QtCore.QPoint): mapped position.
+        """
+        if pos:
+            pos = self.mapToScene(pos)
+        if sensitivity is None:
+            scale = 1.001 ** value
+            self.scale(scale, scale, pos)
+            return
+
+        if value == 0.0:
+            return
+
+        scale = (0.9 + sensitivity) if value < 0.0 else (1.1 - sensitivity)
+        zoom = self.get_zoom()
+        if ZOOM_MIN >= zoom:
+            if scale == 0.9:
+                return
+        if ZOOM_MAX <= zoom:
+            if scale == 1.1:
+                return
+        self.scale(scale, scale, pos)
+
+    def _set_viewer_pan(self, pos_x, pos_y):
+        """
+        Set the viewer in panning mode.
+
+        Args:
+            pos_x (float): x pos.
+            pos_y (float): y pos.
+        """
+        self._scene_range.adjust(pos_x, pos_y, pos_x, pos_y)
+        self._update_scene()
+
+    def scale(self, sx, sy, pos=None):
+        scale = [sx, sx]
+        center = pos or self._scene_range.center()
+        w = self._scene_range.width() / scale[0]
+        h = self._scene_range.height() / scale[1]
+        self._scene_range = QtCore.QRectF(
+            center.x() - (center.x() - self._scene_range.left()) / scale[0],
+            center.y() - (center.y() - self._scene_range.top()) / scale[1],
+            w, h
+        )
+        self._update_scene()
+
+    def _update_scene(self):
+        """
+        Redraw the scene.
+        """
+        self.setSceneRect(self._scene_range)
+        self.fitInView(self._scene_range, QtCore.Qt.KeepAspectRatio)
+
+    def _combined_rect(self, nodes):
+        """
+        Returns a QRectF with the combined size of the provided node items.
+
+        Args:
+            nodes (list[AbstractNodeItem]): list of node qgraphics items.
+
+        Returns:
+            QtCore.QRectF: combined rect
+        """
+        group = self.scene().createItemGroup(nodes)
+        rect = group.boundingRect()
+        self.scene().destroyItemGroup(group)
+        return rect
+
+    def _items_near(self, pos, item_type=None, width=20, height=20):
+        """
+        Filter node graph items from the specified position, width and
+        height area.
+
+        Args:
+            pos (QtCore.QPoint): scene pos.
+            item_type: filter item type. (optional)
+            width (int): width area.
+            height (int): height area.
+
+        Returns:
+            list: qgraphics items from the scene.
+        """
+        x, y = pos.x() - width, pos.y() - height
+        rect = QtCore.QRectF(x, y, width, height)
+        items = []
+        excl = [self._LIVE_PIPE, self._SLICER_PIPE]
+        for item in self.scene().items(rect):
+            if item in excl:
+                continue
+            if not item_type or isinstance(item, item_type):
+                items.append(item)
+        return items
+
+    def _on_search_submitted(self, node_type):
+        """
+        Slot function triggered when the ``TabSearchMenuWidget`` has
+        submitted a search.
+
+        This will emit the "search_triggered" signal and tell the parent node
+        graph to create a new node object.
+
+        Args:
+            node_type (str): node type identifier.
+        """
+        pos = self.mapToScene(self._previous_pos)
+        self.search_triggered.emit(node_type, (pos.x(), pos.y()))
+
+    def _on_pipes_sliced(self, path):
+        """
+        Triggered when the slicer pipe is active
+
+        Args:
+            path (QtGui.QPainterPath): slicer path.
+        """
+        ports = []
+        for i in self.scene().items(path):
+            if isinstance(i, PipeItem) and i != self._LIVE_PIPE:
+                if any([i.input_port.locked, i.output_port.locked]):
+                    continue
+                ports.append([i.input_port, i.output_port])
+        self.connection_sliced.emit(ports)
+
+    # --- reimplemented events ---
+
+    def resizeEvent(self, event):
+        w, h = self.size().width(), self.size().height()
+        if 0 in [w, h]:
+            self.resize(self._last_size)
+        delta = max(w / self._last_size.width(), h / self._last_size.height())
+        self._set_viewer_zoom(delta)
+        self._last_size = self.size()
+        super(NodeViewer, self).resizeEvent(event)
+
+    def contextMenuEvent(self, event):
+        self.RMB_state = False
+
+        ctx_menu = None
+        ctx_menus = self.context_menus()
+
+        if ctx_menus['nodes'].isEnabled():
+            pos = self.mapToScene(self._previous_pos)
+            items = self._items_near(pos)
+            nodes = [i for i in items if isinstance(i, AbstractNodeItem)]
+            if nodes:
+                node = nodes[0]
+                ctx_menu = ctx_menus['nodes'].get_menu(node.type_, node.id)
+                if ctx_menu:
+                    for action in ctx_menu.actions():
+                        if not action.menu():
+                            action.node_id = node.id
+
+        ctx_menu = ctx_menu or ctx_menus['graph']
+        if len(ctx_menu.actions()) > 0:
+            if ctx_menu.isEnabled():
+                ctx_menu.exec_(event.globalPos())
+            else:
+                return super(NodeViewer, self).contextMenuEvent(event)
+
+        return super(NodeViewer, self).contextMenuEvent(event)
+
+    def mousePressEvent(self, event):
+        if event.button() == QtCore.Qt.LeftButton:
+            self.LMB_state = True
+        elif event.button() == QtCore.Qt.RightButton:
+            self.RMB_state = True
+        elif event.button() == QtCore.Qt.MiddleButton:
+            self.MMB_state = True
+
+        self._origin_pos = event.pos()
+        self._previous_pos = event.pos()
+        (self._prev_selection_nodes,
+         self._prev_selection_pipes) = self.selected_items()
+
+        # close tab search
+        if self._search_widget.isVisible():
+            self.tab_search_toggle()
+
+        # cursor pos.
+        map_pos = self.mapToScene(event.pos())
+
+        # pipe slicer enabled.
+        if self.pipe_slicing:
+            slicer_mode = all([
+                self.ALT_state, self.SHIFT_state, self.LMB_state
+            ])
+            if slicer_mode:
+                self._SLICER_PIPE.draw_path(map_pos, map_pos)
+                self._SLICER_PIPE.setVisible(True)
+                return
+
+        # pan mode.
+        if self.ALT_state:
+            return
+
+        items = self._items_near(map_pos, None, 20, 20)
+        pipes = []
+        nodes = []
+        backdrop = None
+        for itm in items:
+            if isinstance(itm, PipeItem):
+                pipes.append(itm)
+            elif isinstance(itm, AbstractNodeItem):
+                if isinstance(itm, BackdropNodeItem):
+                    backdrop = itm
+                    continue
+                nodes.append(itm)
+
+        if nodes:
+            self.MMB_state = False
+
+        # record the node selection as "self.selected_nodes()" is not updated
+        # here on the mouse press event.
+        selection = set([])
+
+        if self.LMB_state:
+            # toggle extend node selection.
+            if self.SHIFT_state:
+                if items and backdrop == items[0]:
+                    backdrop.selected = not backdrop.selected
+                    if backdrop.selected:
+                        selection.add(backdrop)
+                    for n in backdrop.get_nodes():
+                        n.selected = backdrop.selected
+                        if backdrop.selected:
+                            selection.add(n)
+                else:
+                    for node in nodes:
+                        node.selected = not node.selected
+                        if node.selected:
+                            selection.add(node)
+            # unselected nodes with the "ctrl" key.
+            elif self.CTRL_state:
+                if items and backdrop == items[0]:
+                    backdrop.selected = False
+                else:
+                    for node in nodes:
+                        node.selected = False
+            # if no modifier keys then add to selection set.
+            else:
+                if backdrop:
+                    selection.add(backdrop)
+                    for n in backdrop.get_nodes():
+                        selection.add(n)
+                for node in nodes:
+                    if node.selected:
+                        selection.add(node)
+
+        selection.update(self.selected_nodes())
+
+        # update the recorded node positions.
+        self._node_positions.update({n: n.xy_pos for n in selection})
+
+        # show selection marquee.
+        if self.LMB_state and not items:
+            rect = QtCore.QRect(self._previous_pos, QtCore.QSize())
+            rect = rect.normalized()
+            map_rect = self.mapToScene(rect).boundingRect()
+            self.scene().update(map_rect)
+            self._rubber_band.setGeometry(rect)
+            self._rubber_band.isActive = True
+
+        # stop here so we don't select a node.
+        # (ctrl modifier can be used for something else in future.)
+        if self.CTRL_state:
+            return
+
+        # allow new live pipe with the shift modifier on port that allow
+        # for multi connection.
+        if self.SHIFT_state:
+            if pipes:
+                pipes[0].reset()
+                port = pipes[0].port_from_pos(map_pos, reverse=True)
+                if not port.locked and port.multi_connection:
+                    self._cursor_text.setPlainText('')
+                    self._cursor_text.setVisible(False)
+                    self.start_live_connection(port)
+
+            # return here as the default behaviour unselects nodes with
+            # the shift modifier.
+            return
+
+        if not self._LIVE_PIPE.isVisible():
+            super(NodeViewer, self).mousePressEvent(event)
+
+    def mouseReleaseEvent(self, event):
+        if event.button() == QtCore.Qt.LeftButton:
+            self.LMB_state = False
+        elif event.button() == QtCore.Qt.RightButton:
+            self.RMB_state = False
+        elif event.button() == QtCore.Qt.MiddleButton:
+            self.MMB_state = False
+
+        # hide pipe slicer.
+        if self._SLICER_PIPE.isVisible():
+            self._on_pipes_sliced(self._SLICER_PIPE.path())
+            p = QtCore.QPointF(0.0, 0.0)
+            self._SLICER_PIPE.draw_path(p, p)
+            self._SLICER_PIPE.setVisible(False)
+
+        # hide selection marquee
+        if self._rubber_band.isActive:
+            self._rubber_band.isActive = False
+            if self._rubber_band.isVisible():
+                rect = self._rubber_band.rect()
+                map_rect = self.mapToScene(rect).boundingRect()
+                self._rubber_band.hide()
+
+                rect = QtCore.QRect(self._origin_pos, event.pos()).normalized()
+                rect_items = self.scene().items(
+                    self.mapToScene(rect).boundingRect()
+                )
+                node_ids = []
+                for item in rect_items:
+                    if isinstance(item, AbstractNodeItem):
+                        node_ids.append(item.id)
+
+                # emit the node selection signals.
+                if node_ids:
+                    prev_ids = [
+                        n.id for n in self._prev_selection_nodes
+                        if not n.selected
+                    ]
+                    self.node_selected.emit(node_ids[0])
+                    self.node_selection_changed.emit(node_ids, prev_ids)
+
+                self.scene().update(map_rect)
+                return
+
+        # find position changed nodes and emit signal.
+        moved_nodes = {
+            n: xy_pos for n, xy_pos in self._node_positions.items()
+            if n.xy_pos != xy_pos
+        }
+        # only emit of node is not colliding with a pipe.
+        if moved_nodes and not self.COLLIDING_state:
+            self.moved_nodes.emit(moved_nodes)
+
+        # reset recorded positions.
+        self._node_positions = {}
+
+        # emit signal if selected node collides with pipe.
+        # Note: if collide state is true then only 1 node is selected.
+        nodes, pipes = self.selected_items()
+        if self.COLLIDING_state and nodes and pipes:
+            self.insert_node.emit(pipes[0], nodes[0].id, moved_nodes)
+
+        # emit node selection changed signal.
+        prev_ids = [n.id for n in self._prev_selection_nodes if not n.selected]
+        node_ids = [n.id for n in nodes if n not in self._prev_selection_nodes]
+        self.node_selection_changed.emit(node_ids, prev_ids)
+
+        super(NodeViewer, self).mouseReleaseEvent(event)
+
+    def mouseMoveEvent(self, event):
+        if self.ALT_state and self.SHIFT_state:
+            if self.pipe_slicing:
+                if self.LMB_state and self._SLICER_PIPE.isVisible():
+                    p1 = self._SLICER_PIPE.path().pointAtPercent(0)
+                    p2 = self.mapToScene(self._previous_pos)
+                    self._SLICER_PIPE.draw_path(p1, p2)
+                    self._SLICER_PIPE.show()
+            self._previous_pos = event.pos()
+            super(NodeViewer, self).mouseMoveEvent(event)
+            return
+
+        if self.MMB_state and self.ALT_state:
+            pos_x = (event.x() - self._previous_pos.x())
+            zoom = 0.1 if pos_x > 0 else -0.1
+            self._set_viewer_zoom(zoom, 0.05, pos=event.pos())
+        elif self.MMB_state or (self.LMB_state and self.ALT_state):
+            previous_pos = self.mapToScene(self._previous_pos)
+            current_pos = self.mapToScene(event.pos())
+            delta = previous_pos - current_pos
+            self._set_viewer_pan(delta.x(), delta.y())
+
+        if not self.ALT_state:
+            if self.SHIFT_state or self.CTRL_state:
+                if not self._LIVE_PIPE.isVisible():
+                    self._cursor_text.setPos(self.mapToScene(event.pos()))
+
+        if self.LMB_state and self._rubber_band.isActive:
+            rect = QtCore.QRect(self._origin_pos, event.pos()).normalized()
+            # if the rubber band is too small, do not show it.
+            if max(rect.width(), rect.height()) > 5:
+                if not self._rubber_band.isVisible():
+                    self._rubber_band.show()
+                map_rect = self.mapToScene(rect).boundingRect()
+                path = QtGui.QPainterPath()
+                path.addRect(map_rect)
+                self._rubber_band.setGeometry(rect)
+                self.scene().setSelectionArea(
+                    path, QtCore.Qt.IntersectsItemShape
+                )
+                self.scene().update(map_rect)
+
+                if self.SHIFT_state or self.CTRL_state:
+                    nodes, pipes = self.selected_items()
+
+                    for node in self._prev_selection_nodes:
+                        node.selected = True
+
+                    if self.CTRL_state:
+                        for pipe in pipes:
+                            pipe.setSelected(False)
+                        for node in nodes:
+                            node.selected = False
+
+        elif self.LMB_state:
+            self.COLLIDING_state = False
+            nodes, pipes = self.selected_items()
+            if len(nodes) == 1:
+                node = nodes[0]
+                [p.setSelected(False) for p in pipes]
+
+                if self.pipe_collision:
+                    colliding_pipes = [
+                        i for i in node.collidingItems()
+                        if isinstance(i, PipeItem) and i.isVisible()
+                    ]
+                    for pipe in colliding_pipes:
+                        if not pipe.input_port:
+                            continue
+                        port_node_check = all([
+                            not pipe.input_port.node is node,
+                            not pipe.output_port.node is node
+                        ])
+                        if port_node_check:
+                            pipe.setSelected(True)
+                            self.COLLIDING_state = True
+                            break
+
+        self._previous_pos = event.pos()
+        super(NodeViewer, self).mouseMoveEvent(event)
+
+    def wheelEvent(self, event):
+        try:
+            delta = event.delta()
+        except AttributeError:
+            # For PyQt5
+            delta = event.angleDelta().y()
+            if delta == 0:
+                delta = event.angleDelta().x()
+        self._set_viewer_zoom(delta, pos=event.pos())
+
+    def dropEvent(self, event):
+        pos = self.mapToScene(event.pos())
+        event.setDropAction(QtCore.Qt.CopyAction)
+        self.data_dropped.emit(
+            event.mimeData(), QtCore.QPoint(pos.x(), pos.y()))
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat('text/uri-list'):
+            event.accept()
+        else:
+            event.ignore()
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat('text/uri-list'):
+            event.accept()
+        else:
+            event.ignore()
+
+    def dragLeaveEvent(self, event):
+        event.ignore()
+
+    def keyPressEvent(self, event):
+        """
+        Key press event re-implemented to update the states for attributes:
+        - ALT_state
+        - CTRL_state
+        - SHIFT_state
+
+        Args:
+            event (QtGui.QKeyEvent): key event.
+        """
+        self.ALT_state = event.modifiers() == QtCore.Qt.AltModifier
+        self.CTRL_state = event.modifiers() == QtCore.Qt.ControlModifier
+        self.SHIFT_state = event.modifiers() == QtCore.Qt.ShiftModifier
+
+        # Todo: find a better solution to catch modifier keys.
+        if event.modifiers() == (QtCore.Qt.AltModifier | QtCore.Qt.ShiftModifier):
+            self.ALT_state = True
+            self.SHIFT_state = True
+
+        if self._LIVE_PIPE.isVisible():
+            super(NodeViewer, self).keyPressEvent(event)
+            return
+
+        # show cursor text
+        overlay_text = None
+        self._cursor_text.setVisible(False)
+        if not self.ALT_state:
+            if self.SHIFT_state:
+                overlay_text = '\n    SHIFT:\n    Toggle/Extend Selection'
+            elif self.CTRL_state:
+                overlay_text = '\n    CTRL:\n    Deselect Nodes'
+        elif self.ALT_state and self.SHIFT_state:
+            if self.pipe_slicing:
+                overlay_text = '\n    ALT + SHIFT:\n    Pipe Slicer Enabled'
+        if overlay_text:
+            self._cursor_text.setPlainText(overlay_text)
+            self._cursor_text.setPos(self.mapToScene(self._previous_pos))
+            self._cursor_text.setVisible(True)
+
+        super(NodeViewer, self).keyPressEvent(event)
+
+    def keyReleaseEvent(self, event):
+        """
+        Key release event re-implemented to update the states for attributes:
+        - ALT_state
+        - CTRL_state
+        - SHIFT_state
+
+        Args:
+            event (QtGui.QKeyEvent): key event.
+        """
+        self.ALT_state = event.modifiers() == QtCore.Qt.AltModifier
+        self.CTRL_state = event.modifiers() == QtCore.Qt.ControlModifier
+        self.SHIFT_state = event.modifiers() == QtCore.Qt.ShiftModifier
+        super(NodeViewer, self).keyReleaseEvent(event)
+
+        # hide and reset cursor text.
+        self._cursor_text.setPlainText('')
+        self._cursor_text.setVisible(False)
+
+    # --- scene events ---
+
+    def sceneMouseMoveEvent(self, event):
+        """
+        triggered mouse move event for the scene.
+         - redraw the live connection pipe.
+
+        Args:
+            event (QtWidgets.QGraphicsSceneMouseEvent):
+                The event handler from the QtWidgets.QGraphicsScene
+        """
+        if not self._LIVE_PIPE.isVisible():
+            return
+        if not self._start_port:
+            return
+
+        pos = event.scenePos()
+        pointer_color = None
+        for item in self.scene().items(pos):
+            if not isinstance(item, PortItem):
+                continue
+
+            x = item.boundingRect().width() / 2
+            y = item.boundingRect().height() / 2
+            pos = item.scenePos()
+            pos.setX(pos.x() + x)
+            pos.setY(pos.y() + y)
+            if item == self._start_port:
+                break
+            pointer_color = PipeEnum.HIGHLIGHT_COLOR.value
+            accept = self._validate_accept_connection(self._start_port, item)
+            if not accept:
+                pointer_color = [150, 60, 255]
+                break
+            reject = self._validate_reject_connection(self._start_port, item)
+            if reject:
+                pointer_color = [150, 60, 255]
+                break
+
+            if self.acyclic:
+                if item.node == self._start_port.node:
+                    pointer_color = PipeEnum.DISABLED_COLOR.value
+                elif item.port_type == self._start_port.port_type:
+                    pointer_color = PipeEnum.DISABLED_COLOR.value
+            break
+
+        self._LIVE_PIPE.draw_path(
+            self._start_port, cursor_pos=pos, color=pointer_color
+        )
+
+    def sceneMousePressEvent(self, event):
+        """
+        triggered mouse press event for the scene (takes priority over viewer event).
+         - detect selected pipe and start connection.
+         - remap Shift and Ctrl modifier.
+
+        Args:
+            event (QtWidgets.QGraphicsScenePressEvent):
+                The event handler from the QtWidgets.QGraphicsScene
+        """
+        # pipe slicer enabled.
+        if self.ALT_state and self.SHIFT_state:
+            return
+
+        # viewer pan mode.
+        if self.ALT_state:
+            return
+
+        if self._LIVE_PIPE.isVisible():
+            self.apply_live_connection(event)
+            return
+
+        pos = event.scenePos()
+        items = self._items_near(pos, None, 5, 5)
+
+        # filter from the selection stack in the following order
+        # "node, port, pipe" this is to avoid selecting items under items.
+        node, port, pipe = None, None, None
+        for item in items:
+            if isinstance(item, AbstractNodeItem):
+                node = item
+            elif isinstance(item, PortItem):
+                port = item
+            elif isinstance(item, PipeItem):
+                pipe = item
+            if any([node, port, pipe]):
+                break
+
+        if port:
+            if port.locked:
+                return
+
+            if not port.multi_connection and port.connected_ports:
+                self._detached_port = port.connected_ports[0]
+            self.start_live_connection(port)
+            if not port.multi_connection:
+                [p.delete() for p in port.connected_pipes]
+            return
+
+        if node:
+            node_items = self._items_near(pos, AbstractNodeItem, 3, 3)
+
+            # record the node positions at selection time.
+            for n in node_items:
+                self._node_positions[n] = n.xy_pos
+
+            # emit selected node id with LMB.
+            if event.button() == QtCore.Qt.LeftButton:
+                self.node_selected.emit(node.id)
+
+            if not isinstance(node, BackdropNodeItem):
+                return
+
+        if pipe:
+            if not self.LMB_state:
+                return
+
+            from_port = pipe.port_from_pos(pos, True)
+
+            if from_port.locked:
+                return
+
+            from_port.hovered = True
+
+            attr = {
+                PortTypeEnum.IN.value: 'output_port',
+                PortTypeEnum.OUT.value: 'input_port'
+            }
+            self._detached_port = getattr(pipe, attr[from_port.port_type])
+            self.start_live_connection(from_port)
+            self._LIVE_PIPE.draw_path(self._start_port, cursor_pos=pos)
+
+            if self.SHIFT_state:
+                self._LIVE_PIPE.shift_selected = True
+                return
+
+            pipe.delete()
+
+    def sceneMouseReleaseEvent(self, event):
+        """
+        triggered mouse release event for the scene.
+
+        Args:
+            event (QtWidgets.QGraphicsSceneMouseEvent):
+                The event handler from the QtWidgets.QGraphicsScene
+        """
+        if event.button() != QtCore.Qt.MiddleButton:
+            self.apply_live_connection(event)
+
+    # --- port connections ---
+
+    def _validate_accept_connection(self, from_port, to_port):
+        """
+        Check if a pipe connection is allowed if there are a constraints set
+        on the ports.
+
+        Args:
+            from_port (PortItem):
+            to_port (PortItem):
+
+        Returns:
+            bool: true to allow connection.
+        """
+        accept_validation = []
+
+        to_ptype = to_port.port_type
+        from_ptype = from_port.port_type
+
+        # validate the start.
+        from_data = self.accept_connection_types.get(from_port.node.type_) or {}
+        constraints = from_data.get(from_ptype, {}).get(from_port.name, {})
+        accept_data = constraints.get(to_port.node.type_, {})
+        accepted_pnames = accept_data.get(to_ptype, {})
+        if constraints:
+            if to_port.name in accepted_pnames:
+                accept_validation.append(True)
+            else:
+                accept_validation.append(False)
+
+        # validate the end.
+        to_data = self.accept_connection_types.get(to_port.node.type_) or {}
+        constraints = to_data.get(to_ptype, {}).get(to_port.name, {})
+        accept_data = constraints.get(from_port.node.type_, {})
+        accepted_pnames = accept_data.get(from_ptype, {})
+        if constraints:
+            if from_port.name in accepted_pnames:
+                accept_validation.append(True)
+            else:
+                accept_validation.append(False)
+
+        if False in accept_validation:
+            return False
+        return True
+
+    def _validate_reject_connection(self, from_port, to_port):
+        """
+        Check if a pipe connection is NOT allowed if there are a constrains set
+        on the ports.
+
+        Args:
+            from_port (PortItem):
+            to_port (PortItem):
+
+        Returns:
+            bool: true to reject connection.
+        """
+        to_ptype = to_port.port_type
+        from_ptype = from_port.port_type
+
+        to_data = self.reject_connection_types.get(to_port.node.type_) or {}
+        constraints = to_data.get(to_ptype, {}).get(to_port.name, {})
+        reject_data = constraints.get(from_port.node.type_, {})
+
+        rejected_pnames = reject_data.get(from_ptype)
+        if rejected_pnames:
+            if from_port.name in rejected_pnames:
+                return True
+            return False
+
+        from_data = self.reject_connection_types.get(from_port.node.type_) or {}
+        constraints = from_data.get(from_ptype, {}).get(from_port.name, {})
+        reject_data = constraints.get(to_port.node.type_, {})
+
+        rejected_pnames = reject_data.get(to_ptype)
+        if rejected_pnames:
+            if to_port.name in rejected_pnames:
+                return True
+            return False
+        return False
+
+    def apply_live_connection(self, event):
+        """
+        triggered mouse press/release event for the scene.
+        - verifies the live connection pipe.
+        - makes a connection pipe if valid.
+        - emits the "connection changed" signal.
+
+        Args:
+            event (QtWidgets.QGraphicsSceneMouseEvent):
+                The event handler from the QtWidgets.QGraphicsScene
+        """
+        if not self._LIVE_PIPE.isVisible():
+            return
+
+        self._start_port.hovered = False
+
+        # find the end port.
+        end_port = None
+        for item in self.scene().items(event.scenePos()):
+            if isinstance(item, PortItem):
+                end_port = item
+                break
+
+        connected = []
+        disconnected = []
+
+        # if port disconnected from existing pipe.
+        if end_port is None:
+            if self._detached_port and not self._LIVE_PIPE.shift_selected:
+                dist = math.hypot(self._previous_pos.x() - self._origin_pos.x(),
+                                  self._previous_pos.y() - self._origin_pos.y())
+                if dist <= 2.0:  # cursor pos threshold.
+                    self.establish_connection(self._start_port,
+                                              self._detached_port)
+                    self._detached_port = None
+                else:
+                    disconnected.append((self._start_port, self._detached_port))
+                    self.connection_changed.emit(disconnected, connected)
+
+            self._detached_port = None
+            self.end_live_connection()
+            return
+
+        else:
+            if self._start_port is end_port:
+                return
+
+        # if connection to itself
+        same_node_connection = end_port.node == self._start_port.node
+        if not self.acyclic:
+            # allow a node cycle connection.
+            same_node_connection = False
+
+        # constrain check
+        accept_connection = self._validate_accept_connection(
+            self._start_port, end_port
+        )
+        reject_connection = self._validate_reject_connection(
+            self._start_port, end_port
+        )
+
+        # restore connection check.
+        restore_connection = any([
+            # if the end port is locked.
+            end_port.locked,
+            # if same port type.
+            end_port.port_type == self._start_port.port_type,
+            # if connection to itself.
+            same_node_connection,
+            # if end port is the start port.
+            end_port == self._start_port,
+            # if detached port is the end port.
+            self._detached_port == end_port,
+            # if a port has a accept port type constrain.
+            not accept_connection,
+            # if a port has a reject port type constrain.
+            reject_connection
+        ])
+        if restore_connection:
+            if self._detached_port:
+                to_port = self._detached_port or end_port
+                self.establish_connection(self._start_port, to_port)
+                self._detached_port = None
+            self.end_live_connection()
+            return
+
+        # end connection if starting port is already connected.
+        if self._start_port.multi_connection and \
+                self._start_port in end_port.connected_ports:
+            self._detached_port = None
+            self.end_live_connection()
+            return
+
+        # register as disconnected if not acyclic.
+        if self.acyclic and not self.acyclic_check(self._start_port, end_port):
+            if self._detached_port:
+                disconnected.append((self._start_port, self._detached_port))
+
+            self.connection_changed.emit(disconnected, connected)
+
+            self._detached_port = None
+            self.end_live_connection()
+            return
+
+        # make connection.
+        if not end_port.multi_connection and end_port.connected_ports:
+            dettached_end = end_port.connected_ports[0]
+            disconnected.append((end_port, dettached_end))
+
+        if self._detached_port:
+            disconnected.append((self._start_port, self._detached_port))
+
+        connected.append((self._start_port, end_port))
+
+        self.connection_changed.emit(disconnected, connected)
+
+        self._detached_port = None
+        self.end_live_connection()
+
+    def start_live_connection(self, selected_port):
+        """
+        create new pipe for the connection.
+        (show the live pipe visibility from the port following the cursor position)
+        """
+        if not selected_port:
+            return
+        self._start_port = selected_port
+        if self._start_port.type == PortTypeEnum.IN.value:
+            self._LIVE_PIPE.input_port = self._start_port
+        elif self._start_port == PortTypeEnum.OUT.value:
+            self._LIVE_PIPE.output_port = self._start_port
+        self._LIVE_PIPE.setVisible(True)
+        self._LIVE_PIPE.draw_index_pointer(
+            selected_port,
+            self.mapToScene(self._origin_pos)
+        )
+
+    def end_live_connection(self):
+        """
+        delete live connection pipe and reset start port.
+        (hides the pipe item used for drawing the live connection)
+        """
+        self._LIVE_PIPE.reset_path()
+        self._LIVE_PIPE.setVisible(False)
+        self._LIVE_PIPE.shift_selected = False
+        self._start_port = None
+
+    def establish_connection(self, start_port, end_port):
+        """
+        establish a new pipe connection.
+        (adds a new pipe item to draw between 2 ports)
+        """
+        pipe = PipeItem()
+        self.scene().addItem(pipe)
+        pipe.set_connections(start_port, end_port)
+        pipe.draw_path(pipe.input_port, pipe.output_port)
+        if start_port.node.selected or end_port.node.selected:
+            pipe.highlight()
+        if not start_port.node.visible or not end_port.node.visible:
+            pipe.hide()
+
+    @staticmethod
+    def acyclic_check(start_port, end_port):
+        """
+        Validate the node connections so it doesn't loop itself.
+
+        Args:
+            start_port (PortItem): port item.
+            end_port (PortItem): port item.
+
+        Returns:
+            bool: True if port connection is valid.
+        """
+        start_node = start_port.node
+        check_nodes = [end_port.node]
+        io_types = {
+            PortTypeEnum.IN.value: 'outputs',
+            PortTypeEnum.OUT.value: 'inputs'
+        }
+        while check_nodes:
+            check_node = check_nodes.pop(0)
+            for check_port in getattr(check_node, io_types[end_port.port_type]):
+                if check_port.connected_ports:
+                    for port in check_port.connected_ports:
+                        if port.node != start_node:
+                            check_nodes.append(port.node)
+                        else:
+                            return False
+        return True
+
+    # --- viewer ---
+
+    def tab_search_set_nodes(self, nodes):
+        self._search_widget.set_nodes(nodes)
+
+    def tab_search_toggle(self):
+        state = self._search_widget.isVisible()
+        if not state:
+            self._search_widget.setVisible(state)
+            self.setFocus()
+            return
+
+        pos = self._previous_pos
+        rect = self._search_widget.rect()
+        new_pos = QtCore.QPoint(int(pos.x() - rect.width() / 2),
+                                int(pos.y() - rect.height() / 2))
+        self._search_widget.move(new_pos)
+        self._search_widget.setVisible(state)
+        self._search_widget.setFocus()
+
+        rect = self.mapToScene(rect).boundingRect()
+        self.scene().update(rect)
+
+    def rebuild_tab_search(self):
+        if isinstance(self._search_widget, TabSearchMenuWidget):
+            self._search_widget.rebuild = True
+
+    def qaction_for_undo(self):
+        """
+        Get the undo QAction from the parent undo stack.
+
+        Returns:
+            QtWidgets.QAction: undo action.
+        """
+        return self._undo_action
+
+    def qaction_for_redo(self):
+        """
+        Get the redo QAction from the parent undo stack.
+
+        Returns:
+            QtWidgets.QAction: redo action.
+        """
+        return self._redo_action
+
+    def context_menus(self):
+        """
+        All the available context menus for the viewer.
+
+        Returns:
+            dict: viewer context menu.
+        """
+        return {'graph': self._ctx_graph_menu, 'nodes': self._ctx_node_menu}
+
+    def question_dialog(self, text, title='Node Graph'):
+        """
+        Prompt node viewer question dialog widget with "yes", "no" buttons.
+
+        Args:
+            text (str): dialog text.
+            title (str): dialog window title.
+
+        Returns:
+            bool: true if user click yes.
+        """
+        self.clear_key_state()
+        return BaseDialog.question_dialog(text, title)
+
+    def message_dialog(self, text, title='Node Graph'):
+        """
+        Prompt node viewer message dialog widget with "ok" button.
+
+        Args:
+            text (str): dialog text.
+            title (str): dialog window title.
+        """
+        self.clear_key_state()
+        BaseDialog.message_dialog(text, title)
+
+    def load_dialog(self, current_dir=None, ext=None):
+        """
+        Prompt node viewer file load dialog widget.
+
+        Args:
+            current_dir (str): directory path starting point. (optional)
+            ext (str): custom file extension filter type. (optional)
+
+        Returns:
+            str: selected file path.
+        """
+        self.clear_key_state()
+        ext = '*{} '.format(ext) if ext else ''
+        ext_filter = ';;'.join([
+            'Node Graph ({}*json)'.format(ext), 'All Files (*)'
+        ])
+        file_dlg = FileDialog.getOpenFileName(
+            self, 'Open File', current_dir, ext_filter)
+        file = file_dlg[0] or None
+        return file
+
+    def save_dialog(self, current_dir=None, ext=None):
+        """
+        Prompt node viewer file save dialog widget.
+
+        Args:
+            current_dir (str): directory path starting point. (optional)
+            ext (str): custom file extension filter type. (optional)
+
+        Returns:
+            str: selected file path.
+        """
+        self.clear_key_state()
+        ext_label = '*{} '.format(ext) if ext else ''
+        ext_type = '.{}'.format(ext) if ext else '.json'
+        ext_map = {'Node Graph ({}*json)'.format(ext_label): ext_type,
+                   'All Files (*)': ''}
+        file_dlg = FileDialog.getSaveFileName(
+            self, 'Save Session', current_dir, ';;'.join(ext_map.keys()))
+        file_path = file_dlg[0]
+        if not file_path:
+            return
+        ext = ext_map[file_dlg[1]]
+        if ext and not file_path.endswith(ext):
+            file_path += ext
+
+        return file_path
+
+    def all_pipes(self):
+        """
+        Returns all pipe qgraphic items.
+
+        Returns:
+            list[PipeItem]: instances of pipe items.
+        """
+        excl = [self._LIVE_PIPE, self._SLICER_PIPE]
+        return [i for i in self.scene().items()
+                if isinstance(i, PipeItem) and i not in excl]
+
+    def all_nodes(self):
+        """
+        Returns all node qgraphic items.
+
+        Returns:
+            list[AbstractNodeItem]: instances of node items.
+        """
+        return [i for i in self.scene().items()
+                if isinstance(i, AbstractNodeItem)]
+
+    def selected_nodes(self):
+        """
+        Returns selected node qgraphic items.
+
+        Returns:
+            list[AbstractNodeItem]: instances of node items.
+        """
+        return [i for i in self.scene().selectedItems()
+                if isinstance(i, AbstractNodeItem)]
+
+    def selected_pipes(self):
+        """
+        Returns selected pipe qgraphic items.
+
+        Returns:
+            list[Pipe]: pipe items.
+        """
+        pipes = [i for i in self.scene().selectedItems()
+                 if isinstance(i, PipeItem)]
+        return pipes
+
+    def selected_items(self):
+        """
+        Return selected graphic items in the scene.
+
+        Returns:
+            tuple(list[AbstractNodeItem], list[Pipe]):
+                selected (node items, pipe items).
+        """
+        nodes = []
+        pipes = []
+        for item in self.scene().selectedItems():
+            if isinstance(item, AbstractNodeItem):
+                nodes.append(item)
+            elif isinstance(item, PipeItem):
+                pipes.append(item)
+        return nodes, pipes
+
+    def add_node(self, node, pos=None):
+        """
+        Add node item into the scene.
+
+        Args:
+            node (AbstractNodeItem): node item instance.
+            pos (tuple or list): node scene position.
+        """
+        pos = pos or (self._previous_pos.x(), self._previous_pos.y())
+        node.pre_init(self, pos)
+        self.scene().addItem(node)
+        node.post_init(self, pos)
+
+    @staticmethod
+    def remove_node(node):
+        """
+        Remove node item from the scene.
+
+        Args:
+            node (AbstractNodeItem): node item instance.
+        """
+        if isinstance(node, AbstractNodeItem):
+            node.delete()
+
+    def move_nodes(self, nodes, pos=None, offset=None):
+        """
+        Globally move specified nodes.
+
+        Args:
+            nodes (list[AbstractNodeItem]): node items.
+            pos (tuple or list): custom x, y position.
+            offset (tuple or list): x, y position offset.
+        """
+        group = self.scene().createItemGroup(nodes)
+        group_rect = group.boundingRect()
+        if pos:
+            x, y = pos
+        else:
+            pos = self.mapToScene(self._previous_pos)
+            x = pos.x() - group_rect.center().x()
+            y = pos.y() - group_rect.center().y()
+        if offset:
+            x += offset[0]
+            y += offset[1]
+        group.setPos(x, y)
+        self.scene().destroyItemGroup(group)
+
+    def get_pipes_from_nodes(self, nodes=None):
+        nodes = nodes or self.selected_nodes()
+        if not nodes:
+            return
+        pipes = []
+        for node in nodes:
+            n_inputs = node.inputs if hasattr(node, 'inputs') else []
+            n_outputs = node.outputs if hasattr(node, 'outputs') else []
+
+            for port in n_inputs:
+                for pipe in port.connected_pipes:
+                    connected_node = pipe.output_port.node
+                    if connected_node in nodes:
+                        pipes.append(pipe)
+            for port in n_outputs:
+                for pipe in port.connected_pipes:
+                    connected_node = pipe.input_port.node
+                    if connected_node in nodes:
+                        pipes.append(pipe)
+        return pipes
+
+    def center_selection(self, nodes=None):
+        """
+        Center on the given nodes or all nodes by default.
+
+        Args:
+            nodes (list[AbstractNodeItem]): a list of node items.
+        """
+        if not nodes:
+            if self.selected_nodes():
+                nodes = self.selected_nodes()
+            elif self.all_nodes():
+                nodes = self.all_nodes()
+            if not nodes:
+                return
+
+        rect = self._combined_rect(nodes)
+        self._scene_range.translate(rect.center() - self._scene_range.center())
+        self.setSceneRect(self._scene_range)
+
+    def get_pipe_layout(self):
+        """
+        Returns the pipe layout mode.
+
+        Returns:
+            int: pipe layout mode.
+        """
+        return self._pipe_layout
+
+    def set_pipe_layout(self, layout):
+        """
+        Sets the pipe layout mode and redraw all pipe items in the scene.
+
+        Args:
+            layout (int): pipe layout mode. (see the constants module)
+        """
+        self._pipe_layout = layout
+        for pipe in self.all_pipes():
+            pipe.draw_path(pipe.input_port, pipe.output_port)
+
+    def get_layout_direction(self):
+        """
+        Returns the layout direction set on the the node graph viewer
+        used by the pipe items for drawing.
+
+        Returns:
+            int: graph layout mode.
+        """
+        return self._layout_direction
+
+    def set_layout_direction(self, direction):
+        """
+        Sets the node graph viewer layout direction for re-drawing
+        the pipe items.
+
+        Args:
+            direction (int): graph layout direction.
+        """
+        self._layout_direction = direction
+        for pipe_item in self.all_pipes():
+            pipe_item.draw_path(pipe_item.input_port, pipe_item.output_port)
+
+    def reset_zoom(self, cent=None):
+        """
+        Reset the viewer zoom level.
+
+        Args:
+            cent (QtCore.QPoint): specified center.
+        """
+        self._scene_range = QtCore.QRectF(0, 0,
+                                          self.size().width(),
+                                          self.size().height())
+        if cent:
+            self._scene_range.translate(cent - self._scene_range.center())
+        self._update_scene()
+
+    def get_zoom(self):
+        """
+        Returns the viewer zoom level.
+
+        Returns:
+            float: zoom level.
+        """
+        transform = self.transform()
+        cur_scale = (transform.m11(), transform.m22())
+        return float('{:0.2f}'.format(cur_scale[0] - 1.0))
+
+    def set_zoom(self, value=0.0):
+        """
+        Set the viewer zoom level.
+
+        Args:
+            value (float): zoom level
+        """
+        if value == 0.0:
+            self.reset_zoom()
+            return
+        zoom = self.get_zoom()
+        if zoom < 0.0:
+            if not (ZOOM_MIN <= zoom <= ZOOM_MAX):
+                return
+        else:
+            if not (ZOOM_MIN <= value <= ZOOM_MAX):
+                return
+        value = value - zoom
+        self._set_viewer_zoom(value, 0.0)
+
+    def zoom_to_nodes(self, nodes):
+        self._scene_range = self._combined_rect(nodes)
+        self._update_scene()
+
+        if self.get_zoom() > 0.1:
+            self.reset_zoom(self._scene_range.center())
+
+    def force_update(self):
+        """
+        Redraw the current node graph scene.
+        """
+        self._update_scene()
+
+    def scene_rect(self):
+        """
+        Returns the scene rect size.
+
+        Returns:
+            list[float]: x, y, width, height
+        """
+        return [self._scene_range.x(), self._scene_range.y(),
+                self._scene_range.width(), self._scene_range.height()]
+
+    def set_scene_rect(self, rect):
+        """
+        Sets the scene rect and redraws the scene.
+
+        Args:
+            rect (list[float]): x, y, width, height
+        """
+        self._scene_range = QtCore.QRectF(*rect)
+        self._update_scene()
+
+    def scene_center(self):
+        """
+        Get the center x,y pos from the scene.
+
+        Returns:
+            list[float]: x, y position.
+        """
+        cent = self._scene_range.center()
+        return [cent.x(), cent.y()]
+
+    def nodes_rect_center(self, nodes):
+        """
+        Get the center x,y pos from the specified nodes.
+
+        Args:
+            nodes (list[AbstractNodeItem]): list of node qgrphics items.
+
+        Returns:
+            list[float]: x, y position.
+        """
+        cent = self._combined_rect(nodes).center()
+        return [cent.x(), cent.y()]
+
+    def clear_key_state(self):
+        """
+        Resets the Ctrl, Shift, Alt modifiers key states.
+        """
+        self.CTRL_state = False
+        self.SHIFT_state = False
+        self.ALT_state = False
+
+    def use_OpenGL(self):
+        """
+        Use QOpenGLWidget as the viewer.
+        """
+        # use QOpenGLWidget instead of the deprecated QGLWidget to avoid
+        # problems with Wayland.
+        import Qt
+        if Qt.IsPySide2:
+            from PySide2.QtWidgets import QOpenGLWidget
+        elif Qt.IsPyQt5:
+            from PyQt5.QtWidgets import QOpenGLWidget
+        self.setViewport(QOpenGLWidget())
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt/widgets/viewer_nav.py` & `NodeGraphQt-0.6.3/NodeGraphQt/widgets/viewer_nav.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,198 +1,198 @@
-from Qt import QtWidgets, QtCore, QtGui
-
-from NodeGraphQt.constants import NodeEnum, ViewerNavEnum
-
-
-class NodeNavigationDelagate(QtWidgets.QStyledItemDelegate):
-
-    def paint(self, painter, option, index):
-        """
-        Args:
-            painter (QtGui.QPainter):
-            option (QtGui.QStyleOptionViewItem):
-            index (QtCore.QModelIndex):
-        """
-        if index.column() != 0:
-            super(NodeNavigationDelagate, self).paint(painter, option, index)
-            return
-
-        item = index.model().item(index.row(), index.column())
-
-        margin = 1.0, 1.0
-        rect = QtCore.QRectF(
-            option.rect.x() + margin[0],
-            option.rect.y() + margin[1],
-            option.rect.width() - (margin[0] * 2),
-            option.rect.height() - (margin[1] * 2)
-        )
-
-        painter.save()
-        painter.setPen(QtCore.Qt.NoPen)
-        painter.setBrush(QtCore.Qt.NoBrush)
-        painter.setRenderHint(QtGui.QPainter.Antialiasing, True)
-
-        # background.
-        bg_color = QtGui.QColor(*ViewerNavEnum.ITEM_COLOR.value)
-        itm_color = QtGui.QColor(80, 128, 123)
-        if option.state & QtWidgets.QStyle.State_Selected:
-            bg_color = bg_color.lighter(120)
-            itm_color = QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value)
-
-        roundness = 2.0
-        painter.setBrush(bg_color)
-        painter.drawRoundedRect(rect, roundness, roundness)
-
-        if index.row() != 0:
-            txt_offset = 8.0
-            m = 6.0
-            x = rect.left() + 2.0 + m
-            y = rect.top() + m + 2
-            h = rect.height() - (m * 2) - 2
-            painter.setBrush(itm_color)
-            for i in range(4):
-                itm_rect = QtCore.QRectF(x, y, 1.3, h)
-                painter.drawRoundedRect(itm_rect, 1.0, 1.0)
-                x += 2.0
-                y += 2
-                h -= 4
-        else:
-            txt_offset = 5.0
-            x = rect.left() + 4.0
-            size = 10.0
-            for clr in [QtGui.QColor(0, 0, 0, 80), itm_color]:
-                itm_rect = QtCore.QRectF(
-                    x, rect.center().y() - (size / 2), size, size)
-                painter.setBrush(clr)
-                painter.drawRoundedRect(itm_rect, 2.0, 2.0)
-                size -= 5.0
-                x += 2.5
-
-        # text
-        # pen_color = option.palette.text().color()
-        pen_color = QtGui.QColor(*tuple(map(
-            lambda i, j: i - j, (255, 255, 255), bg_color.getRgb()
-        )))
-        pen = QtGui.QPen(pen_color, 0.5)
-        pen.setCapStyle(QtCore.Qt.RoundCap)
-        painter.setPen(pen)
-
-        font = painter.font()
-        font_metrics = QtGui.QFontMetrics(font)
-        item_text = item.text().replace(' ', '_')
-        if hasattr(font_metrics, 'horizontalAdvance'):
-            font_width = font_metrics.horizontalAdvance(item_text)
-        else:
-            font_width = font_metrics.width(item_text)
-        font_height = font_metrics.height()
-        text_rect = QtCore.QRectF(
-            rect.center().x() - (font_width / 2) + txt_offset,
-            rect.center().y() - (font_height / 2),
-            font_width, font_height
-        )
-        painter.drawText(text_rect, item.text())
-        painter.restore()
-
-
-class NodeNavigationWidget(QtWidgets.QListView):
-
-    navigation_changed = QtCore.Signal(str, list)
-
-    def __init__(self, parent=None):
-        super(NodeNavigationWidget, self).__init__(parent)
-        self.setSelectionMode(self.SingleSelection)
-        self.setResizeMode(self.Adjust)
-        self.setViewMode(self.ListMode)
-        self.setFlow(self.LeftToRight)
-        self.setDragEnabled(False)
-        self.setMinimumHeight(20)
-        self.setMaximumHeight(36)
-        self.setSpacing(0)
-
-        # self.viewport().setAutoFillBackground(False)
-        self.setStyleSheet(
-            'QListView {{border: 0px;background-color: rgb({0},{1},{2});}}'
-            .format(*ViewerNavEnum.BACKGROUND_COLOR.value)
-        )
-
-        self.setItemDelegate(NodeNavigationDelagate(self))
-        self.setModel(QtGui.QStandardItemModel())
-
-    def keyPressEvent(self, event):
-        event.ignore()
-
-    def mouseReleaseEvent(self, event):
-        super(NodeNavigationWidget, self).mouseReleaseEvent(event)
-        if not self.selectedIndexes():
-            return
-        index = self.selectedIndexes()[0]
-        rows = reversed(range(1, self.model().rowCount()))
-        if index.row() == 0:
-            rows = [r for r in rows if r > 0]
-        else:
-            rows = [r for r in rows if index.row() < r]
-        if not rows:
-            return
-        rm_node_ids = [self.model().item(r, 0).toolTip() for r in rows]
-        node_id = self.model().item(index.row(), 0).toolTip()
-        [self.model().removeRow(r) for r in rows]
-        self.navigation_changed.emit(node_id, rm_node_ids)
-
-    def clear(self):
-        self.model().sourceMode().clear()
-
-    def add_label_item(self, label, node_id):
-        item = QtGui.QStandardItem(label)
-        item.setToolTip(node_id)
-        metrics = QtGui.QFontMetrics(item.font())
-        if hasattr(metrics, 'horizontalAdvance'):
-            width = metrics.horizontalAdvance(item.text())
-        else:
-            width = metrics.width(item.text())
-        width *= 1.5
-        item.setSizeHint(QtCore.QSize(width, 20))
-        self.model().appendRow(item)
-        self.selectionModel().setCurrentIndex(
-            self.model().indexFromItem(item),
-            QtCore.QItemSelectionModel.ClearAndSelect)
-
-    def update_label_item(self, label, node_id):
-        rows = reversed(range(self.model().rowCount()))
-        for r in rows:
-            item = self.model().item(r, 0)
-            if item.toolTip() == node_id:
-                item.setText(label)
-
-    def remove_label_item(self, node_id):
-        rows = reversed(range(1, self.model().rowCount()))
-        node_ids = [self.model().item(r, 0).toolTip() for r in rows]
-        if node_id not in node_ids:
-            return
-        index = node_ids.index(node_id)
-        if index == 0:
-            rows = [r for r in rows if r > 0]
-        else:
-            rows = [r for r in rows if index < r]
-        [self.model().removeRow(r) for r in rows]
-
-
-if __name__ == '__main__':
-    import sys
-
-    def on_nav_changed(selected_id, remove_ids):
-        print(selected_id, remove_ids)
-
-    app = QtWidgets.QApplication(sys.argv)
-
-    widget = NodeNavigationWidget()
-    widget.navigation_changed.connect(on_nav_changed)
-
-    widget.add_label_item('Close Graph', 'root')
-    for i in range(1, 5):
-        widget.add_label_item(
-            'group node {}'.format(i),
-            'node_id{}'.format(i)
-        )
-    widget.resize(600, 30)
-    widget.show()
-
-    app.exec_()
+from Qt import QtWidgets, QtCore, QtGui
+
+from NodeGraphQt.constants import NodeEnum, ViewerNavEnum
+
+
+class NodeNavigationDelagate(QtWidgets.QStyledItemDelegate):
+
+    def paint(self, painter, option, index):
+        """
+        Args:
+            painter (QtGui.QPainter):
+            option (QtGui.QStyleOptionViewItem):
+            index (QtCore.QModelIndex):
+        """
+        if index.column() != 0:
+            super(NodeNavigationDelagate, self).paint(painter, option, index)
+            return
+
+        item = index.model().item(index.row(), index.column())
+
+        margin = 1.0, 1.0
+        rect = QtCore.QRectF(
+            option.rect.x() + margin[0],
+            option.rect.y() + margin[1],
+            option.rect.width() - (margin[0] * 2),
+            option.rect.height() - (margin[1] * 2)
+        )
+
+        painter.save()
+        painter.setPen(QtCore.Qt.NoPen)
+        painter.setBrush(QtCore.Qt.NoBrush)
+        painter.setRenderHint(QtGui.QPainter.Antialiasing, True)
+
+        # background.
+        bg_color = QtGui.QColor(*ViewerNavEnum.ITEM_COLOR.value)
+        itm_color = QtGui.QColor(80, 128, 123)
+        if option.state & QtWidgets.QStyle.State_Selected:
+            bg_color = bg_color.lighter(120)
+            itm_color = QtGui.QColor(*NodeEnum.SELECTED_BORDER_COLOR.value)
+
+        roundness = 2.0
+        painter.setBrush(bg_color)
+        painter.drawRoundedRect(rect, roundness, roundness)
+
+        if index.row() != 0:
+            txt_offset = 8.0
+            m = 6.0
+            x = rect.left() + 2.0 + m
+            y = rect.top() + m + 2
+            h = rect.height() - (m * 2) - 2
+            painter.setBrush(itm_color)
+            for i in range(4):
+                itm_rect = QtCore.QRectF(x, y, 1.3, h)
+                painter.drawRoundedRect(itm_rect, 1.0, 1.0)
+                x += 2.0
+                y += 2
+                h -= 4
+        else:
+            txt_offset = 5.0
+            x = rect.left() + 4.0
+            size = 10.0
+            for clr in [QtGui.QColor(0, 0, 0, 80), itm_color]:
+                itm_rect = QtCore.QRectF(
+                    x, rect.center().y() - (size / 2), size, size)
+                painter.setBrush(clr)
+                painter.drawRoundedRect(itm_rect, 2.0, 2.0)
+                size -= 5.0
+                x += 2.5
+
+        # text
+        # pen_color = option.palette.text().color()
+        pen_color = QtGui.QColor(*tuple(map(
+            lambda i, j: i - j, (255, 255, 255), bg_color.getRgb()
+        )))
+        pen = QtGui.QPen(pen_color, 0.5)
+        pen.setCapStyle(QtCore.Qt.RoundCap)
+        painter.setPen(pen)
+
+        font = painter.font()
+        font_metrics = QtGui.QFontMetrics(font)
+        item_text = item.text().replace(' ', '_')
+        if hasattr(font_metrics, 'horizontalAdvance'):
+            font_width = font_metrics.horizontalAdvance(item_text)
+        else:
+            font_width = font_metrics.width(item_text)
+        font_height = font_metrics.height()
+        text_rect = QtCore.QRectF(
+            rect.center().x() - (font_width / 2) + txt_offset,
+            rect.center().y() - (font_height / 2),
+            font_width, font_height
+        )
+        painter.drawText(text_rect, item.text())
+        painter.restore()
+
+
+class NodeNavigationWidget(QtWidgets.QListView):
+
+    navigation_changed = QtCore.Signal(str, list)
+
+    def __init__(self, parent=None):
+        super(NodeNavigationWidget, self).__init__(parent)
+        self.setSelectionMode(self.SingleSelection)
+        self.setResizeMode(self.Adjust)
+        self.setViewMode(self.ListMode)
+        self.setFlow(self.LeftToRight)
+        self.setDragEnabled(False)
+        self.setMinimumHeight(20)
+        self.setMaximumHeight(36)
+        self.setSpacing(0)
+
+        # self.viewport().setAutoFillBackground(False)
+        self.setStyleSheet(
+            'QListView {{border: 0px;background-color: rgb({0},{1},{2});}}'
+            .format(*ViewerNavEnum.BACKGROUND_COLOR.value)
+        )
+
+        self.setItemDelegate(NodeNavigationDelagate(self))
+        self.setModel(QtGui.QStandardItemModel())
+
+    def keyPressEvent(self, event):
+        event.ignore()
+
+    def mouseReleaseEvent(self, event):
+        super(NodeNavigationWidget, self).mouseReleaseEvent(event)
+        if not self.selectedIndexes():
+            return
+        index = self.selectedIndexes()[0]
+        rows = reversed(range(1, self.model().rowCount()))
+        if index.row() == 0:
+            rows = [r for r in rows if r > 0]
+        else:
+            rows = [r for r in rows if index.row() < r]
+        if not rows:
+            return
+        rm_node_ids = [self.model().item(r, 0).toolTip() for r in rows]
+        node_id = self.model().item(index.row(), 0).toolTip()
+        [self.model().removeRow(r) for r in rows]
+        self.navigation_changed.emit(node_id, rm_node_ids)
+
+    def clear(self):
+        self.model().sourceMode().clear()
+
+    def add_label_item(self, label, node_id):
+        item = QtGui.QStandardItem(label)
+        item.setToolTip(node_id)
+        metrics = QtGui.QFontMetrics(item.font())
+        if hasattr(metrics, 'horizontalAdvance'):
+            width = metrics.horizontalAdvance(item.text())
+        else:
+            width = metrics.width(item.text())
+        width *= 1.5
+        item.setSizeHint(QtCore.QSize(width, 20))
+        self.model().appendRow(item)
+        self.selectionModel().setCurrentIndex(
+            self.model().indexFromItem(item),
+            QtCore.QItemSelectionModel.ClearAndSelect)
+
+    def update_label_item(self, label, node_id):
+        rows = reversed(range(self.model().rowCount()))
+        for r in rows:
+            item = self.model().item(r, 0)
+            if item.toolTip() == node_id:
+                item.setText(label)
+
+    def remove_label_item(self, node_id):
+        rows = reversed(range(1, self.model().rowCount()))
+        node_ids = [self.model().item(r, 0).toolTip() for r in rows]
+        if node_id not in node_ids:
+            return
+        index = node_ids.index(node_id)
+        if index == 0:
+            rows = [r for r in rows if r > 0]
+        else:
+            rows = [r for r in rows if index < r]
+        [self.model().removeRow(r) for r in rows]
+
+
+if __name__ == '__main__':
+    import sys
+
+    def on_nav_changed(selected_id, remove_ids):
+        print(selected_id, remove_ids)
+
+    app = QtWidgets.QApplication(sys.argv)
+
+    widget = NodeNavigationWidget()
+    widget.navigation_changed.connect(on_nav_changed)
+
+    widget.add_label_item('Close Graph', 'root')
+    for i in range(1, 5):
+        widget.add_label_item(
+            'group node {}'.format(i),
+            'node_id{}'.format(i)
+        )
+    widget.resize(600, 30)
+    widget.show()
+
+    app.exec_()
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt.egg-info/PKG-INFO` & `NodeGraphQt-0.6.3/NodeGraphQt.egg-info/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-Metadata-Version: 2.1
-Name: NodeGraphQt
-Version: 0.6.2
-Summary: Node graph framework for PySide2/PyQt5 that can be
-Home-page: https://github.com/jchanvfx/NodeGraphQt
-Author: Johnny Chan
-License: MIT License
-Project-URL: Documentation, https://jchanvfx.github.io/NodeGraphQt/api/html/index.html
-Project-URL: Source, https://github.com/jchanvfx/NodeGraphQt/
-Project-URL: Tracker, https://github.com/jchanvfx/NodeGraphQt/issues
-Classifier: Operating System :: OS Independent
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Programming Language :: Python :: 3.6
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-Provides-Extra: PySide2
-License-File: LICENSE.md
-
-
-# NodeGraphQt
-
-<p align="center">
-    <a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">
-    <img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/logo.png" title="logo">
-    </a>
-</p>
-
-NodeGraphQt is a node graph UI framework for `PySide2` that can be implemented and re-purposed into 
-applications.
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/screenshot.png" width="100%" title="NodeGraphQt">
-
-## Install
-
-NodeGraphQt is avaliable on The Python Package Index (PyPI) [here](https://pypi.org/project/NodeGraphQt) so it can be installed with:
-```
-pip install NodeGraphQt
-```
-or you can download previous versions from the [releases](https://github.com/jchanvfx/NodeGraphQt/releases) page.
-
-
-## Documentation
-
-<a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">https://jchanvfx.github.io/NodeGraphQt</a>
-
-See the [basic_example.py](/examples/basic_example.py) script to get started or check out the API example overview 
-<a href="https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_overview.html#simple-example" target="_blank">here.</a>
-
-## Vertical Layout
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-direction
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/vertical_layout.png" width="800" title="Vertical Layout">
-
-## Pipe Layout
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-styles
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/pipe_layout_types.gif" width="600" title="Pipe Layout">
-
-## Custom Widgets
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/custom_widgets.html
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/prop_bin.png" width="600" title="Properties Bin">
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/nodes_palette.png" width="450" title="Node Palette">
+Metadata-Version: 2.1
+Name: NodeGraphQt
+Version: 0.6.3
+Summary: Node graph framework for PySide2/PyQt5 that can be
+Home-page: https://github.com/jchanvfx/NodeGraphQt
+Author: Johnny Chan
+License: MIT License
+Project-URL: Documentation, https://jchanvfx.github.io/NodeGraphQt/api/html/index.html
+Project-URL: Source, https://github.com/jchanvfx/NodeGraphQt/
+Project-URL: Tracker, https://github.com/jchanvfx/NodeGraphQt/issues
+Classifier: Operating System :: OS Independent
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python :: 3.6
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+Provides-Extra: PySide2
+License-File: LICENSE.md
+
+
+# NodeGraphQt
+
+<p align="center">
+    <a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">
+    <img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/logo.png" title="logo">
+    </a>
+</p>
+
+NodeGraphQt is a node graph UI framework for `PySide2` that can be implemented and re-purposed into 
+applications.
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/screenshot.png" width="100%" title="NodeGraphQt">
+
+## Install
+
+NodeGraphQt is avaliable on The Python Package Index (PyPI) [here](https://pypi.org/project/NodeGraphQt) so it can be installed with:
+```
+pip install NodeGraphQt
+```
+or you can download previous versions from the [releases](https://github.com/jchanvfx/NodeGraphQt/releases) page.
+
+
+## Documentation
+
+<a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">https://jchanvfx.github.io/NodeGraphQt</a>
+
+See the [basic_example.py](/examples/basic_example.py) script to get started or check out the API example overview 
+<a href="https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_overview.html#simple-example" target="_blank">here.</a>
+
+## Vertical Layout
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-direction
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/vertical_layout.png" width="800" title="Vertical Layout">
+
+## Pipe Layout
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-styles
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/pipe_layout_types.gif" width="600" title="Pipe Layout">
+
+## Custom Widgets
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/custom_widgets.html
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/prop_bin.png" width="600" title="Properties Bin">
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/nodes_palette.png" width="450" title="Node Palette">
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: NodeGraphQt Version: 0.6.2 Summary: Node graph
+Metadata-Version: 2.1 Name: NodeGraphQt Version: 0.6.3 Summary: Node graph
 framework for PySide2/PyQt5 that can be Home-page: https://github.com/jchanvfx/
 NodeGraphQt Author: Johnny Chan License: MIT License Project-URL:
 Documentation, https://jchanvfx.github.io/NodeGraphQt/api/html/index.html
 Project-URL: Source, https://github.com/jchanvfx/NodeGraphQt/ Project-URL:
 Tracker, https://github.com/jchanvfx/NodeGraphQt/issues Classifier: Operating
 System :: OS Independent Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3.6 Requires-Python: >=3.6
```

### Comparing `NodeGraphQt-0.6.2/NodeGraphQt.egg-info/SOURCES.txt` & `NodeGraphQt-0.6.3/NodeGraphQt.egg-info/SOURCES.txt`

 * *Files identical despite different names*

### Comparing `NodeGraphQt-0.6.2/PKG-INFO` & `NodeGraphQt-0.6.3/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-Metadata-Version: 2.1
-Name: NodeGraphQt
-Version: 0.6.2
-Summary: Node graph framework for PySide2/PyQt5 that can be
-Home-page: https://github.com/jchanvfx/NodeGraphQt
-Author: Johnny Chan
-License: MIT License
-Project-URL: Documentation, https://jchanvfx.github.io/NodeGraphQt/api/html/index.html
-Project-URL: Source, https://github.com/jchanvfx/NodeGraphQt/
-Project-URL: Tracker, https://github.com/jchanvfx/NodeGraphQt/issues
-Classifier: Operating System :: OS Independent
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Programming Language :: Python :: 3.6
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-Provides-Extra: PySide2
-License-File: LICENSE.md
-
-
-# NodeGraphQt
-
-<p align="center">
-    <a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">
-    <img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/logo.png" title="logo">
-    </a>
-</p>
-
-NodeGraphQt is a node graph UI framework for `PySide2` that can be implemented and re-purposed into 
-applications.
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/screenshot.png" width="100%" title="NodeGraphQt">
-
-## Install
-
-NodeGraphQt is avaliable on The Python Package Index (PyPI) [here](https://pypi.org/project/NodeGraphQt) so it can be installed with:
-```
-pip install NodeGraphQt
-```
-or you can download previous versions from the [releases](https://github.com/jchanvfx/NodeGraphQt/releases) page.
-
-
-## Documentation
-
-<a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">https://jchanvfx.github.io/NodeGraphQt</a>
-
-See the [basic_example.py](/examples/basic_example.py) script to get started or check out the API example overview 
-<a href="https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_overview.html#simple-example" target="_blank">here.</a>
-
-## Vertical Layout
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-direction
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/vertical_layout.png" width="800" title="Vertical Layout">
-
-## Pipe Layout
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-styles
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/pipe_layout_types.gif" width="600" title="Pipe Layout">
-
-## Custom Widgets
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/custom_widgets.html
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/prop_bin.png" width="600" title="Properties Bin">
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/nodes_palette.png" width="450" title="Node Palette">
+Metadata-Version: 2.1
+Name: NodeGraphQt
+Version: 0.6.3
+Summary: Node graph framework for PySide2/PyQt5 that can be
+Home-page: https://github.com/jchanvfx/NodeGraphQt
+Author: Johnny Chan
+License: MIT License
+Project-URL: Documentation, https://jchanvfx.github.io/NodeGraphQt/api/html/index.html
+Project-URL: Source, https://github.com/jchanvfx/NodeGraphQt/
+Project-URL: Tracker, https://github.com/jchanvfx/NodeGraphQt/issues
+Classifier: Operating System :: OS Independent
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python :: 3.6
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+Provides-Extra: PySide2
+License-File: LICENSE.md
+
+
+# NodeGraphQt
+
+<p align="center">
+    <a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">
+    <img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/logo.png" title="logo">
+    </a>
+</p>
+
+NodeGraphQt is a node graph UI framework for `PySide2` that can be implemented and re-purposed into 
+applications.
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/screenshot.png" width="100%" title="NodeGraphQt">
+
+## Install
+
+NodeGraphQt is avaliable on The Python Package Index (PyPI) [here](https://pypi.org/project/NodeGraphQt) so it can be installed with:
+```
+pip install NodeGraphQt
+```
+or you can download previous versions from the [releases](https://github.com/jchanvfx/NodeGraphQt/releases) page.
+
+
+## Documentation
+
+<a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">https://jchanvfx.github.io/NodeGraphQt</a>
+
+See the [basic_example.py](/examples/basic_example.py) script to get started or check out the API example overview 
+<a href="https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_overview.html#simple-example" target="_blank">here.</a>
+
+## Vertical Layout
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-direction
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/vertical_layout.png" width="800" title="Vertical Layout">
+
+## Pipe Layout
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-styles
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/pipe_layout_types.gif" width="600" title="Pipe Layout">
+
+## Custom Widgets
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/custom_widgets.html
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/prop_bin.png" width="600" title="Properties Bin">
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/nodes_palette.png" width="450" title="Node Palette">
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: NodeGraphQt Version: 0.6.2 Summary: Node graph
+Metadata-Version: 2.1 Name: NodeGraphQt Version: 0.6.3 Summary: Node graph
 framework for PySide2/PyQt5 that can be Home-page: https://github.com/jchanvfx/
 NodeGraphQt Author: Johnny Chan License: MIT License Project-URL:
 Documentation, https://jchanvfx.github.io/NodeGraphQt/api/html/index.html
 Project-URL: Source, https://github.com/jchanvfx/NodeGraphQt/ Project-URL:
 Tracker, https://github.com/jchanvfx/NodeGraphQt/issues Classifier: Operating
 System :: OS Independent Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3.6 Requires-Python: >=3.6
```

### Comparing `NodeGraphQt-0.6.2/README.md` & `NodeGraphQt-0.6.3/README.md`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-
-# NodeGraphQt
-
-<p align="center">
-    <a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">
-    <img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/logo.png" title="logo">
-    </a>
-</p>
-
-NodeGraphQt is a node graph UI framework for `PySide2` that can be implemented and re-purposed into 
-applications.
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/screenshot.png" width="100%" title="NodeGraphQt">
-
-## Install
-
-NodeGraphQt is avaliable on The Python Package Index (PyPI) [here](https://pypi.org/project/NodeGraphQt) so it can be installed with:
-```
-pip install NodeGraphQt
-```
-or you can download previous versions from the [releases](https://github.com/jchanvfx/NodeGraphQt/releases) page.
-
-
-## Documentation
-
-<a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">https://jchanvfx.github.io/NodeGraphQt</a>
-
-See the [basic_example.py](/examples/basic_example.py) script to get started or check out the API example overview 
-<a href="https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_overview.html#simple-example" target="_blank">here.</a>
-
-## Vertical Layout
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-direction
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/vertical_layout.png" width="800" title="Vertical Layout">
-
-## Pipe Layout
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-styles
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/pipe_layout_types.gif" width="600" title="Pipe Layout">
-
-## Custom Widgets
-
-https://jchanvfx.github.io/NodeGraphQt/api/html/custom_widgets.html
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/prop_bin.png" width="600" title="Properties Bin">
-
-<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/nodes_palette.png" width="450" title="Node Palette">
+
+# NodeGraphQt
+
+<p align="center">
+    <a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">
+    <img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/logo.png" title="logo">
+    </a>
+</p>
+
+NodeGraphQt is a node graph UI framework for `PySide2` that can be implemented and re-purposed into 
+applications.
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/screenshot.png" width="100%" title="NodeGraphQt">
+
+## Install
+
+NodeGraphQt is avaliable on The Python Package Index (PyPI) [here](https://pypi.org/project/NodeGraphQt) so it can be installed with:
+```
+pip install NodeGraphQt
+```
+or you can download previous versions from the [releases](https://github.com/jchanvfx/NodeGraphQt/releases) page.
+
+
+## Documentation
+
+<a href="https://jchanvfx.github.io/NodeGraphQt" target="_blank">https://jchanvfx.github.io/NodeGraphQt</a>
+
+See the [basic_example.py](/examples/basic_example.py) script to get started or check out the API example overview 
+<a href="https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_overview.html#simple-example" target="_blank">here.</a>
+
+## Vertical Layout
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-direction
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/vertical_layout.png" width="800" title="Vertical Layout">
+
+## Pipe Layout
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/examples/ex_pipe.html#layout-styles
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/pipe_layout_types.gif" width="600" title="Pipe Layout">
+
+## Custom Widgets
+
+https://jchanvfx.github.io/NodeGraphQt/api/html/custom_widgets.html
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/prop_bin.png" width="600" title="Properties Bin">
+
+<img src="https://raw.githubusercontent.com/jchanvfx/NodeGraphQt/main/docs/_images/nodes_palette.png" width="450" title="Node Palette">
```

### Comparing `NodeGraphQt-0.6.2/examples/nodes/basic_nodes.py` & `NodeGraphQt-0.6.3/examples/nodes/basic_nodes.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,86 +1,86 @@
-from NodeGraphQt import BaseNode, BaseNodeCircle
-
-
-class BasicNodeA(BaseNode):
-    """
-    A node class with 2 inputs and 2 outputs.
-    """
-
-    # unique node identifier.
-    __identifier__ = 'nodes.basic'
-
-    # initial default node name.
-    NODE_NAME = 'node A'
-
-    def __init__(self):
-        super(BasicNodeA, self).__init__()
-
-        # create node inputs.
-        self.add_input('in A')
-        self.add_input('in B')
-
-        # create node outputs.
-        self.add_output('out A')
-        self.add_output('out B')
-
-
-class BasicNodeB(BaseNode):
-    """
-    A node class with 3 inputs and 3 outputs.
-    The last input and last output can take in multiple pipes.
-    """
-
-    # unique node identifier.
-    __identifier__ = 'nodes.basic'
-
-    # initial default node name.
-    NODE_NAME = 'node B'
-
-    def __init__(self):
-        super(BasicNodeB, self).__init__()
-
-        # create node inputs
-        self.add_input('single 1')
-        self.add_input('single 2')
-        self.add_input('multi in', multi_input=True)
-
-        # create node outputs
-        self.add_output('single 1', multi_output=False)
-        self.add_output('single 2', multi_output=False)
-        self.add_output('multi out')
-
-
-class CircleNode(BaseNodeCircle):
-    """
-    A node class with 3 inputs and 3 outputs.
-    This node is a circular design.
-    """
-
-    # unique node identifier.
-    __identifier__ = 'nodes.basic'
-
-    # initial default node name.
-    NODE_NAME = 'Circle Node'
-
-    def __init__(self):
-        super(CircleNode, self).__init__()
-        self.set_color(10, 24, 38)
-
-        # create node inputs
-        p = self.add_input('in 1')
-        p.add_accept_port_type(
-            port_name='single 1',
-            port_type='out',
-            node_type='nodes.basic.BasicNodeB'
-        )
-
-        self.add_input('in 2')
-        self.add_input('in 3', multi_input=True)
-        self.add_input('in 4', display_name=False)
-        self.add_input('in 5', display_name=False)
-
-        # create node outputs
-        self.add_output('out 1')
-        self.add_output('out 2', multi_output=False)
-        self.add_output('out 3', multi_output=True, display_name=False)
-        self.add_output('out 4', multi_output=True, display_name=False)
+from NodeGraphQt import BaseNode, BaseNodeCircle
+
+
+class BasicNodeA(BaseNode):
+    """
+    A node class with 2 inputs and 2 outputs.
+    """
+
+    # unique node identifier.
+    __identifier__ = 'nodes.basic'
+
+    # initial default node name.
+    NODE_NAME = 'node A'
+
+    def __init__(self):
+        super(BasicNodeA, self).__init__()
+
+        # create node inputs.
+        self.add_input('in A')
+        self.add_input('in B')
+
+        # create node outputs.
+        self.add_output('out A')
+        self.add_output('out B')
+
+
+class BasicNodeB(BaseNode):
+    """
+    A node class with 3 inputs and 3 outputs.
+    The last input and last output can take in multiple pipes.
+    """
+
+    # unique node identifier.
+    __identifier__ = 'nodes.basic'
+
+    # initial default node name.
+    NODE_NAME = 'node B'
+
+    def __init__(self):
+        super(BasicNodeB, self).__init__()
+
+        # create node inputs
+        self.add_input('single 1')
+        self.add_input('single 2')
+        self.add_input('multi in', multi_input=True)
+
+        # create node outputs
+        self.add_output('single 1', multi_output=False)
+        self.add_output('single 2', multi_output=False)
+        self.add_output('multi out')
+
+
+class CircleNode(BaseNodeCircle):
+    """
+    A node class with 3 inputs and 3 outputs.
+    This node is a circular design.
+    """
+
+    # unique node identifier.
+    __identifier__ = 'nodes.basic'
+
+    # initial default node name.
+    NODE_NAME = 'Circle Node'
+
+    def __init__(self):
+        super(CircleNode, self).__init__()
+        self.set_color(10, 24, 38)
+
+        # create node inputs
+        p = self.add_input('in 1')
+        p.add_accept_port_type(
+            port_name='single 1',
+            port_type='out',
+            node_type='nodes.basic.BasicNodeB'
+        )
+
+        self.add_input('in 2')
+        self.add_input('in 3', multi_input=True)
+        self.add_input('in 4', display_name=False)
+        self.add_input('in 5', display_name=False)
+
+        # create node outputs
+        self.add_output('out 1')
+        self.add_output('out 2', multi_output=False)
+        self.add_output('out 3', multi_output=True, display_name=False)
+        self.add_output('out 4', multi_output=True, display_name=False)
```

### Comparing `NodeGraphQt-0.6.2/examples/nodes/widget_nodes.py` & `NodeGraphQt-0.6.3/examples/nodes/widget_nodes.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,70 +1,70 @@
-from NodeGraphQt import BaseNode
-
-
-class DropdownMenuNode(BaseNode):
-    """
-    An example node with a embedded added QCombobox menu.
-    """
-
-    # unique node identifier.
-    __identifier__ = 'nodes.widget'
-
-    # initial default node name.
-    NODE_NAME = 'menu'
-
-    def __init__(self):
-        super(DropdownMenuNode, self).__init__()
-
-        # create input & output ports
-        self.add_input('in 1')
-        self.add_output('out 1')
-        self.add_output('out 2')
-
-        # create the QComboBox menu.
-        items = ['item 1', 'item 2', 'item 3']
-        self.add_combo_menu('my_menu', 'Menu Test', items=items)
-
-
-class TextInputNode(BaseNode):
-    """
-    An example of a node with a embedded QLineEdit.
-    """
-
-    # unique node identifier.
-    __identifier__ = 'nodes.widget'
-
-    # initial default node name.
-    NODE_NAME = 'text'
-
-    def __init__(self):
-        super(TextInputNode, self).__init__()
-
-        # create input & output ports
-        self.add_input('in')
-        self.add_output('out')
-
-        # create QLineEdit text input widget.
-        self.add_text_input('my_input', 'Text Input', tab='widgets')
-
-
-class CheckboxNode(BaseNode):
-    """
-    An example of a node with 2 embedded QCheckBox widgets.
-    """
-
-    # set a unique node identifier.
-    __identifier__ = 'nodes.widget'
-
-    # set the initial default node name.
-    NODE_NAME = 'checkbox'
-
-    def __init__(self):
-        super(CheckboxNode, self).__init__()
-
-        # create the checkboxes.
-        self.add_checkbox('cb_1', '', 'Checkbox 1', True)
-        self.add_checkbox('cb_2', '', 'Checkbox 2', False)
-
-        # create input and output port.
-        self.add_input('in', color=(200, 100, 0))
-        self.add_output('out', color=(0, 100, 200))
+from NodeGraphQt import BaseNode
+
+
+class DropdownMenuNode(BaseNode):
+    """
+    An example node with a embedded added QCombobox menu.
+    """
+
+    # unique node identifier.
+    __identifier__ = 'nodes.widget'
+
+    # initial default node name.
+    NODE_NAME = 'menu'
+
+    def __init__(self):
+        super(DropdownMenuNode, self).__init__()
+
+        # create input & output ports
+        self.add_input('in 1')
+        self.add_output('out 1')
+        self.add_output('out 2')
+
+        # create the QComboBox menu.
+        items = ['item 1', 'item 2', 'item 3']
+        self.add_combo_menu('my_menu', 'Menu Test', items=items)
+
+
+class TextInputNode(BaseNode):
+    """
+    An example of a node with a embedded QLineEdit.
+    """
+
+    # unique node identifier.
+    __identifier__ = 'nodes.widget'
+
+    # initial default node name.
+    NODE_NAME = 'text'
+
+    def __init__(self):
+        super(TextInputNode, self).__init__()
+
+        # create input & output ports
+        self.add_input('in')
+        self.add_output('out')
+
+        # create QLineEdit text input widget.
+        self.add_text_input('my_input', 'Text Input', tab='widgets')
+
+
+class CheckboxNode(BaseNode):
+    """
+    An example of a node with 2 embedded QCheckBox widgets.
+    """
+
+    # set a unique node identifier.
+    __identifier__ = 'nodes.widget'
+
+    # set the initial default node name.
+    NODE_NAME = 'checkbox'
+
+    def __init__(self):
+        super(CheckboxNode, self).__init__()
+
+        # create the checkboxes.
+        self.add_checkbox('cb_1', '', 'Checkbox 1', True)
+        self.add_checkbox('cb_2', '', 'Checkbox 2', False)
+
+        # create input and output port.
+        self.add_input('in', color=(200, 100, 0))
+        self.add_output('out', color=(0, 100, 200))
```

