# Comparing `tmp/blackprint_engine-0.8.15-py3-none-any.whl.zip` & `tmp/blackprint_engine-0.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,33 @@
-Zip file size: 41489 bytes, number of entries: 30
--rw-r--r--  2.0 unx    13913 b- defN 23-May-16 04:11 Blackprint/Engine.py
--rw-r--r--  2.0 unx     1426 b- defN 23-May-16 04:11 Blackprint/Environment.py
--rw-r--r--  2.0 unx       70 b- defN 23-May-16 04:11 Blackprint/Event.py
--rw-r--r--  2.0 unx     2012 b- defN 23-May-16 04:11 Blackprint/Interface.py
--rw-r--r--  2.0 unx     2953 b- defN 23-May-16 04:11 Blackprint/Internal.py
--rw-r--r--  2.0 unx     3648 b- defN 23-May-16 04:11 Blackprint/Node.py
--rw-r--r--  2.0 unx     1150 b- defN 23-May-16 04:11 Blackprint/PortGhost.py
--rw-r--r--  2.0 unx     2628 b- defN 23-May-16 04:11 Blackprint/RoutePort.py
--rw-r--r--  2.0 unx      303 b- defN 23-May-16 04:11 Blackprint/Types.py
--rw-r--r--  2.0 unx     2000 b- defN 23-May-16 04:11 Blackprint/Utils.py
--rw-r--r--  2.0 unx      668 b- defN 23-May-16 04:11 Blackprint/__init__.py
--rw-r--r--  2.0 unx     4319 b- defN 23-May-16 04:11 Blackprint/Constructor/Cable.py
--rw-r--r--  2.0 unx     1532 b- defN 23-May-16 04:11 Blackprint/Constructor/CustomEvent.py
--rw-r--r--  2.0 unx     2373 b- defN 23-May-16 04:11 Blackprint/Constructor/InstanceEvent.py
--rw-r--r--  2.0 unx     7781 b- defN 23-May-16 04:11 Blackprint/Constructor/OrderedExecution.py
--rw-r--r--  2.0 unx    13604 b- defN 23-May-16 04:11 Blackprint/Constructor/Port.py
--rw-r--r--  2.0 unx     5799 b- defN 23-May-16 04:11 Blackprint/Constructor/PortLink.py
--rw-r--r--  2.0 unx      208 b- defN 23-May-16 04:11 Blackprint/Constructor/References.py
--rw-r--r--  2.0 unx     5238 b- defN 23-May-16 04:11 Blackprint/Nodes/BPEvent.py
--rw-r--r--  2.0 unx    15461 b- defN 23-May-16 04:11 Blackprint/Nodes/BPFunction.py
--rw-r--r--  2.0 unx     7357 b- defN 23-May-16 04:11 Blackprint/Nodes/BPVariable.py
--rw-r--r--  2.0 unx      188 b- defN 23-May-16 04:11 Blackprint/Nodes/Enums.py
--rw-r--r--  2.0 unx     3280 b- defN 23-May-16 04:11 Blackprint/Nodes/Environments.py
--rw-r--r--  2.0 unx     7665 b- defN 23-May-16 04:11 Blackprint/Nodes/FnPortVar.py
--rw-r--r--  2.0 unx     3335 b- defN 23-May-16 04:11 Blackprint/Port/PortFeature.py
--rw-r--r--  2.0 unx     1067 b- defN 23-May-16 04:11 blackprint_engine-0.8.15.dist-info/LICENSE
--rw-r--r--  2.0 unx     5519 b- defN 23-May-16 04:11 blackprint_engine-0.8.15.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-16 04:11 blackprint_engine-0.8.15.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 23-May-16 04:11 blackprint_engine-0.8.15.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2548 b- defN 23-May-16 04:11 blackprint_engine-0.8.15.dist-info/RECORD
-30 files, 118148 bytes uncompressed, 37389 bytes compressed:  68.4%
+Zip file size: 42182 bytes, number of entries: 31
+-rw-r--r--  2.0 unx    14118 b- defN 23-Jun-23 19:54 Blackprint/Engine.py
+-rw-r--r--  2.0 unx     1426 b- defN 23-Jun-23 19:54 Blackprint/Environment.py
+-rw-r--r--  2.0 unx       70 b- defN 23-Jun-23 19:54 Blackprint/Event.py
+-rw-r--r--  2.0 unx     2012 b- defN 23-Jun-23 19:54 Blackprint/Interface.py
+-rw-r--r--  2.0 unx     3278 b- defN 23-Jun-23 19:54 Blackprint/Internal.py
+-rw-r--r--  2.0 unx     3648 b- defN 23-Jun-23 19:54 Blackprint/Node.py
+-rw-r--r--  2.0 unx     1150 b- defN 23-Jun-23 19:54 Blackprint/PortGhost.py
+-rw-r--r--  2.0 unx     2628 b- defN 23-Jun-23 19:54 Blackprint/RoutePort.py
+-rw-r--r--  2.0 unx      395 b- defN 23-Jun-23 19:54 Blackprint/Types.py
+-rw-r--r--  2.0 unx     1969 b- defN 23-Jun-23 19:54 Blackprint/Utils.py
+-rw-r--r--  2.0 unx      684 b- defN 23-Jun-23 19:54 Blackprint/__init__.py
+-rw-r--r--  2.0 unx     4319 b- defN 23-Jun-23 19:54 Blackprint/Constructor/Cable.py
+-rw-r--r--  2.0 unx     1532 b- defN 23-Jun-23 19:54 Blackprint/Constructor/CustomEvent.py
+-rw-r--r--  2.0 unx     2373 b- defN 23-Jun-23 19:54 Blackprint/Constructor/InstanceEvent.py
+-rw-r--r--  2.0 unx     7781 b- defN 23-Jun-23 19:54 Blackprint/Constructor/OrderedExecution.py
+-rw-r--r--  2.0 unx    13612 b- defN 23-Jun-23 19:54 Blackprint/Constructor/Port.py
+-rw-r--r--  2.0 unx     5770 b- defN 23-Jun-23 19:54 Blackprint/Constructor/PortLink.py
+-rw-r--r--  2.0 unx      208 b- defN 23-Jun-23 19:54 Blackprint/Constructor/References.py
+-rw-r--r--  2.0 unx     5207 b- defN 23-Jun-23 19:54 Blackprint/Nodes/BPEvent.py
+-rw-r--r--  2.0 unx    15582 b- defN 23-Jun-23 19:54 Blackprint/Nodes/BPFunction.py
+-rw-r--r--  2.0 unx     7021 b- defN 23-Jun-23 19:54 Blackprint/Nodes/BPVariable.py
+-rw-r--r--  2.0 unx     1044 b- defN 23-Jun-23 19:54 Blackprint/Nodes/BPVariable_init.py
+-rw-r--r--  2.0 unx      188 b- defN 23-Jun-23 19:54 Blackprint/Nodes/Enums.py
+-rw-r--r--  2.0 unx     3280 b- defN 23-Jun-23 19:54 Blackprint/Nodes/Environments.py
+-rw-r--r--  2.0 unx     7738 b- defN 23-Jun-23 19:54 Blackprint/Nodes/FnPortVar.py
+-rw-r--r--  2.0 unx     3305 b- defN 23-Jun-23 19:54 Blackprint/Port/PortFeature.py
+-rw-r--r--  2.0 unx     1067 b- defN 23-Jun-23 19:54 blackprint_engine-0.9.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     5511 b- defN 23-Jun-23 19:54 blackprint_engine-0.9.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-23 19:54 blackprint_engine-0.9.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 23-Jun-23 19:54 blackprint_engine-0.9.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2635 b- defN 23-Jun-23 19:54 blackprint_engine-0.9.0.dist-info/RECORD
+31 files, 119654 bytes uncompressed, 37946 bytes compressed:  68.3%
```

## zipnote {}

```diff
@@ -57,35 +57,38 @@
 
 Filename: Blackprint/Nodes/BPFunction.py
 Comment: 
 
 Filename: Blackprint/Nodes/BPVariable.py
 Comment: 
 
+Filename: Blackprint/Nodes/BPVariable_init.py
+Comment: 
+
 Filename: Blackprint/Nodes/Enums.py
 Comment: 
 
 Filename: Blackprint/Nodes/Environments.py
 Comment: 
 
 Filename: Blackprint/Nodes/FnPortVar.py
 Comment: 
 
 Filename: Blackprint/Port/PortFeature.py
 Comment: 
 
-Filename: blackprint_engine-0.8.15.dist-info/LICENSE
+Filename: blackprint_engine-0.9.0.dist-info/LICENSE
 Comment: 
 
-Filename: blackprint_engine-0.8.15.dist-info/METADATA
+Filename: blackprint_engine-0.9.0.dist-info/METADATA
 Comment: 
 
-Filename: blackprint_engine-0.8.15.dist-info/WHEEL
+Filename: blackprint_engine-0.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: blackprint_engine-0.8.15.dist-info/top_level.txt
+Filename: blackprint_engine-0.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: blackprint_engine-0.8.15.dist-info/RECORD
+Filename: blackprint_engine-0.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Blackprint/Engine.py

```diff
@@ -304,14 +304,19 @@
 	def settings(this, which, val):
 		if(val == None):
 			return this.settings[which]
 
 		which = which.replace('.', '_')
 		this.settings[which] = val
 
+	def linkVariables(this, vars):
+		for temp in vars:
+			Utils.setDeepProperty(this.variables, temp.id.split('/'), temp)
+			this._emit('variable.new', temp)
+
 	def _getTargetPortType(this, instance, whichPort, targetNodes):
 		target = targetNodes[0] # ToDo: check all target in case if it's supporting Union type
 		targetIface = instance.ifaceList[target['i']]
 
 		if(whichPort == 'input'):
 			return targetIface.input[target['name']]
 		else: return targetIface.output[target['name']]
@@ -415,14 +420,16 @@
 			raise Exception(f"Id can't have space character: '{id}'")
 
 		ids = id.split('/')
 		lastId = ids[len(ids) - 1]
 		parentObj = Utils.getDeepProperty(this.variables, ids, 1)
 
 		if(parentObj != None and lastId in parentObj):
+			if(parentObj[lastId].isShared): return
+      
 			this.variables[id].destroy()
 			del this.variables[id]
 
 		# setDeepProperty
 
 		# BPVariable = ./nodes/Var.js
 		temp = BPVariable(id, options)
```

## Blackprint/Internal.py

```diff
@@ -1,11 +1,12 @@
 import re
 # from .Utils import Utils
 from .Constructor import InstanceEvent
 from .Types import Types
+from .Nodes.BPVariable_init import BPVariable, VarScope
 
 class Internal:
 	nodes = {}
 	interface = {}
 	events = {}
 	# namespace = []
 
@@ -62,14 +63,24 @@
 		# Must be a data type
 		# or type from Blackprint.Port.{Feature}
 		if(not isinstance(obj, type) and obj.feature == None) and not Types.isType(obj):
 			raise Exception(f"Unsupported schema type for field 'key' in '{namespace}'")
 	
 	Internal.events[namespace] = InstanceEvent(options)
 
+def createVariable(namespace, options=[]):
+	if(re.search(r'/\s/', namespace) != None):
+		raise Exception(f"Namespace can't have space character: '{namespace}'")
+
+	temp = BPVariable(namespace, options)
+	temp._scope = VarScope.public
+	temp.isShared = True
+
+	return temp
+
 # Below is for internal only
 class EvError:
 	def __init__(this, type, data):
 		this.type = type
 		this.data = data
 
 class EvIface:
```

## Blackprint/Types.py

```diff
@@ -1,15 +1,18 @@
 class Any: _internal = True
 class Slot: _internal = True
 class Route: _internal = True
+class Trigger: _internal = True
 
 class Types:
 	Any = Any
 	Slot = Slot
 	Route = Route
+	Trigger = Trigger
 
 	@staticmethod
 	def isType(type):
 		if(type == Types.Any): return True
 		if(type == Types.Slot): return True
 		if(type == Types.Route): return True
+		if(type == Types.Trigger): return True
 		return False
```

## Blackprint/Utils.py

```diff
@@ -1,9 +1,8 @@
 import asyncio
-from types import FunctionType
 from .Types import Types
 from .Port.PortFeature import Port
 
 class Utils:
 	NoOperation = lambda: None
 
 	@staticmethod
@@ -41,15 +40,15 @@
 		def_ = None
 		feature = None
 	
 		if(isinstance(val, dict)):
 			feature = val['feature']
 			if(feature == Port.Trigger):
 				def_ = val['func']
-				type = FunctionType
+				type = val['type']
 
 			elif(feature == Port.ArrayOf):
 				type = val['type']
 
 				if(type == Types.Any):
 					def_ = None
 				else: def_ = []
@@ -65,15 +64,15 @@
 			def_ = 0
 		elif(type == bool):
 			def_ = False
 		elif(type == str):
 			def_ = ''
 		elif(type == list):
 			def_ = []
-		# elif(type == FunctionType): 0
+		# elif(type == Types.Trigger): 0
 		# elif(type == Types.Any): 0 # Any
 		# elif(type == Types.Slot): 0
 		# elif(type == Types.Route): 0
 		# elif(feature == None):
 		# 	print(type)
 		# 	raise Exception("Unrecognized port type or port feature", 1)
 		# else{
```

## Blackprint/__init__.py

```diff
@@ -1,15 +1,15 @@
 # for exports
 
 # Import module that don't have circular dependent first
 from .Constructor.CustomEvent import CustomEvent
 from .Environment import Environment
 from .Event import Event
 from .Types import Types
-from .Internal import registerNode, registerInterface, Internal #, registerNamespace
+from .Internal import registerNode, registerInterface, Internal, createVariable #, registerNamespace
 from .Utils import Utils
 
 # Possible circular dependent, we need to specify the import order to avoid partially initialized module
 from .Port.PortFeature import Port
 from .Constructor.Port import Port as _PortClass
 from .RoutePort import RoutePort
 from .Node import Node
```

## Blackprint/Constructor/Port.py

```diff
@@ -151,19 +151,19 @@
 
 					target.iface.input[target.name]._call(cable)
 
 			this.emit('call')
 
 	def createLinker(this):
 		# Callable port
-		if(this.source == 'output' and (this.type == FunctionType or this.type == Types.Route)):
+		if(this.source == 'output' and (this.type == Types.Trigger or this.type == Types.Route)):
 			# Disable sync
 			this._sync = False
 
-			if(this.type != FunctionType):
+			if(this.type != Types.Trigger):
 				this.isRoute = True
 				this.iface.node.routes.disableOut = True
 
 			return lambda: this._callAll()
 
 		# "var prepare = " is in PortLink.php (offsetGet)
 
@@ -301,15 +301,15 @@
 					raise Exception(f"The target port's connection of this port is not instance of type that will be assigned: {portType} is not instance of {clazz}")
 
 		if(isinstance(type_, dict) and 'feature' in type_):
 			if(this.source == 'output'):
 				if(type_['feature'] == PortFeature.Union):
 					type_ = Types.Any
 				elif(type_['feature'] == PortFeature.Trigger):
-					type_ = FunctionType
+					type_ = type_['type']
 				elif(type_['feature'] == PortFeature.ArrayOf):
 					type_ = list
 				elif(type_['feature'] == PortFeature.Default):
 					type_ = type_['type']
 			else:
 				if(type_['type'] == None): raise Exception("Missing type for port feature")
 
@@ -399,16 +399,16 @@
 		   and this.type == FunctionType):
 			if(cableOwner.source == 'output'):
 				isInstance = issubclass(cableOwner.type, this.type)
 			else: isInstance =  issubclass(this.type, cableOwner.type)
 
 		# Remove cable if type restriction
 		if(not isInstance or (
-			   cableOwner.type == FunctionType and this.type != FunctionType
-			or cableOwner.type != FunctionType and this.type == FunctionType
+			   cableOwner.type == Types.Trigger and this.type != Types.Trigger
+			or cableOwner.type != Types.Trigger and this.type == Types.Trigger
 		)):
 			this._cableConnectError('cable.wrong_type_pair', {
 				"cable": cable,
 				"port": this,
 				"target": cableOwner
 			})
 
@@ -452,15 +452,15 @@
 
 		else:
 			# @var Port 
 			inp = cableOwner
 			out = cable.target
 
 		# Remove old cable if the port not support array
-		if(inp.feature != PortFeature.ArrayOf and inp.type != FunctionType):
+		if(inp.feature != PortFeature.ArrayOf and inp.type != Types.Trigger):
 			cables = inp.cables # Cables in input port
 			cableLen = len(cables)
 
 			if(cableLen != 0):
 				temp = cables[0]
 
 				if(temp == cable and cableLen == 1): pass
```

## Blackprint/Constructor/PortLink.py

```diff
@@ -1,10 +1,9 @@
 import re
 
-from types import FunctionType
 from typing import Dict
 
 from ..Internal import EvPortSelf
 from ..Utils import Utils
 from ..Port.PortFeature import Port
 from ..Types import Types
 from .Port import Port as PortClass
@@ -123,15 +122,15 @@
 			portIface._requesting = False
 
 			port._cache = data
 			return data
 		# else: output ports
 
 		# This may get called if the port is lazily assigned with Slot port feature
-		if(port.type == FunctionType):
+		if(port.type == Types.Trigger):
 			if(port._call_ == None):
 				port._call_ = lambda: port._callAll()
 
 			return port._call_
 
 		return port.value
 
@@ -195,15 +194,15 @@
 		if(portName == ''):
 			raise Exception("Port name can't be empty")
 
 		if(this._which == 'output' and (isinstance(val, dict) and 'feature' in val)):
 			if(val['feature'] == Port.Union):
 				val = Types.Any
 			elif(val['feature'] == Port.Trigger):
-				val = FunctionType
+				val = Types.Trigger
 			elif(val['feature'] == Port.ArrayOf):
 				val = list
 			elif(val['feature'] == Port.Default):
 				val = val['type']
 
 		iPort = this._ifacePort
```

## Blackprint/Nodes/BPEvent.py

```diff
@@ -1,9 +1,8 @@
 from ..Types import Types
-from types import FunctionType
 from typing import Dict
 
 from ..Port.PortFeature import Port
 from ..Utils import Utils
 from ..Interface import Interface
 from ..Node import Node
 from ..Environment import Environment
```

## Blackprint/Nodes/BPFunction.py

```diff
@@ -1,19 +1,19 @@
 import re
 
-from types import FunctionType
 from typing import Dict
 
 from ..Port.PortFeature import Port
 from ..Utils import Utils
 from ..Interface import Interface
 from ..Node import Node
 from ..Constructor.CustomEvent import CustomEvent
 from ..Constructor.Port import Port as PortClass
 from .BPVariable import VarScope, BPVariable
+from ..Types import Types
 from .Enums import Enums
 from ..Internal import EvVariableNew, registerNode, registerInterface
 import re
 
 # Don't delete even unused, this is needed for importing the internal node
 from .FnPortVar import PortName, FnVarInput, getFnPortType
 from .BPEvent import BPEventListen
@@ -272,15 +272,15 @@
 
 		if(cable == None): # Triggered by port route
 			IOutput = iface.output
 			thisInput = this.input
 
 			# Sync all port value
 			for key, value in IOutput.items():
-				if(value.type == FunctionType): continue
+				if(value.type == Types.Trigger): continue
 				Output[key] = thisInput[key]
 
 			return
 
 		# Update output value on the input node inside the function node
 		Output[cable.input.name] = cable.value
 
@@ -344,15 +344,15 @@
 
 		if(cable == None): # Triggered by port route
 			IOutput = iface.output
 			thisInput = this.input
 
 			# Sync all port value
 			for key, value in IOutput.items():
-				if(value.type == FunctionType): continue
+				if(value.type == Types.Trigger): continue
 				Output[key] = thisInput[key]
 
 			return
 
 		Output[cable.input.name] = cable.value
 
 @registerInterface('BPIC/BP/Fn/Main')
@@ -375,14 +375,16 @@
 
 		this._importOnce = True
 		node = this.node
 
 		# ToDo: will this be slower if we lazy import the module like below?
 		from ..Engine import Engine
 		this.bpInstance = Engine()
+		if(this.data != None and ('pause' in this.data)):
+			this.bpInstance.executionOrder.pause = True
 
 		bpFunction = node._funcInstance
 
 		newInstance = this.bpInstance
 		newInstance.variables = {} # _for one function
 		newInstance.sharedVariables = bpFunction.variables # shared between function
 		newInstance.functions = node.instance.functions
@@ -417,14 +419,15 @@
 				bpFunction._onFuncChanges(eventName, ev, this.node)
 			finally:
 				bpFunction._syncing = False
 
 		this._save = _save
 		this.bpInstance.on('cable.connect cable.disconnect node.created node.delete node.id.changed port.default.changed _port.split _port.unsplit _port.resync.allow _port.resync.disallow', this._save)
 
+	def imported(this, data): this.data = data
 	def renamePort(this, which, fromName, toName):
 		this.node._funcInstance.renamePort(which, fromName, toName)
 		this._save(False, False, True)
 
 		# this.node.instance._emit('_fn.rename.port', {
 		# 	iface: this,
 		# 	which,
@@ -457,35 +460,35 @@
 					name += inc
 					break
 
 			nodeA = this._funcMain.node
 			nodeB = this.node
 			refName = PortName(name)
 
-			portType = getFnPortType(port, 'input', this._funcMain, refName)
+			portType = getFnPortType(port, 'input', this, refName)
 			nodeA._funcInstance.input[name] = portType
 
 		else: # Output (input) . Main (output)
 			inc = 1
 			while(name in this.input):
 				if((name + inc) in this.input): inc += 1
 				else:
 					name += inc
 					break
 
 			nodeA = this.node
 			nodeB = this._funcMain.node
 			refName = PortName(name)
 
-			portType = getFnPortType(port, 'output', this._funcMain, refName)
+			portType = getFnPortType(port, 'output', this, refName)
 			nodeB._funcInstance.output[name] = portType
 
 		outputPort = nodeB.createPort('output', name, portType)
 
-		if(portType == FunctionType):
+		if(portType == Types.Trigger):
 			inputPort = nodeA.createPort('input', name, Port.Trigger(lambda port: outputPort._callAll()))
 		else: inputPort = nodeA.createPort('input', name, portType)
 
 		if(this.type == 'bp-fn-input'):
 			outputPort._name = refName # When renaming port, this also need to be changed
 			this.emit(f"_add.{name}", outputPort)
 			return outputPort
```

## Blackprint/Nodes/BPVariable.py

```diff
@@ -1,28 +1,20 @@
-from types import FunctionType
 from ..Node import Node
 from ..Interface import Interface
 from ..Nodes.Enums import Enums
-from ..Constructor.CustomEvent import CustomEvent
 from ..Constructor.Port import Port as PortClass
 from ..Utils import Utils
 from ..Internal import registerNode, registerInterface
 from ..Types import Types
 from ..Port.PortFeature import Port
-import re
+from .BPVariable_init import BPVariable, VarScope
 
 # Don't delete even unused, this is needed for importing the internal node
 from .Environments import BPEnvGet
 
-# For internal library use only
-class VarScope:
-	public = 0
-	private = 1
-	shared = 2
-
 @registerNode('BP/Var/Set')
 class VarSet(Node):
 	input = {}
 	iface: 'IVarSet' = None
 	def __init__(this, instance):
 		Node.__init__(this, instance)
 		iface = this.setInterface('BPIC/BP/Var/Set')
@@ -58,54 +50,14 @@
 
 		iface.title = 'VarGet'
 		iface.type = 'bp-var-get'
 		iface._enum = Enums.BPVarGet
 
 	def destroy(this): this.iface.destroyIface()
 
-# used for instance.createVariable
-class BPVariable(CustomEvent):
-	type = None
-	# this.totalSet = 0
-	# this.totalGet = 0
-
-	def __init__(this, id, options={}):
-		CustomEvent.__init__(this)
-
-		id = re.sub(r'/^\/|\/$/m', '', id)
-		id = re.sub(r'/[`~!@#$%^&*()\-_+={}\[\]:"|;\'\\\\,.<>?]+/', '_', id)
-		this.id = id
-		this.title = options['title'] if 'title' in options else id
-
-		# this.rootInstance = instance
-		this.id = this.title = id
-		this.type = Types.Slot
-		this._value = None
-		this.used = []
-
-		# The type need to be defined dynamically on first cable connect
-
-	@property
-	def value(this):
-		return this._value
-
-	@value.setter
-	def value(this, val):
-		if(this._value == val): return
-
-		this._value = val
-		this.emit('value')
-
-	def destroy(this):
-		map = this.used
-		for iface in map:
-			iface.node.instance.deleteNode(iface)
-
-		map.clear()
-
 class BPVarGetSet(Interface):
 	_onChanged = None
 	_dynamicPort = True # Port is initialized dynamically
 
 	def imported(this, data):
 		if(('scope' not in data) or ('name' not in data)):
 			raise Exception("'scope' and 'name' options is required for creating variable node")
@@ -154,41 +106,60 @@
 		temp = this._bpVarRef
 		if(temp.type != Types.Slot):
 			if(port == None): temp.type = Types.Slot
 			return
 
 		if(port == None): raise Exception("Can't set type with None")
 		temp.type = port._config if port._config != None else port.type
+		if(isinstance(temp, dict) and temp.type['feature'] == Port.Trigger):
+			temp.type = Types.Trigger
 
 		if(port.type == Types.Slot):
 			this.waitTypeChange(temp, port)
-		else: temp.emit('type.assigned')
+		else:
+			this._recheckRoute()
+			temp.emit('type.assigned')
 
 		# Also create port for other node that using this variable
 		used = temp.used
 		for item in used:
 			item._reinitPort()
 
 	def waitTypeChange(this, bpVar, port=None):
 		def callback():
 			if(port != None):
 				bpVar.type = port._config if port._config != None else port.type
+				if(isinstance(bpVar, dict) and bpVar.type['feature'] == Port.Trigger):
+					bpVar.type = Types.Trigger
+
 				bpVar.emit('type.assigned')
 			else:
 				if this.input['Val'] != None:
 					target = this.input['Val']
 				else: target = this.output['Val']
 				target.assignType(bpVar.type)
 
+			this._recheckRoute()
+
 		this._waitTypeChange = callback
 		this._destroyWaitType = lambda: bpVar.off('type.assigned', this._waitTypeChange)
 
 		iPort = port if port != None else bpVar
 		iPort.once('type.assigned', this._waitTypeChange)
 
+	def _recheckRoute(this):
+		if(
+			(hasattr(this, 'input') and ('Val' in this.input) and this.input['Val'].type == Types.Trigger)
+     		or
+			(hasattr(this, 'output') and ('Val' in this.output) and this.output['Val'].type == Types.Trigger)
+		):
+			routes = this.node.routes
+			routes.disableOut = True
+			routes.noUpdate = True
+
 	def destroyIface(this):
 		temp = this._destroyWaitType
 		if(temp != None):
 			this._destroyWaitType()
 
 		temp = this._bpVarRef
 		if(temp == None): return
@@ -216,38 +187,39 @@
 		varRef = BPVarGetSet.changeVar(this, name, scopeId)
 		this.title = name.replace('/', ' / ')
 
 		this._bpVarRef = varRef
 		if(varRef.type == Types.Slot): return
 
 		this._reinitPort()
+		this._recheckRoute()
 
 	def _reinitPort(this):
 		temp = this._bpVarRef
 		node = this.node
 
 		if(temp.type == Types.Slot):
 			this.waitTypeChange(temp)
 
 		if('Val' in this.output):
 			node.deletePort('output', 'Val')
 
 		ref = node.output
 		node.createPort('output', 'Val', temp.type)
 
-		if(temp.type == FunctionType):
+		if(temp.type == Types.Trigger):
 			this._eventListen = 'call'
 			def callback(ev): ref['Val']()
 			this._onChanged = callback
 		else:
 			this._eventListen = 'value'
 			def callback(ev): ref['Val'] = temp._value
 			this._onChanged = callback
 
-		if(temp.type != FunctionType):
+		if(temp.type != Types.Trigger):
 			node.output['Val'] = temp._value
 
 		temp.on(this._eventListen, this._onChanged)
 		return this.output['Val']
 
 	def destroyIface(this):
 		if(this._eventListen != None):
@@ -261,25 +233,26 @@
 		varRef = BPVarGetSet.changeVar(this, name, scopeId)
 		this.title = name.replace('/', ' / ')
 
 		this._bpVarRef = varRef
 		if(varRef.type == Types.Slot): return
 
 		this._reinitPort()
+		this._recheckRoute()
 
 	def _reinitPort(this):
 		input = this.input
 		node = this.node
 		temp = this._bpVarRef
 
 		if(temp.type == Types.Slot):
 			this.waitTypeChange(temp)
 
 		if('Val' in input):
 			node.deletePort('input', 'Val')
 
-		if(temp.type == FunctionType):
+		if(temp.type == Types.Trigger):
 			node.createPort('input', 'Val', Port.Trigger(lambda port: temp.emit('call')))
 
 		else: node.createPort('input', 'Val', temp.type)
 
 		return input['Val']
```

## Blackprint/Nodes/FnPortVar.py

```diff
@@ -1,8 +1,7 @@
-from types import FunctionType
 from ..Port.PortFeature import Port
 from ..Types import Types
 from ..Node import Node
 from ..Interface import Interface
 from ..Nodes.Enums import Enums
 from ..Internal import registerNode, registerInterface
 
@@ -116,15 +115,15 @@
 				if(port.feature == Port.ArrayOf): return
 
 				iPort.onConnect = None
 				proxyIface.off(f"_add.{name}", this._waitPortInit)
 				this._waitPortInit = None
 
 				portName = PortName(name)
-				portType = getFnPortType(port, 'input', this._funcMain, portName)
+				portType = getFnPortType(port, 'input', this, portName)
 				iPort.assignType(portType)
 				iPort._name = portName
 
 				proxyIface.addPort(port, name)
 				tPort = port if cable.owner == iPort else iPort
 				tPort.connectCable(cable)
 
@@ -137,35 +136,35 @@
 			def _waitPortInit(port):
 				# Skip port with feature: ArrayOf
 				if(port.feature == Port.ArrayOf): return
 
 				iPort.onConnect = None
 				this._waitPortInit = None
 
-				portType = getFnPortType(port, 'input', this._funcMain, port._name)
+				portType = getFnPortType(port, 'input', this, port._name)
 				iPort.assignType(portType)
 				this._addListener()
 
 			this._waitPortInit = _waitPortInit
 
 			proxyIface.once(f"_add.{name}", this._waitPortInit)
 
 		else:
 			if('Val' not in this.output):
 				port = this._funcMain._proxyInput.iface.output[name]
-				portType = getFnPortType(port, 'input', this._funcMain, port._name)
+				portType = getFnPortType(port, 'input', this, port._name)
 				newPort = node.createPort('output', 'Val', portType)
 				newPort._name = port._name
 
 			this._addListener()
 
 	def _addListener(this):
 		port = this._proxyIface.output[this.data['name']]
 
-		if(port.type == FunctionType):
+		if(port.type == Types.Trigger):
 			def _listener(ev):
 				this.ref.Output['Val']()
 
 			this._listener = _listener
 			port.on('call', _listener)
 
 		else:
@@ -217,15 +216,15 @@
 				if(port.feature == Port.ArrayOf): return
 
 				iPort.onConnect = None
 				proxyIface.off(f"_add.{name}", this._waitPortInit)
 				this._waitPortInit = None
 
 				portName = PortName(name)
-				portType = getFnPortType(port, 'output', this._funcMain, portName)
+				portType = getFnPortType(port, 'output', this, portName)
 				iPort.assignType(portType)
 				iPort._name = portName
 
 				proxyIface.addPort(port, name)
 				tPort = port if cable.owner == iPort else iPort
 				tPort.connectCable(cable)
 				return True
@@ -236,35 +235,43 @@
 			def _waitPortInit(port):
 				# Skip port with feature: ArrayOf
 				if(port.feature == Port.ArrayOf): return
 
 				iPort.onConnect = None
 				this._waitPortInit = None
 
-				portType = getFnPortType(port, 'output', this._funcMain, port._name)
+				portType = getFnPortType(port, 'output', this, port._name)
 				iPort.assignType(portType)
 
 			this._waitPortInit = _waitPortInit
 			proxyIface.once(f"_add.{name}", this._waitPortInit)
 
 		else:
 			port = this._funcMain._proxyOutput.iface.input[name]
-			portType = getFnPortType(port, 'output', this._funcMain, port._name)
+			portType = getFnPortType(port, 'output', this, port._name)
 			newPort = node.createPort('input', 'Val', portType)
 			newPort._name = port._name
 
+	def _recheckRoute(this):
+		if(this.input.Val.type != Types.Trigger): return
+
+		routes = this.node.routes
+		routes.disableOut = True
+		routes.noUpdate = True
+
 def _Dummy_PortTrigger_():
 	raise Exception("This can't be called")
 
 _Dummy_PortTrigger = Port.Trigger(_Dummy_PortTrigger_)
 
 def getFnPortType(port, which, parentNode, ref):
-	if(port.feature == Port.Trigger or port.type == FunctionType):
-		if(which == 'input'): # Function Input (has output port inside, and input port on main node):
-			return FunctionType
+	if(port.feature == Port.Trigger or port.type == Types.Trigger):
+		# Function Input (has output port inside, and input port on main node):
+		if(which == 'input'):
+			return Types.Trigger
 		else: return _Dummy_PortTrigger
 	# Skip ArrayOf port feature, and just use the type
 	elif(port.feature == Port.ArrayOf):
 		return port.type
 	elif(port._isSlot):
 		raise Exception("Function node's input/output can't use port from an lazily assigned port type (Types.Slot)")
 	else: return port._config
```

## Blackprint/Port/PortFeature.py

```diff
@@ -1,9 +1,8 @@
 from ..Types import Types
-from types import FunctionType
 
 class Port:
 	# This port can contain multiple cable as input
 	# and the value will be array of 'type'
 	# it's only one type, not union
 	# for union port, please split it to different port to handle it
 
@@ -40,15 +39,15 @@
 	# func = callback when the port was being called as a function
 	 
 	@staticmethod
 	def Trigger(func):
 		if func == None: raise Exception("Callback must not be None")
 		return {
 			'feature': Port.Trigger,
-			'type': FunctionType,
+			'type': Types.Trigger,
 			'func': func
 		}
 
 	# This port can allow multiple different types
 	# like an 'any' port, but can only contain one value
 	# 
 	# Note:
```

## Comparing `blackprint_engine-0.8.15.dist-info/LICENSE` & `blackprint_engine-0.9.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `blackprint_engine-0.8.15.dist-info/METADATA` & `blackprint_engine-0.9.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: blackprint-engine
-Version: 0.8.15
+Version: 0.9.0
 Summary: Blackprint engine for registering node/interface and run exported Blackprint on Python environment
 Home-page: https://github.com/Blackprint/engine-python
 License: LICENSE
 Project-URL: Homepage, https://github.com/Blackprint/engine-python
 Project-URL: Bug Tracker, https://github.com/Blackprint/engine-python/issues
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
@@ -46,22 +46,21 @@
 import BPNode # Import your own nodes located on ./BPNode directory
 ```
 
 #### Defining custom node
 
 ```python
 # file: ./BPNode/Example/Hello.py
-import types
 
 @Blackprint.registerNode('Example/Hello')
 class Hello(Blackprint.Node):
     # Please remember to capitalize the port name
     # Set the output port structure for your node (Optional)
     output = {
-        'Changed': types.FunctionType,
+        'Changed': Blackprint.Types.Trigger,
         # this.output['Changed']() -- To call every connected port
 
         'Output': int,
         # this.output['Output'] = 246 -- To assign value to output port
     }
 
     # Set the input port structure for your node (Optional)
```

## Comparing `blackprint_engine-0.8.15.dist-info/RECORD` & `blackprint_engine-0.9.0.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,30 +1,31 @@
-Blackprint/Engine.py,sha256=xspp21Sen76CUtpcgubbBn19dvNTGbIN6jkkPvrvYUc,13913
+Blackprint/Engine.py,sha256=dKHxAIazSRhkYLPG1VeMuJsq0j2yqoQYDTwlIjlUOV0,14118
 Blackprint/Environment.py,sha256=vdQcpgC9pbHzngP8v2vcN0CY5nYZwfI_XgwVYyrepPs,1426
 Blackprint/Event.py,sha256=7PyaaWq0K7Gb7teYvhrY4wF0EwO1Q29l7MXELDkALiE,70
 Blackprint/Interface.py,sha256=7cWk7Xdiv9m2YJGJx0iWYj34p7PyQXfvFYQa5cP521M,2012
-Blackprint/Internal.py,sha256=SndVuy7w3RGEp4t7WnqkHE4DDOcYSiTc_06F8TN3wVw,2953
+Blackprint/Internal.py,sha256=bgKqy4j7QMS4u43ppscDfXLLKiM_p3HzIst6fKqZa0E,3278
 Blackprint/Node.py,sha256=a-HAWx2fD0dCTXI8LmXDT8fFzaH-LZoI7pzc2-WGVO8,3648
 Blackprint/PortGhost.py,sha256=dXKnwBCGCLs81YHXoxVXe1bcep9OdZJ13uKbAHdylEE,1150
 Blackprint/RoutePort.py,sha256=2pYDXBKvjzLcQUj8eIp3eSj705TUhdfAjk2IYS-Pubw,2628
-Blackprint/Types.py,sha256=Y4hoJLKc3rr9s8BbgpG5yUrcFQssxDOixwuuN03Mzfc,303
-Blackprint/Utils.py,sha256=-LpKw9NUX9MJKze4QddQAI6LVxmfg0FVpszgA6R3QSQ,2000
-Blackprint/__init__.py,sha256=Yk5VtvLzrdj2RezQZKixrPp94s5Wm3LCQJ8lqORRf-4,668
+Blackprint/Types.py,sha256=EeXICSyQm1AQwhvKGpu2bYGQdNbRweXk4J5Bl7g_Cqg,395
+Blackprint/Utils.py,sha256=8ZK43pS4e88JvpIg6BdaJhyq9ojni27Xn68G620-M7Y,1969
+Blackprint/__init__.py,sha256=uwaxxHTh2Pqsev12_nrKsfzJC-i0-_msDQbFG3GxT_A,684
 Blackprint/Constructor/Cable.py,sha256=VM4bu84bsKHhypsEExK8M1h4CoG8IG8UHk9MhWo9wio,4319
 Blackprint/Constructor/CustomEvent.py,sha256=ujHoT2urmo_1vgVjPUPcfq75OMigCjjHtwHoHqVdUV0,1532
 Blackprint/Constructor/InstanceEvent.py,sha256=NGtOyO9ARr6DXH0PHw-3tISZP-hFDep06sRmYy2mCmg,2373
 Blackprint/Constructor/OrderedExecution.py,sha256=2lkGs_4rG93dq1_M8P8wQr4fYt1xzd358dloweKYk2c,7781
-Blackprint/Constructor/Port.py,sha256=CVJkEV0N631uEsW4ZU8AsyeA8eeit08A6H8rd3n3zUA,13604
-Blackprint/Constructor/PortLink.py,sha256=98Hg0y6twyLRpGIZJ95OK2U6A7GfKXP4aRVvn3WGmgg,5799
+Blackprint/Constructor/Port.py,sha256=p1zJ7UfOk-htlx1lPJT0EotV-0K6GbOS6tBdVj29eEE,13612
+Blackprint/Constructor/PortLink.py,sha256=SaJzhpeFLd7mYXZF4CEDpzsOJhj1y_k1VB6k0DYSHKY,5770
 Blackprint/Constructor/References.py,sha256=9THcOFY3WSKDSCkdnoKwWF0tm5JoD-d2mK6FiXniYfU,208
-Blackprint/Nodes/BPEvent.py,sha256=1GYS9kKcALFsqZOj2UIS7XM3TFZijunZwlrsWW8ZR-E,5238
-Blackprint/Nodes/BPFunction.py,sha256=KbHTBKHaCMPnffHsOMlLdQSXgQhbhLuSV8FUCFwtZqY,15461
-Blackprint/Nodes/BPVariable.py,sha256=ekmtX7icwkGLeZ39HV52378JRbdmpp6hBi_p35XcGC0,7357
+Blackprint/Nodes/BPEvent.py,sha256=mXPhrO-75m-ZZ2DYoJDmRY4irBXeDsg5jBWDLAMbQjA,5207
+Blackprint/Nodes/BPFunction.py,sha256=bEUVLRsxqVm5CvOUiORPui9CvBsbML2apazZluwRix0,15582
+Blackprint/Nodes/BPVariable.py,sha256=Fw0qITwbISkBj4RS8wv0bAcgA54uGtUdy13XZiracBg,7021
+Blackprint/Nodes/BPVariable_init.py,sha256=5Xhi3L-qahJp2gTEeW1cAlmxg9WSHJDMLTifQOkWnYE,1044
 Blackprint/Nodes/Enums.py,sha256=1_Esph9ii8XrMrF4382zfMiNB9SpPFYi6_QoTSWUtVg,188
 Blackprint/Nodes/Environments.py,sha256=5CDgVZhR2NOv0193xEhHyfzpWDS1XaGiw3V3ZzIyY5I,3280
-Blackprint/Nodes/FnPortVar.py,sha256=qzG1MmVmOd8vCmjN7IzQh1vo3Xviag96O70737tmWZo,7665
-Blackprint/Port/PortFeature.py,sha256=8ON_qZitsMtQDGdsTgy7OzwcqbpHpqoz-IM6T5fx37g,3335
-blackprint_engine-0.8.15.dist-info/LICENSE,sha256=lKI8UOOFjqSgg2fve8qJlFVvJqq9HzvT0Z_ICAeCFUQ,1067
-blackprint_engine-0.8.15.dist-info/METADATA,sha256=vaLSbDJI_CXEPbLSY5ivdNeQlcfJ_Z6-zwQ6Flt2A0U,5519
-blackprint_engine-0.8.15.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-blackprint_engine-0.8.15.dist-info/top_level.txt,sha256=pBgP0MZ8xy9sRmyPQ2tdkdvWQh6laD1yAVwgX6tCSBI,11
-blackprint_engine-0.8.15.dist-info/RECORD,,
+Blackprint/Nodes/FnPortVar.py,sha256=EgN8a04-VVVgTdfucPVRN2Gc1HkTgElig53v5hwGn3g,7738
+Blackprint/Port/PortFeature.py,sha256=zhTaoUNvPDFT0GtyJRNia0lJ0vpktf3kWpEGKYPixto,3305
+blackprint_engine-0.9.0.dist-info/LICENSE,sha256=lKI8UOOFjqSgg2fve8qJlFVvJqq9HzvT0Z_ICAeCFUQ,1067
+blackprint_engine-0.9.0.dist-info/METADATA,sha256=gXbXegwrcA9gl1u04jSFfqVfO34jws_w8xmQLLCcCq8,5511
+blackprint_engine-0.9.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+blackprint_engine-0.9.0.dist-info/top_level.txt,sha256=pBgP0MZ8xy9sRmyPQ2tdkdvWQh6laD1yAVwgX6tCSBI,11
+blackprint_engine-0.9.0.dist-info/RECORD,,
```

