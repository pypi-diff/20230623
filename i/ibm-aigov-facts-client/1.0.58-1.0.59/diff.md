# Comparing `tmp/ibm_aigov_facts_client-1.0.58-py3-none-any.whl.zip` & `tmp/ibm_aigov_facts_client-1.0.59-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,77 +1,80 @@
-Zip file size: 154294 bytes, number of entries: 75
--rw-r--r--  2.0 unx     1346 b- defN 23-May-27 10:23 ibm_aigov_facts_client/__init__.py
--rw-r--r--  2.0 unx      633 b- defN 23-May-27 10:23 ibm_aigov_facts_client/version.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-27 10:23 ibm_aigov_facts_client/_wrappers/__init__.py
--rw-r--r--  2.0 unx     4784 b- defN 23-May-27 10:23 ibm_aigov_facts_client/_wrappers/requests.py
--rw-r--r--  2.0 unx      611 b- defN 23-May-27 10:23 ibm_aigov_facts_client/base_classes/__init__.py
--rw-r--r--  2.0 unx     9290 b- defN 23-May-27 10:23 ibm_aigov_facts_client/base_classes/auth.py
--rw-r--r--  2.0 unx     1328 b- defN 23-May-27 10:23 ibm_aigov_facts_client/base_classes/common.py
--rw-r--r--  2.0 unx      776 b- defN 23-May-27 10:23 ibm_aigov_facts_client/client/__init__.py
--rw-r--r--  2.0 unx     3385 b- defN 23-May-27 10:23 ibm_aigov_facts_client/client/autolog.py
--rw-r--r--  2.0 unx    21931 b- defN 23-May-27 10:26 ibm_aigov_facts_client/client/fact_trace.py
--rw-r--r--  2.0 unx     8641 b- defN 23-May-27 10:23 ibm_aigov_facts_client/client/manual_log.py
--rw-r--r--  2.0 unx      687 b- defN 23-May-27 10:23 ibm_aigov_facts_client/custom/__init__.py
--rw-r--r--  2.0 unx     3437 b- defN 23-May-27 10:23 ibm_aigov_facts_client/custom/custom_exp.py
--rw-r--r--  2.0 unx    10081 b- defN 23-May-27 10:23 ibm_aigov_facts_client/custom/custom_file_store.py
--rw-r--r--  2.0 unx      606 b- defN 23-May-27 10:23 ibm_aigov_facts_client/export/__init__.py
--rw-r--r--  2.0 unx    10861 b- defN 23-May-27 10:23 ibm_aigov_facts_client/export/export_facts.py
--rw-r--r--  2.0 unx     6155 b- defN 23-May-27 10:23 ibm_aigov_facts_client/export/export_facts_manual.py
--rw-r--r--  2.0 unx      611 b- defN 23-May-27 10:23 ibm_aigov_facts_client/factsheet/__init__.py
--rw-r--r--  2.0 unx     7516 b- defN 23-May-27 10:23 ibm_aigov_facts_client/factsheet/asset_utils_experiments.py
--rw-r--r--  2.0 unx    55454 b- defN 23-May-27 10:23 ibm_aigov_facts_client/factsheet/asset_utils_me.py
--rw-r--r--  2.0 unx   109357 b- defN 23-May-27 10:23 ibm_aigov_facts_client/factsheet/asset_utils_model.py
--rw-r--r--  2.0 unx    40742 b- defN 23-May-27 10:23 ibm_aigov_facts_client/factsheet/asset_utils_runs.py
--rw-r--r--  2.0 unx    31959 b- defN 23-May-27 10:23 ibm_aigov_facts_client/factsheet/assets.py
--rw-r--r--  2.0 unx    23474 b- defN 23-May-27 10:23 ibm_aigov_facts_client/factsheet/external_modelfacts_utility.py
--rw-r--r--  2.0 unx    27316 b- defN 23-May-27 10:23 ibm_aigov_facts_client/factsheet/factsheet_utility.py
--rw-r--r--  2.0 unx      716 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/__init__.py
--rw-r--r--  2.0 unx      956 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/abstract_payload_manual.py
--rw-r--r--  2.0 unx      946 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/abstract_payload_store.py
--rw-r--r--  2.0 unx      611 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/__init__.py
--rw-r--r--  2.0 unx     3419 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/autolog_utils.py
--rw-r--r--  2.0 unx     4151 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/bst_payload_store.py
--rw-r--r--  2.0 unx     4396 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/bst_payload_store_custom.py
--rw-r--r--  2.0 unx     4517 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/bst_payload_store_custom_lgbm.py
--rw-r--r--  2.0 unx      748 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/decorators.py
--rw-r--r--  2.0 unx     4292 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/dl_payload_store.py
--rw-r--r--  2.0 unx     4440 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/dl_payload_store_custom.py
--rw-r--r--  2.0 unx     2633 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/general_payload_store.py
--rw-r--r--  2.0 unx     3049 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/autolog/spark_payload_store.py
--rw-r--r--  2.0 unx      611 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/manual/__init__.py
--rw-r--r--  2.0 unx     7385 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/manual/bst_payload_manual.py
--rw-r--r--  2.0 unx     7402 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/manual/dl_payload_manual.py
--rw-r--r--  2.0 unx     4965 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/manual/general_payload_manual.py
--rw-r--r--  2.0 unx     4774 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/manual/manuallog_utils.py
--rw-r--r--  2.0 unx     4461 b- defN 23-May-27 10:23 ibm_aigov_facts_client/store/manual/spark_payload_manual.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-27 10:23 ibm_aigov_facts_client/supporting_classes/__init__.py
--rw-r--r--  2.0 unx     3483 b- defN 23-May-27 10:23 ibm_aigov_facts_client/supporting_classes/cp4d_authenticator.py
--rw-r--r--  2.0 unx     5359 b- defN 23-May-27 10:23 ibm_aigov_facts_client/supporting_classes/cp4d_token_manager.py
--rw-r--r--  2.0 unx    14856 b- defN 23-May-27 10:23 ibm_aigov_facts_client/supporting_classes/factsheet_utils.py
--rw-r--r--  2.0 unx      800 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/__init__.py
--rw-r--r--  2.0 unx     4428 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/cell_facts.py
--rw-r--r--  2.0 unx     3159 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/client_errors.py
--rw-r--r--  2.0 unx     4858 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/client_utils.py
--rw-r--r--  2.0 unx     1598 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/config.py
--rw-r--r--  2.0 unx     3956 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/constants.py
--rw-r--r--  2.0 unx     4548 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/cp4d_utils.py
--rw-r--r--  2.0 unx     3920 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/doc_annotations.py
--rw-r--r--  2.0 unx     3979 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/enums.py
--rw-r--r--  2.0 unx     5255 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/logging_utils.py
--rw-r--r--  2.0 unx     9152 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/manual_store_utils.py
--rw-r--r--  2.0 unx     6318 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/me_containers_meta.py
--rw-r--r--  2.0 unx     2095 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/metrics_utils.py
--rw-r--r--  2.0 unx     9254 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/store_utils.py
--rw-r--r--  2.0 unx    15176 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/support_scope_meta.py
--rw-r--r--  2.0 unx    17106 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/utils.py
--rw-r--r--  2.0 unx     7131 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/validation.py
--rw-r--r--  2.0 unx      611 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/experiments/__init__.py
--rw-r--r--  2.0 unx     7945 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/experiments/experiments_utils.py
--rw-r--r--  2.0 unx      612 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/runs/__init__.py
--rw-r--r--  2.0 unx    20668 b- defN 23-May-27 10:23 ibm_aigov_facts_client/utils/runs/runs_utils.py
--rw-r--r--  2.0 unx    10173 b- defN 23-May-27 10:28 ibm_aigov_facts_client-1.0.58.dist-info/LICENSE
--rw-r--r--  2.0 unx     1001 b- defN 23-May-27 10:28 ibm_aigov_facts_client-1.0.58.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-27 10:28 ibm_aigov_facts_client-1.0.58.dist-info/WHEEL
--rw-r--r--  2.0 unx       94 b- defN 23-May-27 10:28 ibm_aigov_facts_client-1.0.58.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       23 b- defN 23-May-27 10:28 ibm_aigov_facts_client-1.0.58.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     7894 b- defN 23-May-27 10:28 ibm_aigov_facts_client-1.0.58.dist-info/RECORD
-75 files, 620997 bytes uncompressed, 141202 bytes compressed:  77.3%
+Zip file size: 171128 bytes, number of entries: 78
+-rw-r--r--  2.0 unx     1346 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/__init__.py
+-rw-r--r--  2.0 unx      633 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/version.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/_wrappers/__init__.py
+-rw-r--r--  2.0 unx     4784 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/_wrappers/requests.py
+-rw-r--r--  2.0 unx      611 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/base_classes/__init__.py
+-rw-r--r--  2.0 unx     9290 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/base_classes/auth.py
+-rw-r--r--  2.0 unx     1328 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/base_classes/common.py
+-rw-r--r--  2.0 unx      776 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/client/__init__.py
+-rw-r--r--  2.0 unx     3385 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/client/autolog.py
+-rw-r--r--  2.0 unx    22372 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/client/fact_trace.py
+-rw-r--r--  2.0 unx     8641 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/client/manual_log.py
+-rw-r--r--  2.0 unx      687 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/custom/__init__.py
+-rw-r--r--  2.0 unx     3437 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/custom/custom_exp.py
+-rw-r--r--  2.0 unx    10081 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/custom/custom_file_store.py
+-rw-r--r--  2.0 unx      606 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/export/__init__.py
+-rw-r--r--  2.0 unx    10861 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/export/export_facts.py
+-rw-r--r--  2.0 unx     6155 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/export/export_facts_manual.py
+-rw-r--r--  2.0 unx      611 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/__init__.py
+-rw-r--r--  2.0 unx    16485 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/approaches.py
+-rw-r--r--  2.0 unx     7516 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/asset_utils_experiments.py
+-rw-r--r--  2.0 unx    81044 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/asset_utils_me.py
+-rw-r--r--  2.0 unx   130668 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/asset_utils_model.py
+-rw-r--r--  2.0 unx    40744 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/asset_utils_runs.py
+-rw-r--r--  2.0 unx    39307 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/assets.py
+-rw-r--r--  2.0 unx    21548 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/external_deployments.py
+-rw-r--r--  2.0 unx    27706 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/external_modelfacts_utility.py
+-rw-r--r--  2.0 unx    27316 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/factsheet_utility.py
+-rw-r--r--  2.0 unx      250 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/factsheet/html_parser.py
+-rw-r--r--  2.0 unx      716 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/__init__.py
+-rw-r--r--  2.0 unx      956 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/abstract_payload_manual.py
+-rw-r--r--  2.0 unx      946 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/abstract_payload_store.py
+-rw-r--r--  2.0 unx      611 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/__init__.py
+-rw-r--r--  2.0 unx     3419 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/autolog_utils.py
+-rw-r--r--  2.0 unx     4151 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/bst_payload_store.py
+-rw-r--r--  2.0 unx     4396 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/bst_payload_store_custom.py
+-rw-r--r--  2.0 unx     4517 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/bst_payload_store_custom_lgbm.py
+-rw-r--r--  2.0 unx      748 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/decorators.py
+-rw-r--r--  2.0 unx     4292 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/dl_payload_store.py
+-rw-r--r--  2.0 unx     4440 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/dl_payload_store_custom.py
+-rw-r--r--  2.0 unx     2633 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/general_payload_store.py
+-rw-r--r--  2.0 unx     3049 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/autolog/spark_payload_store.py
+-rw-r--r--  2.0 unx      611 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/manual/__init__.py
+-rw-r--r--  2.0 unx     7385 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/manual/bst_payload_manual.py
+-rw-r--r--  2.0 unx     7402 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/manual/dl_payload_manual.py
+-rw-r--r--  2.0 unx     4965 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/manual/general_payload_manual.py
+-rw-r--r--  2.0 unx     4774 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/manual/manuallog_utils.py
+-rw-r--r--  2.0 unx     4461 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/store/manual/spark_payload_manual.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/supporting_classes/__init__.py
+-rw-r--r--  2.0 unx     3483 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/supporting_classes/cp4d_authenticator.py
+-rw-r--r--  2.0 unx     5359 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/supporting_classes/cp4d_token_manager.py
+-rw-r--r--  2.0 unx    22329 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/supporting_classes/factsheet_utils.py
+-rw-r--r--  2.0 unx      800 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/__init__.py
+-rw-r--r--  2.0 unx     4861 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/cell_facts.py
+-rw-r--r--  2.0 unx     3159 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/client_errors.py
+-rw-r--r--  2.0 unx     4858 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/client_utils.py
+-rw-r--r--  2.0 unx     1598 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/config.py
+-rw-r--r--  2.0 unx     3956 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/constants.py
+-rw-r--r--  2.0 unx     4548 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/cp4d_utils.py
+-rw-r--r--  2.0 unx     3920 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/doc_annotations.py
+-rw-r--r--  2.0 unx     4442 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/enums.py
+-rw-r--r--  2.0 unx     5255 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/logging_utils.py
+-rw-r--r--  2.0 unx     9152 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/manual_store_utils.py
+-rw-r--r--  2.0 unx     6318 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/me_containers_meta.py
+-rw-r--r--  2.0 unx     2095 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/metrics_utils.py
+-rw-r--r--  2.0 unx     9254 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/store_utils.py
+-rw-r--r--  2.0 unx    15176 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/support_scope_meta.py
+-rw-r--r--  2.0 unx    17106 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/utils.py
+-rw-r--r--  2.0 unx     7131 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/validation.py
+-rw-r--r--  2.0 unx      611 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/experiments/__init__.py
+-rw-r--r--  2.0 unx     7945 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/experiments/experiments_utils.py
+-rw-r--r--  2.0 unx      612 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/runs/__init__.py
+-rw-r--r--  2.0 unx    20668 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client/utils/runs/runs_utils.py
+-rw-r--r--  2.0 unx    10173 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client-1.0.59.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1001 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client-1.0.59.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client-1.0.59.dist-info/WHEEL
+-rw-r--r--  2.0 unx       94 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client-1.0.59.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       23 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client-1.0.59.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     8215 b- defN 23-Jun-23 09:47 ibm_aigov_facts_client-1.0.59.dist-info/RECORD
+78 files, 726894 bytes uncompressed, 157510 bytes compressed:  78.3%
```

## zipnote {}

```diff
@@ -48,14 +48,17 @@
 
 Filename: ibm_aigov_facts_client/export/export_facts_manual.py
 Comment: 
 
 Filename: ibm_aigov_facts_client/factsheet/__init__.py
 Comment: 
 
+Filename: ibm_aigov_facts_client/factsheet/approaches.py
+Comment: 
+
 Filename: ibm_aigov_facts_client/factsheet/asset_utils_experiments.py
 Comment: 
 
 Filename: ibm_aigov_facts_client/factsheet/asset_utils_me.py
 Comment: 
 
 Filename: ibm_aigov_facts_client/factsheet/asset_utils_model.py
@@ -63,20 +66,26 @@
 
 Filename: ibm_aigov_facts_client/factsheet/asset_utils_runs.py
 Comment: 
 
 Filename: ibm_aigov_facts_client/factsheet/assets.py
 Comment: 
 
+Filename: ibm_aigov_facts_client/factsheet/external_deployments.py
+Comment: 
+
 Filename: ibm_aigov_facts_client/factsheet/external_modelfacts_utility.py
 Comment: 
 
 Filename: ibm_aigov_facts_client/factsheet/factsheet_utility.py
 Comment: 
 
+Filename: ibm_aigov_facts_client/factsheet/html_parser.py
+Comment: 
+
 Filename: ibm_aigov_facts_client/store/__init__.py
 Comment: 
 
 Filename: ibm_aigov_facts_client/store/abstract_payload_manual.py
 Comment: 
 
 Filename: ibm_aigov_facts_client/store/abstract_payload_store.py
@@ -201,26 +210,26 @@
 
 Filename: ibm_aigov_facts_client/utils/runs/__init__.py
 Comment: 
 
 Filename: ibm_aigov_facts_client/utils/runs/runs_utils.py
 Comment: 
 
-Filename: ibm_aigov_facts_client-1.0.58.dist-info/LICENSE
+Filename: ibm_aigov_facts_client-1.0.59.dist-info/LICENSE
 Comment: 
 
-Filename: ibm_aigov_facts_client-1.0.58.dist-info/METADATA
+Filename: ibm_aigov_facts_client-1.0.59.dist-info/METADATA
 Comment: 
 
-Filename: ibm_aigov_facts_client-1.0.58.dist-info/WHEEL
+Filename: ibm_aigov_facts_client-1.0.59.dist-info/WHEEL
 Comment: 
 
-Filename: ibm_aigov_facts_client-1.0.58.dist-info/entry_points.txt
+Filename: ibm_aigov_facts_client-1.0.59.dist-info/entry_points.txt
 Comment: 
 
-Filename: ibm_aigov_facts_client-1.0.58.dist-info/top_level.txt
+Filename: ibm_aigov_facts_client-1.0.59.dist-info/top_level.txt
 Comment: 
 
-Filename: ibm_aigov_facts_client-1.0.58.dist-info/RECORD
+Filename: ibm_aigov_facts_client-1.0.59.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ibm_aigov_facts_client/client/fact_trace.py

```diff
@@ -430,9 +430,25 @@
         token =  FactsClientAdapter._authenticator.token_manager.get_token() if  ( isinstance(FactsClientAdapter._authenticator, IAMAuthenticator) or (isinstance(FactsClientAdapter._authenticator, CloudPakForDataAuthenticator))) else FactsClientAdapter._authenticator.bearer_token
         iam_headers = {
             "Content-Type": "application/json",
             "Authorization": "Bearer %s" % token
         }
         return iam_headers 
 
+    def get_cpd_version(self)->str:
 
 
+        """
+            Get Cloud Pak for Data version. If it's cloud then it'll return as SaaS
+
+            :rtype: CP4D version or SaaS if it's cloud.
+            
+            The way to use me is:
+            
+            >>> client.assets.get_cpd_version()
+        
+        """
+
+        if FactsClientAdapter._is_cp4d:
+            return self.get_CP4D_version()
+        else:
+            return "SaaS"
```

## ibm_aigov_facts_client/factsheet/asset_utils_me.py

```diff
@@ -11,49 +11,54 @@
 from ibm_aigov_facts_client.utils.utils import validate_enum,validate_type
 from ibm_aigov_facts_client.utils.cell_facts import CellFactsMagic
 
 from ibm_aigov_facts_client.utils.config import *
 from ibm_aigov_facts_client.utils.client_errors import *
 from ibm_aigov_facts_client.utils.constants import *
 
+from ibm_aigov_facts_client.factsheet.approaches import ApproachUtilities
+from ibm_aigov_facts_client.factsheet.html_parser import FactHTMLParser
+
 _logger = logging.getLogger(__name__) 
 
 
-class ModelEntryUtilities:
+class ModelUsecaseUtilities:
 
     """
-        Model use case utilities. Running `client.assets.model_usecase()` makes all methods in ModelEntryUtilities object available to use.
+        Model use case utilities. Running `client.assets.model_usecase()` makes all methods in ModelUsecaseUtilities object available to use.
     
     """
    
     def __init__(self,assets_client:'assets.Assets',model_id:str=None, model_usecase_id: str=None, container_type: str=None, container_id: str=None,facts_type: str=None) -> None:
 
         """
-        Initialize a ModelEntryUtilities object.
+        Initialize a ModelUsecaseUtilities object.
         
         """
 
         self._asset_id = model_usecase_id
         self._container_type=container_type
         self._container_id=container_id
         self._facts_type=facts_type
 
+        self._assets_client=assets_client
+
         self._facts_client=assets_client._facts_client
         self._is_cp4d=assets_client._is_cp4d
         self._external_model=assets_client._external_model
         
         if self._is_cp4d:
             self._cpd_configs=assets_client._cpd_configs
             self._cp4d_version=assets_client._cp4d_version
 
         self._facts_definitions=self._get_fact_definitions()
 
     @classmethod
-    def from_dict(cls, _dict: Dict) -> 'ModelEntryUtilities':
-        """Initialize a ModelEntryUtilities object from a json dictionary."""
+    def from_dict(cls, _dict: Dict) -> 'ModelUsecaseUtilities':
+        """Initialize a ModelUsecaseUtilities object from a json dictionary."""
         args = {}
         if '_asset_id' in _dict:
             args['asset_id'] = _dict.get('_asset_id')
        
         if '_container_type' in _dict:
             args['container_type'] = _dict.get('_container_type') #[convert_model(x) for x in metrics]
         else:
@@ -89,46 +94,55 @@
         
         return _dict
 
     def _to_dict(self):
         """Return a json dictionary representing this model."""
         return self.to_dict()
     
+    def __str__(self) -> str:
+        """Return a `str` version of this ModelUsecaseUtilities object."""
+        return json.dumps(self.to_dict(), indent=2)
+
+    def __repr__(self):
+        """Return a `repr` version of this ModelUsecaseUtilities object."""
+        return json.dumps(self.to_dict(), indent=2)
+
     def _get_fact_definitions(self)->Dict:
 
         """
             Get all facts definitions
 
             :rtype: dict
 
             A way you might use me is:
 
             >>> model_usecase.get_fact_definitions()
 
         """
 
-        if self._is_cp4d:
-           url = self._cpd_configs["url"] + \
-                    "/v2/asset_types/" + self._facts_type + "?" + self._container_type + "_id=" + self._container_id
-        else:
-            if get_env() == 'dev':
-                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + \
-                    "/v2/asset_types/" + self._facts_type + "?" + self._container_type + "_id=" + self._container_id
-            elif get_env() == 'test':
-                url = test_config["DEFAULT_TEST_SERVICE_URL"] + \
-                    "/v2/asset_types/" + self._facts_type + "?" + self._container_type + "_id=" + self._container_id
+        if(self._facts_type != None):
+            if self._is_cp4d:
+                url = self._cpd_configs["url"] + \
+                        "/v2/asset_types/" + self._facts_type + "?" + self._container_type + "_id=" + self._container_id
             else:
-                url = prod_config["DEFAULT_SERVICE_URL"] + \
-                    "/v2/asset_types/" + self._facts_type + "?" + self._container_type + "_id=" + self._container_id
+                if get_env() == 'dev':
+                    url = dev_config["DEFAULT_DEV_SERVICE_URL"] + \
+                        "/v2/asset_types/" + self._facts_type + "?" + self._container_type + "_id=" + self._container_id
+                elif get_env() == 'test':
+                    url = test_config["DEFAULT_TEST_SERVICE_URL"] + \
+                        "/v2/asset_types/" + self._facts_type + "?" + self._container_type + "_id=" + self._container_id
+                else:
+                    url = prod_config["DEFAULT_SERVICE_URL"] + \
+                        "/v2/asset_types/" + self._facts_type + "?" + self._container_type + "_id=" + self._container_id
 
-        response = requests.get(url, headers=self._get_headers())
-        if not response.ok:
-            raise ClientError("User facts definitions not found. ERROR {}. {}".format(response.status_code,response.text))
-        else:
-            return response.json()
+            response = requests.get(url, headers=self._get_headers())
+            if not response.ok:
+                raise ClientError("User facts definitions not found. ERROR {}. {}".format(response.status_code,response.text))
+            else:
+                return response.json()
 
     def get_info(self,verbose=False)-> Dict:
         """Get model use case details
 
         :param verbose: If True, returns additional model details. Defaults to False
         :type verbose: bool, optional
         :rtype: dict
@@ -202,15 +216,15 @@
         
         if not value or value=='':
             raise ClientError("Value can not be empty")
         
         url=self._get_url_by_factstype_container()
 
         attr_is_array=self._get_fact_definition_properties(fact_id).get("is_array")
-        value_type_array=(type(value) is not str and isinstance(value, collections.Sequence))
+        value_type_array=(type(value) is not str and isinstance(value, collections.abc.Sequence))
         
         if isinstance(value, list) and any(isinstance(x, dict) for x in value ):
             raise ClientError("Value should be a list of Strings but found Dict")
 
         self._type_check_by_id(fact_id,value)
         
         path= "/" + fact_id
@@ -280,15 +294,15 @@
         url=self._get_url_by_factstype_container()
 
         body=[]
 
         for key, val in facts_dict.items() : 
             
             attr_is_array=self._get_fact_definition_properties(key).get("is_array")
-            value_type_array=(type(val) is not str and isinstance(val, collections.Sequence))
+            value_type_array=(type(val) is not str and isinstance(val, collections.abc.Sequence))
             
             self._type_check_by_id(key,val)
 
             path= "/" + key
             op = ADD
 
             
@@ -532,16 +546,16 @@
             :param str file_to_upload: Attachment file path to upload
             :param str description: Description about the attachment file
             :param str fact_id: Fact id for the attachment
             :param str html_rendering_hint: (Optional) html rendering hint. Available options are in :func:`~ibm_aigov_facts_client.utils.enums.RenderingHints`
 
             A way to use me is:
 
-            >>> model_usecase.set_attachment_fact(fileToUpload="./artifacts/image.png",description=<file description>,fact_id=<custom fact id>)
-            >>> model_usecase.set_attachment_fact(fileToUpload="./artifacts/image.png",description=<file description>,fact_id=<custom fact id>,html_rendering_hint=<render hint>)
+            >>> model_usecase.set_attachment_fact(file_to_upload="./artifacts/image.png",description=<file description>,fact_id=<custom fact id>)
+            >>> model_usecase.set_attachment_fact(file_to_upload="./artifacts/image.png",description=<file description>,fact_id=<custom fact id>,html_rendering_hint=<render hint>)
 
         """
         
         if self._is_cp4d and self._cp4d_version < "4.6.5":
             raise ClientError("Version mismatch: Attachment functionality is only supported in CP4D version 4.6.5 or higher. Current version of CP4D is "+self._cp4d_version)
 
         model_asset_id=self._asset_id
@@ -570,14 +584,26 @@
 
             mimetype=self._get_mime(file_to_upload)
 
             attachment_url=self._get_url_attachments(model_asset_id,model_container_type,model_container_id)
 
             base_filename = os.path.basename(file_to_upload)
 
+            if html_rendering_hint==RenderingHints.INLINE_HTML:
+                htmlparser = FactHTMLParser()
+                html_file = open(file_to_upload, 'r')
+                html_content = html_file.read()
+                htmlparser.feed(html_content)
+                htmlparser.close()
+                restricted_tags = "style istyle css"
+                # checking if any of the above restricted_tags values in html tags
+                contains_restricted_tag = any(item in restricted_tags for item in htmlparser.start_tags)
+                if contains_restricted_tag:
+                    raise ClientError("Invalid inline HTML content: Attachments content to be rendered as inline_html is NOT allowed to contain any of the following HTML tags: {}".format(list(restricted_tags.split(" "))))
+
             # convert png to jpeg
             flag=False
             if mimetype=="image/png":
                 from PIL import Image
 
                 ima=Image.open(file_to_upload)
                 rgb_im = ima.convert('RGB')
@@ -1279,7 +1305,555 @@
             url += "&response-content-disposition=attachment;filename=" + filename
 
         response=requests.get(url, headers=self._get_headers())
         download_url = response.json().get("url")
         return download_url
 
 
+    ########   Commenting below 2 methods based on this defect  https://github.ibm.com/wdp-gov/tracker/issues/126147
+
+    # def modify_approach_or_version_of_model(self,approach_id:str=None,version_number:str=None,target_approach_id:str=None,target_version_number:str=None,target_version_comment:str=None):
+
+    #     """
+    #         Returns WKC Model usecase updated approach. Supported for CPD version >=4.7.0
+            
+    #         :param str approach_id: Name of approach
+    #         :param str version_number: Version number of the model
+    #         :param str target_approach_id: Target approach ID
+    #         :param str target_version_number: Target version number
+    #         :param str target_version_comment: Target version comment
+
+    #         :rtype: None
+
+    #         :return: WKC Model usecase approache is modified
+            
+    #         Example:
+    #         >>> client.assets.model_usecase.modify_approach_or_version_of_model(approach_id=<approach_id>,version_number=<version_number>,target_approach_id=<target_approach_id>,target_version_number=<target_version_number>,target_version_comment=<target_version_comment>)
+    #     """
+
+    #     if self._is_cp4d and self._cp4d_version < "4.7.0":
+    #         raise ClientError("Version mismatch: Model usecase, modify approach or version of model functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+    #     if (approach_id is None or approach_id == ""):
+    #         raise MissingValue("approach_id", "approach ID is missing")
+    #     if (version_number is None or version_number == ""):
+    #         raise MissingValue("version_number", "version number is missing")
+    #     if (target_approach_id is None or target_approach_id == ""):
+    #         raise MissingValue("target_approach_id", "target approach ID is missing")
+    #     if (target_version_number is None or target_version_number == ""):
+    #         raise MissingValue("target_version_number", "target version number is missing")
+
+    #     model_asset_id=self._asset_id
+    #     model_container_id= self._container_id
+
+    #     if target_approach_id:
+    #         body= {
+    #                 "target_approach_id": target_approach_id,
+    #                 "target_version_number": target_version_number,
+    #                 "target_version_comment": target_version_comment
+    #             }
+    #     else:
+    #         raise ClientError("Provide target approach ID")
+       
+    #     url=self._get_approach_url(model_asset_id,model_container_id,approach_id,version_number,operation="put")
+
+    #     response = requests.put(url,data=json.dumps(body), headers=self._get_headers())
+        
+    #     if response.status_code ==200:
+    #         _logger.info("Approach or version of model updated successfully")
+    #         return response
+    #     else:
+    #         raise ClientError("Failed while updating an approach or version of model. ERROR {}. {}".format(response.status_code,response.text))
+    
+
+
+    # def update_approach(self,approach_id:str=None,new_approach_name:str=None,new_approach_description:str=None):
+
+    #     """
+    #         Returns WKC Model usecase updated approach. Supported for CPD version >=4.7.0
+            
+    #         :param str approach_id: Name of approach
+    #         :param str new_approach_name: New name for approach
+    #         :param str new_approach_description: New description for approach
+            
+    #         :rtype: None
+
+    #         :return: WKC Model usecase approache is updated
+            
+    #         Example:
+    #         >>> client.assets.model_usecase.remove_approach(approach_id=<approach_id>,new_approach_name=<new_approach_name>,new_approach_description=<new_approach_description>)
+    #     """
+
+    #     if self._is_cp4d and self._cp4d_version < "4.7.0":
+    #         raise ClientError("Version mismatch: Model usecase, update approach functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+    #     if (approach_id is None or approach_id == ""):
+    #         raise MissingValue("approach_id", "approach ID is missing")
+    #     if (new_approach_name is None or new_approach_name == ""):
+    #         raise MissingValue("new_approach_name", "New approach name is missing")
+    #     if (new_approach_description is None or new_approach_description == ""):
+    #         raise MissingValue("new_approach_description", "New approach description is missing")
+
+    #     model_asset_id=self._asset_id
+    #     model_container_id= self._container_id
+
+    #     if new_approach_name:
+    #         body= [
+    #             {
+    #                 "op": "add",
+    #                 "path": "/name",
+    #                 "value": new_approach_name
+    #             },
+    #             {
+    #                 "op": "add",
+    #                 "path": "/description",
+    #                 "value": new_approach_description
+    #             }
+    #             ]
+    #     else:
+    #         raise ClientError("Provide approach name")
+
+    #     url=self._get_approach_url(model_asset_id,model_container_id,approach_id,operation="patch")
+
+    #     response = requests.patch(url,data=json.dumps(body), headers=self._get_headers())
+        
+    #     if response.status_code ==200:
+    #         _logger.info("Approach updated successfully")
+    #         return response.json()
+    #     else:
+    #         raise ClientError("Failed while updating an approach. ERROR {}. {}".format(response.status_code,response.text))
+    
+
+    def remove_approach(self,approach:ApproachUtilities=None):
+
+        """
+            Returns WKC Model usecase removed approache. Supported for CPD version >=4.7.0
+            
+            :param ApproachUtilities approach: Object or instance of ApproachUtilities
+            
+            :rtype: None
+
+            :return: WKC Model usecase approache is removed
+            
+            Example:
+            >>> client.assets.model_usecase.remove_approach(approach=ApproachUtilities)
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.7.0":
+            raise ClientError("Version mismatch: Model usecase, remove approach functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+
+        if (approach is None or approach == ""):
+            raise MissingValue("approach", "ApproachUtilities object or instance is missing")
+        
+        if ( not isinstance(approach, ApproachUtilities)):
+            raise ClientError("Provide ApproachUtilities object for approach")
+
+        approach_id = approach.get_id()
+        if (approach_id == "00000000-0000-0000-0000-000000000000"):
+            _logger.info("Can't delete default approach ")
+        else:
+            model_asset_id=self._asset_id
+            model_container_id= self._container_id
+
+            url=self._get_approach_url(model_asset_id,model_container_id,approach_id,operation="delete")
+
+        
+            response=requests.delete(url,headers=self._get_headers())
+
+            if response.status_code ==204:
+                _logger.info("Approach removed successfully")
+            else:
+                raise ClientError("Failed in removing an approache. ERROR {}. {}".format(response.status_code,response.text))
+
+
+    def create_approach(self,name:str=None,description:str=None)->ApproachUtilities:
+
+        """
+            Returns WKC Model usecase approache. Supported for CPD version >=4.7.0
+            
+            :param str name: Name of approach
+            :param str description: (Optional) Description of approach
+            :rtype: ApproachUtilities
+
+            :return: WKC Model usecase approache
+            
+            Example:
+            >>> client.assets.model_usecase.create_approach(name=<approach name>,description=<approach description>)
+            >>> client.assets.model_usecase.create_approach(name=<approach name>)
+
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.7.0":
+            raise ClientError("Version mismatch: Model usecase, create approach functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        model_asset_id=self._asset_id
+        model_container_type= self._container_type
+        model_container_id= self._container_id
+
+        if (name is None or name == ""):
+            raise MissingValue("name", "approach name is missing")
+        
+        if name:
+            body={
+                    "name": name,
+                    "description": description,
+                    "icon": "Packages",
+                    "icon_color": "Gray"
+                }
+        else:
+            raise ClientError("Provide approach name")
+
+        url=self._get_approach_url(model_asset_id,model_container_id,operation="post")
+        response = requests.post(url,data=json.dumps(body), headers=self._get_headers())
+        
+        if response.status_code ==200:
+            _logger.info("Approach created successfully")
+            ret_create_approach = response.json()
+            return ApproachUtilities(self,approach_id=ret_create_approach.get('id'),approach_name=ret_create_approach.get('name'),approach_desc=ret_create_approach.get('description'),approach_icon=ret_create_approach.get('icon'),approach_icon_color=ret_create_approach.get('icon_color'),model_asset_id=model_asset_id,model_container_type=model_container_type,model_container_id=model_container_id)
+            #return response.json()
+        else:
+            raise ClientError("Failed while creating an approach. ERROR {}. {}".format(response.status_code,response.text))
+
+
+    def get_approaches(self)->list:
+
+        """
+            Returns list of WKC Model usecase approaches. Supported for CPD version >=4.7.0
+            
+            :return: All WKC Model usecase approaches
+            :rtype: list(ApproachUtilities)
+
+            Example:
+            >>> client.assets.model_usecase.get_approaches()
+
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.7.0":
+            raise ClientError("Version mismatch: Model usecase, retrieve approaches functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        model_asset_id=self._asset_id
+        model_container_type= self._container_type
+        model_container_id= self._container_id
+
+        url=self._get_approach_url(model_asset_id,model_container_id,operation="get")
+        response=requests.get(url,headers=self._get_headers())
+
+        if response.status_code ==200:
+            _logger.info("Approaches retrieved successfully")
+            approaches_list = response.json()["approaches"]
+            approach_list_values = []
+            for approach in approaches_list:
+                approach_list_values.append(ApproachUtilities(self,approach_id=approach.get('id'),approach_name=approach.get('name'),approach_desc=approach.get('description'),approach_icon=approach.get('icon'),approach_icon_color=approach.get('icon_color'),versions=approach.get('versions'),model_asset_id=model_asset_id,model_container_type=model_container_type,model_container_id=model_container_id))
+            return approach_list_values
+        else:
+            raise ClientError("Failed in retrieving an approache. ERROR {}. {}".format(response.status_code,response.text))
+
+    def get_approach(self,approach_id:str=None)->ApproachUtilities:
+
+        """
+            Returns WKC Model usecase approaches. Supported for CPD version >=4.7.0
+            
+            :param str approach_id: Approach ID
+
+            :rtype: ApproachUtilities
+
+            :return:  Specific WKC Model usecase approache
+            
+
+            Example:
+            >>> client.assets.model_usecase.get_approach(approach_id=<approach_id>)
+
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.7.0":
+            raise ClientError("Version mismatch: Model usecase, retrieve approach functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        if (approach_id is None or approach_id == ""):
+            raise MissingValue("approach_id", "approach ID is missing")
+
+        model_asset_id=self._asset_id
+        model_container_type= self._container_type
+        model_container_id= self._container_id
+
+        url=self._get_approach_url(model_asset_id,model_container_id,operation="get")
+        response=requests.get(url,headers=self._get_headers())
+
+        if response.status_code ==200:
+            approaches_list = response.json()["approaches"]
+            _is_approach_exists = False
+            for approach in approaches_list:
+                if approach.get('id') == approach_id:
+                    _is_approach_exists = True
+                    _logger.info("Approach retrieved successfully")
+                    return ApproachUtilities(self,approach_id=approach.get('id'),approach_name=approach.get('name'),approach_desc=approach.get('description'),approach_icon=approach.get('icon'),approach_icon_color=approach.get('icon_color'),versions=approach.get('versions'),model_asset_id=model_asset_id,model_container_type=model_container_type,model_container_id=model_container_id)
+            if not _is_approach_exists:
+                raise ClientError("Approach "+approach_id+" is not available.")
+        else:
+            raise ClientError("Failed in retrieving an approache. ERROR {}. {}".format(response.status_code,response.text))
+
+
+    def _get_approach_url(self,model_usecase_asset_id:str=None,catalog_id:str=None,approach_id:str=None,version_number:str=None,operation:str=None):
+        
+        if operation == 'post':
+            append_url = '/v1/aigov/model_inventory/model_usecases/' + model_usecase_asset_id + '/version_approach?catalog_id='+ catalog_id
+        elif operation == 'get':
+            append_url = '/v1/aigov/model_inventory/model_usecases/' + model_usecase_asset_id + '/tracked_model_versions?catalog_id='+ catalog_id
+        elif operation == 'delete' or operation == 'patch':
+            append_url = '/v1/aigov/model_inventory/model_usecases/' + model_usecase_asset_id + '/version_approach/' + approach_id + '?catalog_id='+ catalog_id
+        elif operation == 'put':
+            append_url = '/v1/aigov/model_inventory/model_usecases/' + model_usecase_asset_id + '/version_approach/' + approach_id + '/versions/'+ version_number +'?catalog_id='+ catalog_id
+        else:
+            append_url = ""
+        
+        if self._is_cp4d:
+            url = self._cpd_configs["url"] + append_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + append_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + append_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + append_url
+
+        return url
+
+
+    def get_grc_models(self)->list:
+
+        """
+            Returns list of WKC Models associated with Openpages for a particular model usecase
+            
+            :return: All WKC Models associated with Openpages for a particular model usecase
+            :rtype: list()
+
+            Example:
+            >>> client.assets.model_usecase.get_grc_models()
+
+        """
+
+        modelusecase_asset_id=self._asset_id
+        model_container_type= self._container_type
+        modelusecase_catalog_id= self._container_id
+
+        #if self._is_cp4d and self._cp4d_version < "4.7.0":
+        #    raise ClientError("Version mismatch: models associated for a particular Model usecase in Openpages functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        if (modelusecase_asset_id is None or modelusecase_asset_id == ""):
+            raise MissingValue("modelusecase_asset_id", "model usecase asset ID is missing")
+        if (modelusecase_catalog_id is None or modelusecase_catalog_id == ""):
+            raise MissingValue("modelusecase_catalog_id", "model usecase catalog ID is missing")
+
+        url=self._get_grc_url(modelusecase_asset_id,modelusecase_catalog_id)
+        response=requests.get(url,headers=self._get_headers())
+
+        if response.status_code ==200:
+            _logger.info("GRC models retrieved successfully")
+            grc_model_list = response.json()["models"]
+            grc_model_list_values = []
+            for grc_model in grc_model_list:
+                grc_model_list_values.append({'GrcModel': {'id': grc_model.get('model_id'), 'name': grc_model.get('model_name'), 'description': grc_model.get('model_description'), 'status': grc_model.get('model_status')}})
+            return grc_model_list_values
+        else:
+            raise ClientError("Failed in retrieving GRC models. ERROR {}. {}".format(response.status_code,response.text))
+
+
+    def get_grc_model(self,id: str=None):
+
+        """
+            Returns list WKC Model associated with Openpages for a particular model usecase
+            
+            :return: WKC Model associated with Openpages for a particular model usecase
+            :rtype: dictionary
+
+            Example:
+            >>> client.assets.model_usecase.get_grc_model(id=<grc_model_id>)
+
+        """
+
+        modelusecase_asset_id=self._asset_id
+        model_container_type= self._container_type
+        modelusecase_catalog_id= self._container_id
+
+        #if self._is_cp4d and self._cp4d_version < "4.7.0":
+        #    raise ClientError("Version mismatch: models associated for a particular Model usecase in Openpages functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        if (modelusecase_asset_id is None or modelusecase_asset_id == ""):
+            raise MissingValue("modelusecase_asset_id", "model usecase asset ID is missing")
+        if (modelusecase_catalog_id is None or modelusecase_catalog_id == ""):
+            raise MissingValue("modelusecase_catalog_id", "model usecase catalog ID is missing")
+
+        url=self._get_grc_url(modelusecase_asset_id,modelusecase_catalog_id)
+        response=requests.get(url,headers=self._get_headers())
+
+        if response.status_code ==200:
+            _logger.info("GRC models retrieved successfully")
+            grc_model_list = response.json()["models"]
+            _is_grc_model_exists = False
+            for grc_model in grc_model_list:
+                if grc_model.get('model_id') == id:
+                    _is_grc_model_exists = True
+                    _logger.info("GRC model retrieved successfully")
+                    return {'GrcModel': {'id': grc_model.get('model_id'), 'name': grc_model.get('model_name'), 'description': grc_model.get('model_description'), 'status': grc_model.get('model_status')}}
+            if not _is_grc_model_exists:
+                raise ClientError("GRC Model ID "+id+" is not available.")
+        else:
+            raise ClientError("Failed in retrieving GRC models. ERROR {}. {}".format(response.status_code,response.text))
+
+
+    def _get_grc_url(self,model_usecase_asset_id:str=None,catalog_id:str=None):
+        
+        
+        append_url = '/v1/aigov/model_inventory/grc/model_entries/' + model_usecase_asset_id + '/models?catalog_id='+ catalog_id
+        
+        if self._is_cp4d:
+            url = self._cpd_configs["url"] + append_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + append_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + append_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + append_url
+
+        return url
+
+
+    def get_name(self)->str:
+
+        """
+            Returns model usecase name
+            
+            :return: Model usecase name
+            :rtype: str
+
+            Example:
+            >>> client.assets.model_usecase.get_name()
+
+        """
+
+        return self.get_info(True).get("name")
+    
+    def get_id(self)->str:
+
+        """
+            Returns model usecase asset ID 
+            
+            :return: Model usecase asset ID
+            :rtype: str
+
+            Example:
+            >>> client.assets.model_usecase.get_id()
+
+        """
+
+        return self.get_info(True).get("model_usecase_id")
+
+    def get_container_id(self)->str:
+
+        """
+            Returns model usecase container ID 
+            
+            :return: Model usecase container ID
+            :rtype: str
+
+            Example:
+            >>> client.assets.model_usecase.get_container_id()
+
+        """
+
+        return self.get_info(True).get("catalog_id")
+    
+    def get_container_type(self)->str:
+
+        """
+            Returns model usecase container type
+            
+            :return: Model usecase container type
+            :rtype: str
+
+            Example:
+            >>> client.assets.model_usecase.get_container_type()
+
+        """
+
+        return self.get_info(True).get("container_type")
+
+    def get_description(self)->str:
+
+        """
+            Returns model usecase description
+            
+            :return: Model usecase description
+            :rtype: str
+
+            Example:
+            >>> client.assets.model_usecase.get_description()
+
+        """
+
+        return self.get_info(True).get("description")
+
+    def relate_models(self,reference_model_asset_id: str=None, model_asset_id: str=None):
+
+        """
+            Returns Update master_id for a model
+            
+            :return: Update master_id for a model, now both models will be in same row.
+            :rtype: None
+
+            Example:
+            >>> client.assets.model_usecase.get_grc_model(id=<grc_model_id>)
+
+        """
+
+        if (reference_model_asset_id is None or reference_model_asset_id == ""):
+            raise MissingValue("reference_model_asset_id", "Reference model asset ID is missing")
+        
+        if (model_asset_id is None or model_asset_id == ""):
+            raise MissingValue("model_asset_id", "Model asset ID is missing")
+        
+        modelusecase_asset_id=self._asset_id
+        model_container_type= self._container_type
+        modelusecase_catalog_id= self._container_id
+
+        #if self._is_cp4d and self._cp4d_version < "4.7.0":
+        #    raise ClientError("Version mismatch: relate models functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        if (modelusecase_asset_id is None or modelusecase_asset_id == ""):
+            raise MissingValue("modelusecase_asset_id", "model usecase asset ID is missing")
+        if (modelusecase_catalog_id is None or modelusecase_catalog_id == ""):
+            raise MissingValue("modelusecase_catalog_id", "model usecase catalog ID is missing")
+
+        url=self._get_relatemodels_url(modelusecase_asset_id,modelusecase_catalog_id)
+
+        body = [
+                {
+                    "reference_model_id": reference_model_asset_id, 
+                    "model_id": model_asset_id
+                }
+            ]
+        response = requests.patch(url, data=json.dumps(body), headers=self._get_headers())
+        
+        if response.status_code ==200:
+            _logger.info("Models are related successfully")
+        else:
+            raise ClientError("Failed in relating models. ERROR {}. {}".format(response.status_code,response.text))
+
+
+    def _get_relatemodels_url(self,model_usecase_asset_id:str=None,catalog_id:str=None):
+        
+        
+        append_url = '/v1/aigov/model_inventory/grc/model_entries/' + model_usecase_asset_id + '/relatemodels?catalog_id='+ catalog_id
+        
+        if self._is_cp4d:
+            url = self._cpd_configs["url"] + append_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + append_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + append_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + append_url
+
+        return url
+
```

## ibm_aigov_facts_client/factsheet/asset_utils_model.py

```diff
@@ -1,34 +1,38 @@
 import logging
 import os
 import json
 import collections
 import itertools
 import uuid
 import ibm_aigov_facts_client._wrappers.requests as requests
+import hashlib
 
 from typing import Optional
 from datetime import datetime
 
 from typing import BinaryIO, Dict, List, TextIO, Union,Any
-from ibm_aigov_facts_client.factsheet import assets 
+from ibm_aigov_facts_client.factsheet import assets
 from ibm_cloud_sdk_core.authenticators import IAMAuthenticator,CloudPakForDataAuthenticator
 from ibm_aigov_facts_client.utils.enums import AssetContainerSpaceMap, AssetContainerSpaceMapExternal,ContainerType, FactsType, ModelEntryContainerType, AllowedDefinitionType,FormatType, RenderingHints
 from ibm_aigov_facts_client.utils.utils import validate_enum,validate_type,STR_TYPE
-from ibm_aigov_facts_client.factsheet.asset_utils_me import ModelEntryUtilities
+from ibm_aigov_facts_client.factsheet.asset_utils_me import ModelUsecaseUtilities
 from ibm_aigov_facts_client.factsheet.asset_utils_experiments import NotebookExperimentUtilities
 from ibm_cloud_sdk_core.utils import  convert_model
 from ibm_aigov_facts_client.utils.metrics_utils import convert_metric_value_to_float_if_possible
 from ibm_aigov_facts_client.utils.cell_facts import CellFactsMagic
 
-
+from ibm_aigov_facts_client.factsheet.approaches import ApproachUtilities
 from ibm_aigov_facts_client.utils.config import *
 from ibm_aigov_facts_client.utils.client_errors import *
 from ibm_aigov_facts_client.utils.constants import *
 
+from ibm_aigov_facts_client.factsheet.external_deployments import Deployment
+from ibm_aigov_facts_client.factsheet.html_parser import FactHTMLParser
+from ibm_aigov_facts_client.utils.doc_annotations import deprecated
 
 _logger = logging.getLogger(__name__) 
 
 
 class ModelAssetUtilities:
 
     """
@@ -97,14 +101,22 @@
         return _dict
   
 
     def _to_dict(self):
         """Return a json dictionary representing this model."""
         return self.to_dict()
 
+    def __str__(self) -> str:
+        """Return a `str` version of this ModelAssetUtilities object."""
+        return json.dumps(self.to_dict(), indent=2)
+
+    def __repr__(self):
+        """Return a `repr` version of this ModelAssetUtilities object."""
+        return json.dumps(self.to_dict(), indent=2)
+
     def get_info(self,verbose=False)-> Dict:
         """Get model object details
 
             :param verbose: If True, returns additional model details. Defaults to False
             :type verbose: bool, optional
             :rtype: dict
 
@@ -207,29 +219,29 @@
                     raise ClientError ("Model {} is not tracked by a model use case".format(self._asset_id))
                 lmdidParts = lmid.split(':')
                 if len(lmdidParts) < 2:
                     return None
                 container_id = lmdidParts[0]
                 model_usecase_id = lmdidParts[1]
             
-            self._current_model_usecase= ModelEntryUtilities(self,model_usecase_id=model_usecase_id,container_type=MODEL_USECASE_CONTAINER_TYPE_TAG,container_id=container_id,facts_type=FactsType.MODEL_USECASE_USER)
+            self._current_model_usecase= ModelUsecaseUtilities(self,model_usecase_id=model_usecase_id,container_type=MODEL_USECASE_CONTAINER_TYPE_TAG,container_id=container_id,facts_type=FactsType.MODEL_USECASE_USER)
         
             return self._current_model_usecase.to_dict()
 
         else:
             raise ClientError("Asset model use case information is not available for model id {}. ERROR. {}. {}".format(self._asset_id,response.status_code,response.text))
 
  
 
-    def get_tracking_model_usecase(self)-> ModelEntryUtilities:
+    def get_tracking_model_usecase(self)-> ModelUsecaseUtilities:
 
         """
             Get model use case associated to the model.
             
-            :rtype: ModelEntryUtilities
+            :rtype: ModelUsecaseUtilities
 
             A way you might use me is:
 
             >>> model.get_tracking_model_usecase()
 
         """
 
@@ -250,22 +262,22 @@
                     raise ClientError ("Model {} is not tracked by a model use case. lmid is missing".format(self._asset_id))
                 lmdidParts = lmid.split(':')
                 if len(lmdidParts) < 2:
                     return None
                 container_id = lmdidParts[0]
                 model_usecase_id = lmdidParts[1]
             
-            self._current_model_usecase= ModelEntryUtilities(self,model_usecase_id=model_usecase_id,container_type=MODEL_USECASE_CONTAINER_TYPE_TAG,container_id=container_id,facts_type=FactsType.MODEL_USECASE_USER)
+            self._current_model_usecase= ModelUsecaseUtilities(self,model_usecase_id=model_usecase_id,container_type=MODEL_USECASE_CONTAINER_TYPE_TAG,container_id=container_id,facts_type=FactsType.MODEL_USECASE_USER)
         
             return self._current_model_usecase
 
         else:
             raise ClientError("Asset model use case information is not available for model id {}. ERROR. {}. {}".format(self._asset_id,response.status_code,response.text))
 
-
+    @deprecated(alternative="model.track()")
     def add_tracking_model_usecase(self,model_usecase_name:str=None,model_usecase_desc:str=None,model_usecase_id:str=None,model_usecase_catalog_id:str=None,grc_model_id:str=None):
         
         """
             Link Model to model use case. Model asset should be stored in either Project or Space and corrsponding ID should be provided when registering to model use case. 
 
             
             :param str model_usecase_name: (Optional) New model use case name. Used only when creating new model use case. 
@@ -353,14 +365,15 @@
             error_msg = u'Model registration failed'
             reason = response.text
             _logger.info(error_msg)
             raise ClientError(error_msg + '. Error: ' + str(response.status_code) + '. ' + reason)
 
         return response.json()
 
+    @deprecated(alternative="model.untrack()")
     def remove_tracking_model_usecase(self):
         """
             Unregister from model use case
 
             Example for IBM Cloud or CPD:
 
             >>> model.remove_tracking_model_usecase()
@@ -431,15 +444,15 @@
             url=self._get_url_by_factstype_container()
         else:
             raise ClientError("Fact id {} is not defined under custom asset definitions".format(fact_id))
 
         if cur_val:
             attr_is_array=cur_val.get("is_array")
 
-        value_type_array=(type(value) is not str and isinstance(value, collections.Sequence))
+        value_type_array=(type(value) is not str and isinstance(value, collections.abc.Sequence))
         
         if isinstance(value, list) and any(isinstance(x, dict) for x in value ):
             raise ClientError("Value should be a list of Strings but found Dict")
 
         self._type_check_by_id(fact_id,value)
         
         path= "/" + fact_id
@@ -532,15 +545,15 @@
                 _logger.info("Escaping Fact id {} as it is not defined under custom asset definitions".format(key))
 
             cur_val= attr_is_array or attr_is_array_op
             
             if cur_val:
                 is_array=cur_val.get("is_array")
 
-                value_type_array=(type(val) is not str and isinstance(val, collections.Sequence))
+                value_type_array=(type(val) is not str and isinstance(val, collections.abc.Sequence))
                 
                 self._type_check_by_id(key,val)
 
                 path= "/" + key
                 op = ADD
 
                 
@@ -940,16 +953,34 @@
             A way you might use me is:
 
             >>> model.set_environment_type(from_container="test",to_container="validate")
 
         """
         
         if self._external_model:
-            self._set_environment_classification_external(from_container,to_container)
-            
+
+            if self._is_cp4d and self._cp4d_version < "4.7.0":
+                self._set_environment_classification_external(from_container,to_container)
+            elif (self._is_cp4d and self._cp4d_version >= "4.7.0") or (not self._is_cp4d):
+                validate_enum(from_container,"from_container", ModelEntryContainerType, True)
+                validate_enum(to_container,"to_container", ModelEntryContainerType, True)
+
+                container_asset_id=self._asset_id
+                asset_container_type=self._container_type
+                asset_container_id=self._container_id
+                body={
+                    "target_environment": to_container.capitalize()
+                }
+                
+                url=self._get_deployments_url(container_asset_id,asset_container_id,operation="modelput")
+                response = requests.put(url,data=json.dumps(body), headers=self._get_headers())
+                if response.status_code == 200:
+                    _logger.info("Asset successfully moved from {} to {} environment".format(from_container,to_container))
+                else:
+                    raise ClientError("Asset movement failed. ERROR {}. {}".format(response.status_code,response.text))
         else:
             validate_enum(from_container,"from_container", ModelEntryContainerType, True)
             validate_enum(to_container,"to_container", ModelEntryContainerType, True)
 
             container_asset_id=self._asset_id
             asset_container_type=self._container_type
             asset_container_id=self._container_id
@@ -1450,16 +1481,16 @@
             :param str file_to_upload: Attachment file path to upload
             :param str description: Description about the attachment file
             :param str fact_id: Fact id for the attachment
             :param str html_rendering_hint: (Optional) html rendering hint. Available options are in :func:`~ibm_aigov_facts_client.utils.enums.RenderingHints`
 
             A way to use me is:
 
-            >>> model.set_attachment_fact(fileToUpload="./artifacts/image.png",description=<file description>,fact_id=<custom fact id>)
-            >>> model.set_attachment_fact(fileToUpload="./artifacts/image.png",description=<file description>,fact_id=<custom fact id>,html_rendering_hint=<render hint>)
+            >>> model.set_attachment_fact(file_to_upload="./artifacts/image.png",description=<file description>,fact_id=<custom fact id>)
+            >>> model.set_attachment_fact(file_to_upload="./artifacts/image.png",description=<file description>,fact_id=<custom fact id>,html_rendering_hint=<render hint>)
 
         """
         
         if self._is_cp4d and self._cp4d_version < "4.6.5":
             raise ClientError("Version mismatch: Attachment functionality is only supported in CP4D version 4.6.5 or higher. Current version of CP4D is "+self._cp4d_version)
 
         model_asset_id=self._asset_id
@@ -1490,14 +1521,26 @@
 
             attachment_url=self._get_url_attachments(model_asset_id,model_container_type,model_container_id)
 
             #base_filename = os.path.basename(file_to_upload)
             base_filename_before = os.path.basename(file_to_upload)
             base_filename = base_filename_before.replace(" ","_")
 
+            if html_rendering_hint==RenderingHints.INLINE_HTML:
+                htmlparser = FactHTMLParser()
+                html_file = open(file_to_upload, 'r')
+                html_content = html_file.read()
+                htmlparser.feed(html_content)
+                htmlparser.close()
+                restricted_tags = "style istyle css"
+                # checking if any of the above restricted_tags values in html tags
+                contains_restricted_tag = any(item in restricted_tags for item in htmlparser.start_tags)
+                if contains_restricted_tag:
+                    raise ClientError("Invalid inline HTML content: Attachments content to be rendered as inline_html is NOT allowed to contain any of the following HTML tags:{}".format(list(restricted_tags.split(" "))))
+
             # convert png to jpeg
             flag=False
             if mimetype=="image/png":
                 from PIL import Image
 
                 ima=Image.open(file_to_upload)
                 rgb_im = ima.convert('RGB')
@@ -2037,14 +2080,16 @@
         return url
     
     
     def _get_fact_definition_properties(self,fact_id):
         props_by_id=None
         props_by_id_op=None
         
+        self._facts_definitions=self._get_fact_definitions()
+        
         if self._facts_definitions and self._facts_definitions_op:
             props=self._facts_definitions.get(PROPERTIES)
             props_by_id=props.get(fact_id)
             props_op=self._facts_definitions_op.get(PROPERTIES)
             props_by_id_op=props_op.get(fact_id)
 
         elif self._facts_definitions and not self._facts_definitions_op:
@@ -2311,7 +2356,470 @@
             url += "&response-content-disposition=attachment;filename=" + filename
 
         response=requests.get(url, headers=self._get_headers())
         download_url = response.json().get("url")
         return download_url
 
 
+    def _finalVersion(self,versionList: list=None):
+
+        splitVersion = []
+        FinalVersionList = []
+        convertFromString = []
+        for version in versionList:
+            splitVersion.append(version.split("."))
+        for splitVal in splitVersion:
+            splitVal = list(map(int, splitVal))
+            convertFromString.append(splitVal)
+        sortedVersion = sorted(convertFromString)    
+        for combineSortedVal in sortedVersion:
+            combineSortedVal = '.'.join(str(sortedVal) for sortedVal in combineSortedVal)
+            FinalVersionList.append(combineSortedVal)
+        return FinalVersionList
+
+    def _increment_ver(self,version,releaseVal):
+
+        version = version.split('.')
+        if releaseVal == "major":
+            version[0] = str(int(version[0]) + 1)
+        elif releaseVal == "minor":
+            version[1] = str(int(version[1]) + 1)
+        elif releaseVal == "patch":
+            version[2] = str(int(version[2]) + 1)
+        return '.'.join(version)
+
+    def track(self,model_usecase:ModelUsecaseUtilities=None,approach:ApproachUtilities=None,grc_model:dict=None, version_number:str=None, version_comment:str=None):
+        
+        """
+            Link Model to model use case. Model asset should be stored in either Project or Space and corrsponding ID should be provided when registering to model use case. 
+            
+            Supported for CPD version >=4.7.0
+
+            :param ModelUsecaseUtilities model_usecase: Instance of ModelUsecaseUtilities
+            :param ApproachUtilities approach: Instance of ApproachUtilities
+            :param str grc_model: (Optional) Openpages model id. Only applicable for CPD environments. This should be dictionary, output of get_grc_model()
+            :param str version_number: Version number of model. supports either a semantic versioning string or one of the following keywords for auto-incrementing based on the latest version in the approach: "patch", "minor", "major"
+            :param str version_comment: (Optional) An optional comment describing the changes made in this version
+
+            :rtype: ModelAssetUtilities
+
+            For tracking model with model usecase:
+
+            >>> model.track(model_usecase=<instance of ModelUsecaseUtilities>,approach=<instance of ApproachUtilities>,version_number=<version>)
+            
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.6.5":
+            raise ClientError("Version mismatch: Track model with model usecase and approach functionality is only supported in CP4D version 4.6.5 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        if (model_usecase is None or model_usecase == ""):
+            raise MissingValue("model_usecase", "ModelUsecaseUtilities object or instance is missing")
+        
+        if ( not isinstance(model_usecase, ModelUsecaseUtilities)):
+            raise ClientError("Provide ModelUsecaseUtilities object for model_usecase")
+
+        if (approach is None or approach == ""):
+            raise MissingValue("approach", "ApproachUtilities object or instance is missing")
+        
+        if ( not isinstance(approach, ApproachUtilities)):
+            raise ClientError("Provide ApproachUtilities object for approach")
+
+        if (version_number is None or version_number == ""):
+            raise MissingValue("version_number", "version number is missing")
+
+        model_asset_id=self._asset_id
+        container_type=self._container_type
+        container_id=self._container_id
+        
+        params={}
+        payload={}
+        version_details={}
+        
+        params[container_type +'_id']=container_id
+        
+        model_usecase_id = model_usecase.get_id()
+        model_usecase_catalog_id = model_usecase.get_container_id()
+
+        approach_id = approach.get_id()
+
+        approachVersionList = approach.get_versions()
+        versionList = []
+        for version in approachVersionList:
+            #version["number"]
+            versionList.append(version["number"])
+        finalVersionValList = self._finalVersion(versionList)
+        finalVersionVal = finalVersionValList[-1]
+
+        if grc_model and not self._is_cp4d:
+            raise WrongParams ("grc_model is only applicable for Openpages enabled CPD platform")
+
+        payload['model_entry_catalog_id']=model_usecase_catalog_id or self._assets_client._get_pac_catalog_id()
+        payload['model_entry_asset_id']=model_usecase_id
+
+        version_details['approach_id']=approach_id
+
+        if version_comment:
+            version_details['comment']=version_comment
+
+        if version_number in ["major","minor","patch"]:
+            finalVersionVal = self._increment_ver(finalVersionVal,version_number)
+        else:
+            finalVersionVal = version_number
+
+        version_details['number']=finalVersionVal
+
+        payload['version_details'] = version_details
+        
+        wkc_register_url=WKC_MODEL_REGISTER.format(model_asset_id)
+
+        if grc_model:
+            payload['grc_model_id']=grc_model.get('GrcModel').get('id')
+
+        if self._is_cp4d:            
+            url = self._cpd_configs["url"] + wkc_register_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + wkc_register_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + wkc_register_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + wkc_register_url
+
+        if model_usecase_id:
+            _logger.info("Initiate linking model to existing model use case {}".format(model_usecase_id))
+        else:
+            _logger.info("Initiate linking model to new model use case......")
+        
+        response = requests.post(url,
+                                headers=self._get_headers(),
+                                params=params,
+                                data=json.dumps(payload))
+
+        if response.status_code == 200:
+            _logger.info("Successfully finished linking Model {} to model use case".format(model_asset_id))
+        else:
+            error_msg = u'Model registration failed'
+            reason = response.text
+            _logger.info(error_msg)
+            raise ClientError(error_msg + '. Error: ' + str(response.status_code) + '. ' + reason)
+
+        return response.json()
+
+
+    def untrack(self):
+
+        """
+            Unlink model from it's usecase and approach
+
+            Example for IBM Cloud or CPD:
+
+            >>> model.untrack()
+
+        """
+
+        wkc_unregister_url=WKC_MODEL_REGISTER.format(self._asset_id)
+
+        params={}
+        params[self._container_type +'_id']=self._container_id
+
+        if self._is_cp4d:
+            url = self._cpd_configs["url"] + \
+                 wkc_unregister_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + \
+                wkc_unregister_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + \
+                    wkc_unregister_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + \
+                    wkc_unregister_url
+        
+        response = requests.delete(url,
+                                headers=self._get_headers(),
+                                params=params,
+                                )
+
+        if response.status_code == 204:
+            _logger.info("Successfully finished unregistering WKC Model {} from model use case.".format(self._asset_id))
+        else:
+            error_msg = u'WKC model use case unregistering failed'
+            reason = response.text
+            _logger.info(error_msg)
+            raise ClientError(error_msg + '. Error: ' + str(response.status_code) + '. ' + reason)
+
+
+    def get_version(self)->Dict:
+
+        """
+            Get model version details. Supported for CPD version >=4.7.0
+
+            :rtype: dict
+
+            The way to use me is:
+
+            >>> get_model.get_version()
+
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.7.0":
+            raise ClientError("Version mismatch: Model version functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        url=self._get_assets_url(self._asset_id,self._container_type,self._container_id)
+        response = requests.get(url, headers=self._get_headers())
+        if response.status_code==200:
+                model_version_details={}
+
+                if "model_version" in (response.json()["entity"]["wml_model"]):
+                    model_version=response.json()["entity"]["wml_model"]["model_version"].get("number")
+                    model_version_comment=response.json()["entity"]["wml_model"]["custom"].get("version_comment")
+
+                    model_version_details["number"]=model_version
+                    model_version_details["comment"]=model_version_comment
+
+                    _logger.info("Model version details retrieved successfully")
+                    return model_version_details
+        else:
+                raise ClientError("Failed to retrieve model version details information. ERROR {}. {}".format(response.status_code,response.text))
+
+
+    def get_name(self)->str:
+
+        """
+            Returns model name
+            
+            :return: Model name
+            :rtype: str
+
+            Example:
+            >>> get_model.get_name()
+
+        """
+
+        return self.get_info(True).get("name")
+    
+    def get_id(self)->str:
+
+        """
+            Returns model ID
+            
+            :return: Model ID
+            :rtype: str
+
+            Example:
+            >>> get_model.get_id()
+
+        """
+
+        return self.get_info(True).get("asset_id")
+
+    def get_container_id(self)->str:
+
+        """
+            Returns model container ID
+            
+            :return: Model container ID
+            :rtype: str
+
+            Example:
+            >>> get_model.get_container_id()
+
+        """
+
+        return self.get_info(True).get("container_id")
+    
+    def get_container_type(self)->str:
+
+        """
+            Returns model container type
+            
+            :return: Model container type
+            :rtype: str
+
+            Example:
+            >>> get_model.get_container_type()
+
+        """
+
+        return self.get_info(True).get("container_type")
+
+    def get_description(self)->str:
+
+        """
+            Returns model description
+            
+            :return: Model description
+            :rtype: str
+
+            Example:
+            >>> get_model.get_description()
+
+        """
+
+        return self.get_info(True).get("description")
+
+
+    def _encode_id(self,id):
+        encoded_id=hashlib.md5(id.encode("utf-8")).hexdigest()
+        return encoded_id
+
+    def get_deployments(self)->List:
+         
+        """
+            Get all deployment details for the external model. Supported for CPD version >=4.7.0
+
+            :return: All deployment details for external model
+            :rtype: list(Deployment)
+
+            The way to use me is:
+            >>> get_model.get_deployments()
+
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.7.0":
+            raise ClientError("Version mismatch: Retrieving external model deployments functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        model_asset_id=self._asset_id
+        container_type=self._container_type
+        container_id=self._container_id
+
+        url=self._get_deployments_url(model_asset_id,container_id,operation="get")
+
+        response = requests.get(url, headers=self._get_headers())
+
+        if response.status_code ==200:
+            _logger.info("Deployments retrieved successfully")
+            deployment_list = response.json()["deployment_details"]
+            deployment_list_values = []
+            for deployment in deployment_list:
+                deployment_list_values.append(Deployment(self,deployment.get('id'),deployment.get('name'),deployment.get('type'),deployment.get('scoring_endpoint'),deployment.get('external_identifier'),deployment.get('is_deleted'),deployment.get('description'),model_asset_id,self.get_name(),container_type,container_id))
+            return deployment_list_values
+        else:
+            raise ClientError("Failed in retrieving deployments. ERROR {}. {}".format(response.status_code,response.text))
+
+
+    def delete_deployments(self,deployment_ids:list=None):
+
+        """
+            Returns Delete the deployments in external model. Supported for CPD version >=4.7.0
+            
+            :param list deployment_ids: List of deployment ID's to be deleted. Provide deployment_ids in a list.
+            
+            :rtype: None
+
+            :return: External model deployments are deleted.
+            
+            The way to use me is:
+            >>> get_model.delete_deployments([deployment_ids])
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.7.0":
+            raise ClientError("Version mismatch: Deleting external model deployments functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        model_asset_id=self._asset_id
+        container_type=self._container_type
+        container_id=self._container_id
+
+        if (isinstance(deployment_ids, list)) and (deployment_ids is not None and len(deployment_ids)>0):
+            for deployment_id in deployment_ids:
+                url=self._get_deployments_url(model_asset_id,container_id,deployment_id,operation="delete")
+                response = requests.delete(url, headers=self._get_headers())
+                if response.status_code ==204:
+                    _logger.info("Deployment "+ deployment_id +" deleted successfully")
+                else:
+                    raise ClientError("Failed in deleting deployment {}. ERROR {}. {}".format(deployment_id,response.status_code,response.text))
+        else:
+            raise MissingValue("deployment_ids", "Missing list of deployment_ids")
+
+
+    def add_deployments(self,deployments:list=None)->list:
+
+        """
+            Returns Add deployments in external model. Supported for CPD version >=4.7.0
+            
+            :param list deployments: List of deployments to be added. Provide deployments in a list.
+            
+            :rtype: list(Deployment)
+
+            :return: External model deployments are added
+            
+            The way to use me is:
+            >>> get_model.add_deployments([{"id":"<id>","name":"<name>","type":"<type>","scoring_endpoint":"<scoring_endpoint>","description":"<description>"}])
+
+        """
+
+        if self._is_cp4d and self._cp4d_version < "4.7.0":
+            raise ClientError("Version mismatch: Adding deployments for external model functionality is only supported in CP4D version 4.7.0 or higher. Current version of CP4D is "+self._cp4d_version)
+
+        model_asset_id=self._asset_id
+        container_type=self._container_type
+        container_id=self._container_id
+
+        if (isinstance(deployments, list)) and (deployments is not None and len(deployments)>0):
+            failed_deployments = []
+            deployments_response =[]
+            for deployment in deployments:
+                deployment_identifier = deployment.get('id')
+                name = deployment.get('name')
+                type = deployment.get('type')
+                scoring_endpoint = deployment.get('scoring_endpoint')
+                description = deployment.get('description')
+
+                if (deployment_identifier is None or deployment_identifier == ""):
+                    raise MissingValue("id", "ID is missing")
+                if (name is None or name == ""):
+                    raise MissingValue("name", "name is missing")
+
+                id = self._encode_id(deployment_identifier)        
+
+                body={
+                        "id": id,
+                        "external_identifier": deployment_identifier,
+                        "name": name,
+                        "type": type,
+                        "scoring_endpoint": scoring_endpoint,
+                        "description": description
+                    }
+                final_body = {k: v for (k, v) in body.items() if v is not None}
+
+                url=self._get_deployments_url(model_asset_id,container_id,operation="add")
+                response = requests.put(url,data=json.dumps(final_body), headers=self._get_headers())
+        
+                if response.status_code ==200:
+                    _logger.info("Deployment added successfully to an external model")
+                    deployments_response.append(Deployment(self,id,name,type,scoring_endpoint,deployment_identifier,"false",description,model_asset_id,self.get_name(),container_type,container_id))
+
+                else:
+                    failed_deployments.append(response.text)
+            if len(deployments_response)>0:
+                return deployments_response
+
+            if len(failed_deployments)>0:
+                raise ClientError("Failed while adding deployment to an external model. ERROR {}".format(failed_deployments))
+        else:
+            raise MissingValue("deployments", "Missing deployments as a list of dictionary values.")
+
+    def _get_deployments_url(self,model_asset_id:str=None,catalog_id:str=None,deployment_id:str=None,operation:str=None):
+        
+        if operation == 'add':
+            append_url = '/v1/aigov/model_inventory/models/' + model_asset_id + '/deployments?catalog_id='+ catalog_id
+        elif operation == 'get':
+            append_url = '/v1/aigov/model_inventory/models/' + model_asset_id + '/deployments?catalog_id='+ catalog_id
+        elif operation == 'delete':
+            append_url = '/v1/aigov/model_inventory/models/' + model_asset_id + '/deployments/'+ deployment_id + '?catalog_id='+ catalog_id
+        elif operation == 'modelput':
+            append_url = '/v1/aigov/model_inventory/models/' + model_asset_id + '/environment?catalog_id=' + catalog_id
+        else:
+            append_url = ""
+        
+        if self._is_cp4d:
+            url = self._cpd_configs["url"] + append_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + append_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + append_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + append_url
+
+        return url
```

## ibm_aigov_facts_client/factsheet/asset_utils_runs.py

```diff
@@ -9,15 +9,15 @@
 from typing import Optional
 
 from typing import BinaryIO, Dict, List, TextIO, Union,Any
 from ibm_aigov_facts_client.factsheet import assets 
 from ibm_cloud_sdk_core.authenticators import IAMAuthenticator,CloudPakForDataAuthenticator
 from ibm_aigov_facts_client.utils.enums import AssetContainerSpaceMap, AssetContainerSpaceMapExternal,ContainerType, FactsType, ModelEntryContainerType, AllowedDefinitionType,FormatType, RenderingHints
 from ibm_aigov_facts_client.utils.utils import validate_enum,validate_type,STR_TYPE
-from ibm_aigov_facts_client.factsheet.asset_utils_me import ModelEntryUtilities
+from ibm_aigov_facts_client.factsheet.asset_utils_me import ModelUsecaseUtilities
 from ibm_cloud_sdk_core.utils import  convert_model
 
 
 from ibm_aigov_facts_client.utils.config import *
 from ibm_aigov_facts_client.utils.client_errors import *
 from ibm_aigov_facts_client.utils.constants import *
 from ibm_aigov_facts_client.utils.metrics_utils import convert_metric_value_to_float_if_possible
```

## ibm_aigov_facts_client/factsheet/assets.py

```diff
@@ -12,23 +12,23 @@
 
 
 from ..utils.client_errors import *
 from typing import BinaryIO, Dict, List,Any,Sequence
 
 from ibm_aigov_facts_client.client import fact_trace
 from ibm_aigov_facts_client.factsheet.asset_utils_model import ModelAssetUtilities
-from ibm_aigov_facts_client.factsheet.asset_utils_me import ModelEntryUtilities
-from ibm_aigov_facts_client.utils.enums import AssetContainerSpaceMap, AssetContainerSpaceMapExternal,ContainerType, FactsType, ModelEntryContainerType, AllowedDefinitionType,FormatType
+from ibm_aigov_facts_client.factsheet.asset_utils_me import ModelUsecaseUtilities
+from ibm_aigov_facts_client.utils.enums import AssetContainerSpaceMap, AssetContainerSpaceMapExternal,ContainerType, FactsType, ModelEntryContainerType, AllowedDefinitionType,FormatType,AttachmentFactDefinitionType
 from ibm_cloud_sdk_core.authenticators import IAMAuthenticator,CloudPakForDataAuthenticator
 
 from ibm_aigov_facts_client.utils.utils import validate_enum,validate_type,STR_TYPE
 from ibm_aigov_facts_client.utils.me_containers_meta import AssetsContainersDefinitions
 from ibm_aigov_facts_client.utils.constants import *
 from ibm_aigov_facts_client.utils.config import *
-
+from ibm_aigov_facts_client.utils.doc_annotations import deprecated
 
 _logger = logging.getLogger(__name__) 
 
 class Assets:
     
     def __init__(self, facts_client: 'fact_trace.FactsClientAdapter'):
         self._container_type= facts_client._container_type
@@ -176,18 +176,21 @@
 
 
         validate_enum(container_type,"container_type", ContainerType, False)
 
         if not self._external_model and model_id and container_type and container_id:
             url=self._get_assets_url(model_id,container_type,container_id)
             response = requests.get(url, headers=self._get_headers())
-            get_type=response.json()["metadata"][ASSET_TYPE_TAG]
+            if response.status_code==200:
+                get_type=response.json()["metadata"][ASSET_TYPE_TAG]
 
-            if get_type==EXT_MODEL:
-                self._external_model=True
+                if get_type==EXT_MODEL:
+                    self._external_model=True
+            else:
+                raise ClientError("Provide correct details for retrieving a model")
 
         if not self._external_model and container_type==ContainerType.CATALOG:
             raise ClientError("Container type should be `space` or `project` for non-external models")
 
         if self._external_model:
             self._asset_id=model_id
             self._container_type=container_type or MODEL_USECASE_CONTAINER_TYPE_TAG
@@ -232,47 +235,50 @@
             else:
                 raise ClientError("Asset information not found for model id {}. ERROR {}. {}".format(self._asset_id,response.status_code,response.text))
         else:
             raise ClientError("Could not get current model {}".format(self._current_model.to_dict()))
 
         return self._current_model
     
-    def get_model_usecase(self, model_usecase_id: str,catalog_id:str=None)->ModelEntryUtilities:
+    def get_model_usecase(self, model_usecase_id: str,catalog_id:str=None)->ModelUsecaseUtilities:
 
         """
             Get model usecase asset.
 
             :param str model_usecase_id: Id of the model usecase.
-            :param str catalog_id: (Optional) Id of the catalog where model usecase is saved. If not provided, uses available platform asset catalog id.
+            :param str catalog_id: Id of the catalog where model usecase is saved.
 
-            :rtype: ModelEntryUtilities
+            :rtype: ModelUsecaseUtilities
             
             The way to use me is:
             
             >>> client.assets.get_model_usecase(model_usecase_id=<model usecase id>, catalog_id=<catalog id>)
         
         """
 
-        if model_usecase_id=="" or catalog_id=="":
-            raise ClientError("Model usecase id or catalog id can not be an empty value")
+        if (model_usecase_id is None or model_usecase_id == ""):
+            raise MissingValue("model_usecase_id", "model usecase asset ID is missing")
+        if (catalog_id is None or catalog_id == ""):
+            raise MissingValue("catalog_id", "Catalog ID is missing")
 
         self._facts_type=FactsType.MODEL_USECASE_USER
-        catalog_id=catalog_id or self._get_pac_catalog_id()
-
-        if not catalog_id:
-            raise ClientError("Catalog id is not provided and no platform asset catalog found to use as default. Please provide a valid catalog id for used model usecase")
+        #catalog_id=catalog_id or self._get_pac_catalog_id()
+        catalog_id=catalog_id
+        
+        #if not catalog_id:
+        #    raise ClientError("Catalog id is not provided and no platform asset catalog found to use as default. Please provide a valid catalog id for used model usecase")
 
         if model_usecase_id and catalog_id:
             url=self._get_assets_url(model_usecase_id,MODEL_USECASE_CONTAINER_TYPE_TAG,catalog_id)
             response = requests.get(url, headers=self._get_headers())
             
             if response.status_code==404:
                 raise ClientError ("Invalid model usecase id or catalog id. ERROR {}. {}".format(response.status_code,response.text))
             elif response.status_code==200:
-                self._current_model_usecase= ModelEntryUtilities(self,model_usecase_id=model_usecase_id,container_type=MODEL_USECASE_CONTAINER_TYPE_TAG,container_id=catalog_id,facts_type=self._facts_type)
+                self._current_model_usecase= ModelUsecaseUtilities(self,model_usecase_id=model_usecase_id,container_type=MODEL_USECASE_CONTAINER_TYPE_TAG,container_id=catalog_id,facts_type=self._facts_type)
                 _logger.info("Current model usecase information: {}".format(self._current_model_usecase.to_dict()))
                 return self._current_model_usecase
             else:
                 raise ClientError("Model usecase information is not found. ERROR {}. {}".format(response.status_code,response.text))
 
     def remove_asset(self,asset_id:str,container_type:str=None,container_id:str=None):
         """Remove a model or model usecase asset
@@ -304,15 +310,15 @@
 
         if response.status_code==204:
             _logger.info("Successfully deleted asset id {} in {} {}".format(asset_id,container_type,container_id))
         else:
             raise ClientError("Failed to delete asset {}. ERROR {}. {}".format(asset_id,response.status_code,response.text))
 
     
-
+    @deprecated(alternative="client.assets.get_model_usecases()")
     def list_model_usecases(self, catalog_id:str=None)-> list:
         
         """
             Returns WKC Model usecase assets
 
             :param str catalog_id: Catalog ID where registered model usecase. if not provided, dafault shows all model usecases in all catalogs across all accounts to which the user has access.
             
@@ -689,13 +695,189 @@
                     '/v2/assets/' + asset_id + '?'+ container_type + '_id=' + container_id
             else:
                 url = prod_config["DEFAULT_SERVICE_URL"] + \
                     '/v2/assets/' + asset_id + '?'+ container_type + '_id=' + container_id
         return url
 
 
+    
+    def create_model_usecase(self,catalog_id:str=None,name:str=None,description:str=None)-> ModelUsecaseUtilities:
+
+        """
+            Returns WKC Model usecase
+
+            :param str catalog_id:  Catalog ID where this model usecase needs to create.
+            :param str name: Name of model usecase
+            :param str description: (Optional) Model usecase description
+
+            :rtype: ModelUsecaseUtilities
+
+            :return: WKC Model usecase asset
+            
+            Example:
+
+            >>> client.assets.create_model_usecase(catalog_id=<catalog_id>,name=<model usecase name>,description=<model usecase description>)
+
+        """
+
+        if (catalog_id is None or catalog_id == ""):
+            raise MissingValue("catalog_id", "catalog ID is missing")
+        if (name is None or name == ""):
+            raise MissingValue("name", "Model usecase name is missing")
+
+        if catalog_id:
+            validate_type(catalog_id, u'catalog_id', STR_TYPE, True)
+        
+        if name:
+            body={
+                    "name": name,
+                    "description": description
+                }
+        else:
+            raise ClientError("Provide model usecase name")
+
+        url=self._get_create_usecase_url(catalog_id)
+
+        response = requests.post(url,data=json.dumps(body), headers=self._get_headers())
+        
+        if response.status_code ==201:
+            _logger.info("Model usecase created successfully")
+            retResponse = response.json()
+            retrieved_catalog_id = retResponse["metadata"]["catalog_id"]
+            retrieved_asset_id = retResponse["metadata"]["asset_id"]
+            self._current_model_usecase = ModelUsecaseUtilities(self,model_usecase_id=retrieved_asset_id,container_type=MODEL_USECASE_CONTAINER_TYPE_TAG,container_id=retrieved_catalog_id)
+            return self._current_model_usecase
+        else:
+            raise ClientError("Failed while creating model usecase. ERROR {}. {}".format(response.status_code,response.text))
+
+    def _get_create_usecase_url(self,catalog_id:str=None):
+        
+        usecase_url = '/v1/aigov/model_inventory/model_entries?catalog_id=' + catalog_id
+
+        if self._is_cp4d:
+            url = self._cpd_configs["url"] + usecase_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + usecase_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + usecase_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + usecase_url
+        return url
+
+
+
+    def get_model_usecases(self, catalog_id:str=None)-> list:
+        
+        """
+            Returns WKC Model usecase assets
+
+            :param str catalog_id:  (Optional) Catalog ID where model usecase are registered. if not provided, dafault shows all model usecases in all catalogs across all accounts to which the user has access.
+            
+            :rtype: list(ModelUsecaseUtilities)
+
+            :return: All WKC Model usecase assets for a catalog
+
+            Example:
+
+            >>> client.assets.get_model_usecases(catalog_id=<catalog_id>)
+            >>> client.assets.get_model_usecases()
+
+        """
+
+        if catalog_id:
+            validate_type(catalog_id, u'catalog_id', STR_TYPE, True)
+            list_url=WKC_MODEL_LIST_FROM_CATALOG.format(catalog_id)
+        else:
+            list_url=WKC_MODEL_LIST_ALL
+
+        if self._is_cp4d:
+            url=self._cpd_configs["url"] + list_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + list_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + list_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + list_url
+        
+        response = requests.get(url,headers=self._get_headers())
+
+        if response.status_code == 200:
+
+            usecase_list = response.json()["results"]
+            usecase_list_values = []
+            for usecaseVal in usecase_list:
+                retrieved_catalog_id = usecaseVal["metadata"]["catalog_id"]
+                retrieved_asset_id = usecaseVal["metadata"]["asset_id"]
+                usecase_list_values.append(ModelUsecaseUtilities(self,model_usecase_id=retrieved_asset_id,container_type=MODEL_USECASE_CONTAINER_TYPE_TAG,container_id=retrieved_catalog_id))
+            _logger.info("Model usecases retrieved successfully")
+            return usecase_list_values
+        else:
+            error_msg = u'WKC Model Entries listing failed'
+            reason = response.text
+            _logger.info(error_msg)
+            raise ClientError(error_msg + '. Error: ' + str(response.status_code) + '. ' + reason)
+
+
+    def get_PAC_id(self)->str:
+
+        """
+            Get Platform Asset Catalog ( PAC ) ID.
+
+            :rtype: PAC ID
+            
+            The way to use me is:
+            
+            >>> client.assets.get_PAC_id()
+        
+        """
+
+        return self._get_pac_catalog_id()
+    
+
+
+    def get_attachment_definitions(self,type_name:str=None)->List:
+         
+        """
+            Get all attachment fact definitions for model or model_usecase. Supported for CPD version >=4.6.5
+
+            :return: All attachment fact definitions for model or model_usecase
+            :rtype: list()
+
+            The way to use me is:
+
+            >>> client.assets.get_attachment_definitions(type_name=<model or model_usecase>)
+
+        """
 
+        if self._is_cp4d and self._cp4d_version < "4.6.5":
+            raise ClientError("Version mismatch: Retrieving attachment fact definitions functionality is only supported in CP4D version 4.6.4.0 or higher. Current version of CP4D is "+self._cp4d_version)
 
+        validate_enum(type_name, "type_name", AttachmentFactDefinitionType, True)
+        
+        url=self._get_attachment_definitions_url(type_name)
 
+        response = requests.get(url, headers=self._get_headers())
+
+        if response.status_code ==200:
+            _logger.info("Attachment fact definitions retrieved successfully")
+            return response.json()
+        else:
+            raise ClientError("Failed in retrieving attachment fact definitions. ERROR {}. {}".format(response.status_code,response.text))
 
 
+    def _get_attachment_definitions_url(self,type_name:str=None):
+        
+        append_url = '/v1/aigov/factsheet/attachment_fact_definitions/' + type_name
+        
+        if self._is_cp4d:
+            url = self._cpd_configs["url"] + append_url
+        else:
+            if get_env() == 'dev':
+                url = dev_config["DEFAULT_DEV_SERVICE_URL"] + append_url
+            elif get_env() == 'test':
+                url = test_config["DEFAULT_TEST_SERVICE_URL"] + append_url
+            else:
+                url = prod_config["DEFAULT_SERVICE_URL"] + append_url
 
+        return url
```

## ibm_aigov_facts_client/factsheet/external_modelfacts_utility.py

```diff
@@ -27,15 +27,15 @@
 import ibm_aigov_facts_client._wrappers.requests as requests
 
 from ibm_cloud_sdk_core.authenticators import IAMAuthenticator,CloudPakForDataAuthenticator
 from ibm_aigov_facts_client.client import fact_trace
 from ibm_aigov_facts_client.utils.client_errors import *
 from ibm_aigov_facts_client.utils.enums import ContainerType
 from ibm_cloud_sdk_core.utils import convert_model
-from ibm_aigov_facts_client.supporting_classes.factsheet_utils import ExternalModelSchemas,TrainingDataReference,DeploymentDetails,ModelEntryProps
+from ibm_aigov_facts_client.supporting_classes.factsheet_utils import ExternalModelSchemas,TrainingDataReference,DeploymentDetails,ModelEntryProps,ModelDetails
 from .factsheet_utility import FactSheetElements
 from ibm_aigov_facts_client.utils.doc_annotations import deprecated, deprecated_param
 from typing import BinaryIO, Dict, List, TextIO, Union
 from ibm_aigov_facts_client.factsheet.assets import Assets
 from ibm_aigov_facts_client.factsheet.asset_utils_model import ModelAssetUtilities
 
 from ..utils.config import *
@@ -50,14 +50,16 @@
 
         self._facts_client=facts_client
         self.api_key=self._facts_client._api_key
         self.experiment_name = self._facts_client.experiment_name
         self.model_asset_id=None
         self.model_catalog_id=None
         self.is_cpd=self._facts_client._is_cp4d
+        self._external_model=self._facts_client._external
+
         if self.is_cpd:
             self.cpd_configs=convert_model(self._facts_client.cp4d_configs)
             self._cp4d_version=self._facts_client._cp4d_version
 
     def _encode_model_id(self,model_id):
         encoded_id=hashlib.md5(model_id.encode("utf-8")).hexdigest()
         return encoded_id
@@ -72,23 +74,38 @@
         else:
             payload["model_id"]= self._encode_model_id(payload["model_id"])
         if payload.get("deployment_details"):
             payload["deployment_details"]["id"]= self._encode_deployment_id(payload["deployment_details"]["id"])
 
         return payload
 
+    def _validate_payload_new(self, payload):
+        if not payload["model_id"] or not payload["name"]:
+            raise ClientError("model_identifier or name is missing")
+        else:
+            modelVal = payload["model_id"]
+            payload["model_id"]= self._encode_model_id(modelVal)
+            payload["external_model_identifier"]= modelVal
+        if payload.get("deployment_details"):
+            deploymentVal = payload["deployment_details"]["id"]
+            payload["deployment_details"]["id"]= self._encode_deployment_id(deploymentVal)
+            payload["deployment_details"]["external_identifier"]= deploymentVal
+
+        return payload
+
     @deprecated_param(alternative="save_external_model_asset().add_tracking_model_usecase() to create/link to model usecase",deprecated_args="model_entry_props") 
-    def save_external_model_asset(self, model_identifier:str, name:str, description:str=None, schemas:'ExternalModelSchemas'=None, training_data_reference:'TrainingDataReference'=None,deployment_details:'DeploymentDetails'=None,model_entry_props:'ModelEntryProps'=None,catalog_id:str=None)->ModelAssetUtilities:
-        
+    def save_external_model_asset(self, model_identifier:str, name:str, description:str=None, model_details:'ModelDetails'=None, schemas:'ExternalModelSchemas'=None, training_data_reference:'TrainingDataReference'=None,deployment_details:'DeploymentDetails'=None,model_entry_props:'ModelEntryProps'=None,catalog_id:str=None)->ModelAssetUtilities:
+
         """
         Save External model assets in catalog and (Optional) link to model usecase. By default external model is goig to save in Platform Asset Catalog ( PAC ), if user wants to save it to different catalog user has to pass catalog_id parameter.
 
         :param str model_identifier: Identifier specific to ML providers (i.e., Azure ML service: `service_id`, AWS Sagemaker:`model_name`)
         :param str name: Name of the model
         :param str description: (Optional) description of the model
+        :param ModelDetails model_details: (Optional) Model details.   Supported only after CP4D >= 4.7.0
         :param ExternalModelSchemas schemas: (Optional) Input and Output schema of the model
         :param TrainingDataReference training_data_reference: (Optional) Training data schema
         :param DeploymentDetails deployment_details: (Optional) Model deployment details
         :param ModelEntryProps model_entry_props: (Optional) Properties about model usecase and model usecase catalog.
         :param str catalog_id: (Optional) catalog id as external model can be saved in catalog itslef..
 
         :rtype: ModelAssetUtilities
@@ -135,20 +152,22 @@
 
             external_schemas=ExternalModelSchemas(input=input_schema,output=output_schema)
             trainingdataref=TrainingDataReference(schema=training_ref)
             deployment=DeploymentDetails(identifier=<service_url in Azure>,name="deploymentname",deployment_type="online",scoring_endpoint="test/score")
 
             client.external_model_facts.save_external_model_asset(model_identifier=<service_id in Azure>
                                                                         ,name=<model_name>
+                                                                        ,model_details=<model_stub_details>
                                                                         ,deployment_details=deployment
                                                                         ,schemas=external_schemas
                                                                         ,training_data_reference=tdataref)
 
             client.external_model_facts.save_external_model_asset(model_identifier=<service_id in Azure>
                                                                         ,name=<model_name>
+                                                                        ,model_details=<model_stub_details>
                                                                         ,deployment_details=deployment
                                                                         ,schemas=external_schemas
                                                                         ,training_data_reference=tdataref,
                                                                         ,catalog_id=<catalog_id>) Different catalog_id other than Platform Asset Catalog (PAC)
 
         AWS Sagemaker:
 
@@ -156,21 +175,23 @@
 
             external_schemas=ExternalModelSchemas(input=input_schema,output=output_schema)
             trainingdataref=TrainingDataReference(schema=training_ref)
             deployment=DeploymentDetails(identifier=<endpoint_name in Sagemaker>,name="deploymentname",deployment_type="online",scoring_endpoint="test/score")
 
             client.external_model_facts.save_external_model_asset(model_identifier=<model_name in Sagemaker>
                                                                         ,name=<model_name>
+                                                                        ,model_details=<model_stub_details>
                                                                         ,deployment_details=deployment
                                                                         ,schemas=external_schemas
                                                                         ,training_data_reference=tdataref)
 
 
             client.external_model_facts.save_external_model_asset(model_identifier=<model_name in Sagemaker>
                                                                         ,name=<model_name>
+                                                                        ,model_details=<model_stub_details>
                                                                         ,deployment_details=deployment
                                                                         ,schemas=external_schemas
                                                                         ,training_data_reference=tdataref,
                                                                         ,catalog_id=<catalog_id>) Different catalog_id other than Platform Asset Catalog (PAC)
 
         NOTE: 
 
@@ -205,25 +226,27 @@
         >>> props=ModelEntryProps(
                     model_entry_catalog_id=<catalog_id>,
                     model_entry_id=<model_entry_id to link>
                     )
 
         >>> client.external_model_facts.save_external_model_asset(model_identifier=<model_name in Sagemaker>
                                                                         ,name=<model_name>
+                                                                        ,model_details=<model_stub_details>
                                                                         ,deployment_details=deployment
                                                                         ,schemas=external_schemas
                                                                         ,training_data_reference=tdataref
                                                                         ,model_entry_props= props)
 
         Current and go forward suggested way:
 
         .. code-block:: python
 
             external_model=client.external_model_facts.save_external_model_asset(model_identifier=<service_id in Azure>
                                                                 ,name=<model_name>
+                                                                ,model_details=<model_stub_details>
                                                                 ,deployment_details=deployment
                                                                 ,schemas=external_schemas
                                                                 ,training_data_reference=tdataref)
             
         
         Create and link to new model usecase:
 
@@ -237,36 +260,89 @@
 
         >>> external_model.remove_tracking_model_usecase()
         
         """
         
         if catalog_id is not None and self.is_cpd and self._cp4d_version < "4.6.4":
             raise ClientError("Version mismatch: Saving external model to a catalog other than platform asset catalog (PAC) is only supported in CP4D version 4.6.4 or higher. Please remove catalog_id value to save in PAC. Current version of CP4D is "+self._cp4d_version)
-            
-        if deployment_details:
-            deployment_details=convert_model(deployment_details)
-        if schemas:
-            schemas=convert_model(schemas)
-        if training_data_reference:
-            training_data_reference=convert_model(training_data_reference)
-        if model_entry_props:
-            model_entry_props=convert_model(model_entry_props)
+        
+        if self.is_cpd and self._cp4d_version < "4.7.0":
+            if deployment_details:
+                deployment_details=convert_model(deployment_details)
+            if schemas:
+                schemas=convert_model(schemas)
+            if training_data_reference:
+                training_data_reference=convert_model(training_data_reference)
+            if model_entry_props:
+                model_entry_props=convert_model(model_entry_props)
+
+            data = {
+                'model_id': model_identifier,
+                'name': name,
+                'description': description,
+                'schemas': schemas,
+                'training_data_references': training_data_reference,
+                'deployment_details': deployment_details,
+                'catalog_id': catalog_id
+            }
+
+            data = {k: v for (k, v) in data.items() if v is not None}
+            _validated_payload= self._validate_payload(data)
+
+        if (self.is_cpd and self._cp4d_version >= "4.7.0") or (not self.is_cpd):
+            training_list = []
+            if model_details:
+                model_details=convert_model(model_details)
+            if deployment_details:
+                deployment_details=convert_model(deployment_details)
+            if schemas:
+                schemas=convert_model(schemas)
+            if training_data_reference:
+                training_data_reference=convert_model(training_data_reference)
+                                
+                if (training_data_reference.get('connection') is not None) or (training_data_reference.get('location') is not None):
+                    if (training_data_reference.get('type') is None) or (training_data_reference.get('id') is None):
+                        raise ClientError("As connection or location is specified type and ID are mandatory for training data reference")
+
+                training_list.append(training_data_reference)
+            if model_entry_props:
+                model_entry_props=convert_model(model_entry_props)
+        
+            if model_details:
+                data = {
+                    'model_id': model_identifier,
+                    'name': name,
+                    'description': description,
+                    'model_type': model_details.get('model_type'),
+                    'input_type': model_details.get('input_type'),
+                    'algorithm': model_details.get('algorithm'),
+                    'label_type': model_details.get('label_type'),
+                    'label_column': model_details.get('label_column'),
+                    'prediction_type': model_details.get('prediction_type'),
+                    'software_spec': model_details.get('software_spec'),
+                    'software_spec_id': model_details.get('software_spec_id'),
+                    'schemas': schemas,
+                    'training_data_references': training_list,
+                    'deployment_details': deployment_details,
+                    'catalog_id': catalog_id
+                }
+            else:
+                data = {
+                    'model_id': model_identifier,
+                    'name': name,
+                    'description': description,
+                    'schemas': schemas,
+                    'training_data_references': training_list,
+                    'deployment_details': deployment_details,
+                    'catalog_id': catalog_id
+                }
+
+            data = {k: v for (k, v) in data.items() if v is not None}
+            _validated_payload= self._validate_payload_new(data)
 
-               
-        data = {
-            'model_id': model_identifier,
-            'name': name,
-            'description': description,
-            'schemas': schemas,
-            'training_data_references': training_data_reference,
-            'deployment_details': deployment_details,
-            'catalog_id': catalog_id
-        }
-        data = {k: v for (k, v) in data.items() if v is not None}
-        _validated_payload= self._validate_payload(data) 
         self._publish(_validated_payload)
         
         if model_entry_props:
             if 'project_id' in model_entry_props or 'space_id' in model_entry_props:
                 raise WrongProps("project or space is not expected for external models")
 
             if 'asset_id' not in model_entry_props:
@@ -515,7 +591,9 @@
     def _get_headers(self):
         token = self._facts_client._authenticator.token_manager.get_token() if  ( isinstance(self._facts_client._authenticator, IAMAuthenticator) or (isinstance(self._facts_client.authenticator, CloudPakForDataAuthenticator))) else self._facts_client.authenticator.bearer_token
         iam_headers = {
             "Content-Type": "application/json",
             "Authorization": "Bearer %s" % token
         }
         return iam_headers 
+
+
```

## ibm_aigov_facts_client/supporting_classes/factsheet_utils.py

```diff
@@ -70,44 +70,88 @@
         return not self == other
 
 
 class TrainingDataReference:
     """
     Training data schema definition
 
+    :attr str type: Type of training data reference. It has values as fs, url, data_asset or connection_asset.
+    :attr str id: ID of training data reference.
+    :attr Dict connection: (Optional) Connection details
+    :attr Dict location: (Optional) Location details
     :attr Dict schema: Model training data schema
-    
-    """
-    def __init__(self,schema:Dict) -> None:
+
+    If type is fs, the parameters that user needs to input are - location.path
+    If type is url, the parameters that user needs to provide are - training_data_references[].id and connection.url
+    If type is data_asset, then - location.href
+    If type is connection_asset, then location.file_name or location.table_name, connection.href
+
+    """ 
+
+    def __init__(self, type: str=None, id: str=None, connection: Dict=None, location: Dict=None, schema:Dict=None) -> None:
         """
         Initialize a TrainingDataReference object.
 
+        :param str type: Model training data type
+        :param str id: Model training data id
+        :param Dict connection: (Optional) Model training data connection
+        :param Dict location: (Optional)  Model training data location
         :param Dict schema: Model training data schema
-        
+
         """
+
+        self.type = type
+        self.id = id
+        self.connection = connection
+        self.location = location
         self.schema = schema
 
     @classmethod
     def from_dict(cls, _dict: Dict) -> 'TrainingDataReference':
         """Initialize a TrainingDataReference object from a json dictionary."""
         args = {}
+
+        if 'type' in _dict:
+            args['type'] = _dict.get('type')
+        else:
+            raise ValueError('Required property \'type\' not present in TrainingDataReference JSON')
+        if 'id' in _dict:
+            args['id'] = _dict.get('id')
+        else:
+            raise ValueError('Required property \'id\' not present in TrainingDataReference JSON')
+        if 'connection' in _dict:
+            args['connection'] = _dict.get('connection')
+        else:
+            raise ValueError('Required property \'connection\' not present in TrainingDataReference JSON')
+        if 'location' in _dict:
+            args['location'] = _dict.get('location')
+        else:
+            raise ValueError('Required property \'location\' not present in TrainingDataReference JSON')
         if 'schema' in _dict:
             args['schema'] = _dict.get('schema')
         else:
             raise ValueError('Required property \'schema\' not present in TrainingDataReference JSON')
         return cls(**args)
 
     @classmethod
     def _from_dict(cls, _dict):
         """Initialize a TrainingDataReference object from a json dictionary."""
         return cls.from_dict(_dict)
 
     def to_dict(self) -> Dict:
         """Return a json dictionary representing this model."""
         _dict = {}
+        if hasattr(self, 'type') and self.type is not None:
+            _dict['type'] = self.type
+        if hasattr(self, 'id') and self.id is not None:
+            _dict['id'] = self.id
+        if hasattr(self, 'connection') and self.connection is not None:
+            _dict['connection'] = self.connection
+        if hasattr(self, 'location') and self.location is not None:
+            _dict['location'] = self.location
         if hasattr(self, 'schema') and self.schema is not None:
             _dict['schema'] = self.schema
         return _dict
 
     def _to_dict(self):
         """Return a json dictionary representing this model."""
         return self.to_dict()
@@ -130,36 +174,39 @@
     """
     External model deployment details
 
     :attr str identifier: Deployment identifier specific to providers.
     :attr str name: Name of the deployment
     :attr str deployment_type: Deployment type (i.e., online)
     :attr str scoring_endpoint: Deployment scoring endpoint url.  
-    
+    :attr str description: (Optional) Description of the deployment
+
     """
 
     def __init__(self,identifier: str,
                  name: str,
                  deployment_type: str,
-                 scoring_endpoint: str = None) -> None:
+                 scoring_endpoint: str = None, description: str = None) -> None:
         
         """
         Initialize a DeploymentDetails object.
 
         :param str identifier: Deployment identifier specific to ML providers
         :param str name: Name of the deployment
         :param str deployment_type: Deployment type (i.e., online)
-        :param str scoring_endpoint: Deployment scoring endpoint url.  
+        :param str scoring_endpoint: Deployment scoring endpoint url. 
+        :param str description: (Optional) Deployment description.
 
         """
         
         self.id = identifier
         self.name = name
         self.type = deployment_type
         self.scoring_endpoint = scoring_endpoint
+        self.description = description
 
 
     @classmethod
     def from_dict(cls, _dict: Dict) -> 'DeploymentDetails':
         """Initialize a DeploymentDetails object from a json dictionary."""
         args = {}
         if 'id' in _dict:
@@ -174,14 +221,18 @@
             args['type'] = _dict.get('type')
         else:
             raise ValueError('Required property \'type\' not present in DeploymentDetails JSON')
         if 'scoring_endpoint' in _dict:
             args['scoring_endpoint'] = _dict.get('scoring_endpoint')
         else:
             raise ValueError('Required property \'scoring_endpoint\' not present in DeploymentDetails JSON')
+        if 'description' in _dict:
+            args['description'] = _dict.get('description')
+        else:
+            raise ValueError('Required property \'description\' not present in DeploymentDetails JSON')
         return cls(**args)
 
     @classmethod
     def _from_dict(cls, _dict):
         """Initialize a DeploymentDetails object from a json dictionary."""
         return cls.from_dict(_dict)
 
@@ -192,14 +243,16 @@
             _dict['id'] = self.id
         if hasattr(self, 'name') and self.name is not None:
             _dict['name'] = self.name
         if hasattr(self, 'type') and self.type is not None:
             _dict['type'] = self.type
         if hasattr(self, 'scoring_endpoint') and self.scoring_endpoint is not None:
             _dict['scoring_endpoint'] = self.scoring_endpoint
+        if hasattr(self, 'description') and self.description is not None:
+            _dict['description'] = self.description
         return _dict
 
     def _to_dict(self):
         """Return a json dictionary representing this model."""
         return self.to_dict()
 
     def __str__(self) -> str:
@@ -352,8 +405,136 @@
         """Return `true` when self and other are equal, false otherwise."""
         if not isinstance(other, self.__class__):
             return False
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other: 'ModelEntryProps') -> bool:
         """Return `true` when self and other are not equal, false otherwise."""
+        return not self == other
+
+
+
+
+
+
+
+class ModelDetails:
+    """
+    External model model details
+
+    :attr str model_type: Value for model type
+    :attr str input_type: Value for inout type
+    :attr str algorithm: Value for algorithm
+    :attr str label_type: Value for label type
+    :attr str label_column: Value for label column
+    :attr str prediction_type: Value for prediction type
+    :attr str software_spec: Value for software_spec
+    :attr str software_spec_id: Value for software_spec_id
+    
+    """
+
+    def __init__(self,model_type: str=None,
+                 input_type: str=None,
+                 algorithm: str=None,
+                 label_type: str=None,
+                 label_column: str=None,
+                 prediction_type: str=None,
+                 software_spec: str=None,
+                 software_spec_id: str=None
+                 ) -> None:
+        
+        """
+        Initialize a ModelDetails object.
+
+        :param str model_type: Value for model type
+        :param str input_type: Value for inout type
+        :param str algorithm: Value for algorithm
+        :param str label_type: Value for label type
+        :param str label_column: Value for label column
+        :param str prediction_type: Value for prediction type
+        :param str software_spec: Value for software_spec
+        :param str software_spec_id: Value for software_spec_id
+
+        """
+        
+        self.model_type = model_type
+        self.input_type = input_type
+        self.algorithm = algorithm
+        self.label_type = label_type
+        self.label_column = label_column
+        self.prediction_type = prediction_type
+        self.software_spec = software_spec
+        self.software_spec_id = software_spec_id
+
+    @classmethod
+    def from_dict(cls, _dict: Dict) -> 'ModelDetails':
+        """Initialize a ModelDetails object from a json dictionary."""
+        args = {}
+        if 'model_type' in _dict:
+            args['model_type'] = _dict.get('model_type')
+
+        if 'input_type' in _dict:
+            args['input_type'] = _dict.get('input_type')
+
+        if 'algorithm' in _dict:
+            args['algorithm'] = _dict.get('algorithm')
+
+        if 'label_type' in _dict:
+            args['label_type'] = _dict.get('label_type')
+
+        if 'label_column' in _dict:
+            args['label_column'] = _dict.get('label_column')
+
+        if 'prediction_type' in _dict:
+            args['prediction_type'] = _dict.get('prediction_type')
+
+        if 'software_spec' in _dict:
+            args['software_spec'] = _dict.get('software_spec')
+
+        if 'software_spec_id' in _dict:
+            args['software_spec_id'] = _dict.get('software_spec_id')
+
+        return cls(**args)
+
+    @classmethod
+    def _from_dict(cls, _dict):
+        """Initialize a ModelDetails object from a json dictionary."""
+        return cls.from_dict(_dict)
+
+    def to_dict(self) -> Dict:
+        """Return a json dictionary representing this model."""
+        _dict = {}
+        if hasattr(self, 'model_type') and self.model_type is not None:
+            _dict['model_type'] = self.model_type
+        if hasattr(self, 'input_type') and self.input_type is not None:
+            _dict['input_type'] = self.input_type
+        if hasattr(self, 'algorithm') and self.algorithm is not None:
+            _dict['algorithm'] = self.algorithm
+        if hasattr(self, 'label_type') and self.label_type is not None:
+            _dict['label_type'] = self.label_type
+        if hasattr(self, 'label_column') and self.label_column is not None:
+            _dict['label_column'] = self.label_column
+        if hasattr(self, 'prediction_type') and self.prediction_type is not None:
+            _dict['prediction_type'] = self.prediction_type
+        if hasattr(self, 'software_spec') and self.software_spec is not None:
+            _dict['software_spec'] = self.software_spec
+        if hasattr(self, 'software_spec_id') and self.software_spec_id is not None:
+            _dict['software_spec_id'] = self.software_spec_id
+        return _dict
+
+    def _to_dict(self):
+        """Return a json dictionary representing this model."""
+        return self.to_dict()
+
+    def __str__(self) -> str:
+        """Return a `str` version of this ModelDetails object."""
+        return json.dumps(self.to_dict(), indent=2)
+
+    def __eq__(self, other: 'ModelDetails') -> bool:
+        """Return `true` when self and other are equal, false otherwise."""
+        if not isinstance(other, self.__class__):
+            return False
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other: 'ModelDetails') -> bool:
+        """Return `true` when self and other are not equal, false otherwise."""
         return not self == other
```

## ibm_aigov_facts_client/utils/cell_facts.py

```diff
@@ -1,11 +1,12 @@
 import os
 import logging
 import random
 import string
+import re
 import ibm_aigov_facts_client.factsheet as modelfacts
 from base64 import b64decode,b64encode
 from io import BytesIO
 from IPython import get_ipython
 from IPython.core import magic_arguments
 from IPython.core.magic import (Magics, cell_magic, magics_class)
 from IPython.display import display
@@ -26,14 +27,23 @@
     final_directory = os.path.join(current_directory, CELL_FACTS_TMP_DIR)
     if not os.path.exists(final_directory):
         os.makedirs(final_directory)
 
     file_path = os.path.join(final_directory, filename)
     return file_path
 
+def remove_tag(html, tag_name):
+    new_html = html.replace("\n", '')
+    regex_string = f'<{tag_name}[^>]*>\s*.*\s*<\/{tag_name}>'
+    regex = re.compile(rf'{regex_string}', re.IGNORECASE | re.MULTILINE)
+    # replace the matching patterns with an empty string
+    new_html = re.sub(regex, '', new_html)
+    return new_html
+
+
 @magics_class
 class CellFactsMagic(Magics):
     _fname=None
 
     @cell_magic
     @magic_arguments.magic_arguments()
 
@@ -46,20 +56,19 @@
 
     @magic_arguments.argument(
         "--capturecode",
         "-cc",
         action='store_true',
         help=("Defines whether to capture cell codes"),
     )
-    
+
     def capture_cell_facts(self, line, cell):
         args = magic_arguments.parse_argstring(CellFactsMagic.capture_cell_facts, line)
         stdout_only = args.printmsgonly
         cap_codes=args.capturecode
-
         
         fmt='''<div class="card"><img src="data:image/png;base64,{}"/><br>\n'''
         txt='''<pre> {} </pre> <br>\n'''
         t='''<p> {} </p> <br>\n'''
         tmp=[]
         
         CellFactsMagic._fname="Captured_Cell_Output_{}.html".format(randStr())
@@ -76,26 +85,24 @@
                 with open(output_filepath, 'w+') as fd:
                     if result.stdout is not None:
                         message=result.stdout
                         fmt_data="<br />".join(message.split("\n"))
                         if cap_codes:
                             fmt_cell="<br />".join(cell.split("\n"))
                             fd.write(t.format(fmt_cell))
-                        fd.write(t.format(fmt_data))
-                
+                        fd.write(t.format(fmt_data))  
         else:
             with capture_output(stdout=False, stderr=False, display=True) as result:
                 #self.shell.run_cell(cell)
                 get_ipython().run_cell(cell)
                 if result.outputs:
                     for output in result.outputs:
                         data = output.data
                         tmp.append(data)
 
-
             with open(output_filepath, 'w+') as fd:
                 if cap_codes:
                     fmt_cell="<br />".join(cell.split("\n"))
                     fd.write(t.format(fmt_cell))
 
                 for i in tmp:
                     if 'image/png' in i:
@@ -110,16 +117,17 @@
 
                     elif 'text/plain' in i and not 'text/html' in i:
                         txt_data = i['text/plain']
                         fd.write(txt.format(txt_data))
                     
                     elif 'text/plain' in i and 'text/html' in i:
                         tbl_data = i['text/html']
-                        fd.write(tbl_data)
+                        # removes style tag and it's content
+                        tmp_data = remove_tag(tbl_data,"style")
+                        fd.write(tmp_data)
                  
                     else:
                         fmt_data="<br />".join(i.split("\n"))
                         fd.write(t.format(fmt_data))
 
         _logger.info("Saved cell facts under: ")    
-        return output_filepath
-                       
+        return output_filepath
```

## ibm_aigov_facts_client/utils/enums.py

```diff
@@ -135,8 +135,17 @@
     FAILURE = "failure"
     FAILED = "failed"
     ERROR = "error"
     CANCELLED = "cancelled"
     CANCELED = "canceled"
 
 
+class AttachmentFactDefinitionType:
+    """
+        Describes possible Factsheet attachment definition types. Only MODEL_TYPE and MODEL_USECASE_TYPE are supported.
+        Contains: [MODEL_TYPE,MODEL_USECASE_TYPE]
 
+        - The model to list attachment fact definitions for all models defined.
+        - The model_usecase to list attachment fact definitions for all model usecases defined.
+    """
+    MODEL_TYPE = 'model'
+    MODEL_USECASE_TYPE = 'model_usecase'
```

## Comparing `ibm_aigov_facts_client-1.0.58.dist-info/LICENSE` & `ibm_aigov_facts_client-1.0.59.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `ibm_aigov_facts_client-1.0.58.dist-info/METADATA` & `ibm_aigov_facts_client-1.0.59.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: ibm-aigov-facts-client
-Version: 1.0.58
+Version: 1.0.59
 Summary: FactSheetService ML facts collection utility
 Author: IBM
 License: Apache 2.0
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: pandas
```

## Comparing `ibm_aigov_facts_client-1.0.58.dist-info/RECORD` & `ibm_aigov_facts_client-1.0.59.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -3,30 +3,33 @@
 ibm_aigov_facts_client/_wrappers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ibm_aigov_facts_client/_wrappers/requests.py,sha256=95J2SH9bh164jE8vaYHbLkhIKLw-HOYoYBU0jWESCFM,4784
 ibm_aigov_facts_client/base_classes/__init__.py,sha256=9aOqTJ9oRveYnVud0YuKcb43qpmvKYv8dRKp7WTmUlc,611
 ibm_aigov_facts_client/base_classes/auth.py,sha256=sU9ccxuW5UIdsyyKiePP83vLYm4oOODl2y_GmSOe1sw,9290
 ibm_aigov_facts_client/base_classes/common.py,sha256=rMb0P38RXz8KOeRAMkDmTUcp282KKDPvyA3xQE49NnY,1328
 ibm_aigov_facts_client/client/__init__.py,sha256=tXtafqdFW1Ana-dIyRv-aOgGsJYMia24PJjgU2PNq3I,776
 ibm_aigov_facts_client/client/autolog.py,sha256=DydYuy9xYbxf6pqqIQ57HnnFWRBlj-EP-z1BwqyfrrQ,3385
-ibm_aigov_facts_client/client/fact_trace.py,sha256=NInD0xeWU5aRNt1ri2BoyY2Eib4ev9Lr6RuUDTNgbFo,21931
+ibm_aigov_facts_client/client/fact_trace.py,sha256=3HqbvAuh2L3DsA-Ar5rRYTgoqjccetlrd7N4_mcLwyY,22372
 ibm_aigov_facts_client/client/manual_log.py,sha256=ia470HK9pgLR-qM-rTYBPLcj0jlPpf56o5Yokf1fpMs,8641
 ibm_aigov_facts_client/custom/__init__.py,sha256=cNZY0ZLMzgO-8Tm0oJjQ_IVjrxV3v3Vm7TugHUIUoP0,687
 ibm_aigov_facts_client/custom/custom_exp.py,sha256=aSl28JBgZv5DOb5fQJQwVawi5SeFQ4z5Z4fck1qJN_c,3437
 ibm_aigov_facts_client/custom/custom_file_store.py,sha256=v8geceTKc9bXp8MHpTU-XwrBsae_-cENkbuzd53O5qI,10081
 ibm_aigov_facts_client/export/__init__.py,sha256=LCZPbj8Q_fgFg_GL4lrzxblgwdc0BNgn7E71NMZTFPQ,606
 ibm_aigov_facts_client/export/export_facts.py,sha256=6AZ2ABrwO6qDO590U0RCX5RLCdBW7BiaDbUjECGLcWc,10861
 ibm_aigov_facts_client/export/export_facts_manual.py,sha256=duCGbIWTNIPkunZOWGDwQpRe1UgAJrz_J6nQ2gkkXFk,6155
 ibm_aigov_facts_client/factsheet/__init__.py,sha256=9aOqTJ9oRveYnVud0YuKcb43qpmvKYv8dRKp7WTmUlc,611
+ibm_aigov_facts_client/factsheet/approaches.py,sha256=2dRxLSWhfIsXIMXCJRnLDi1sBCLUInPqkd90cOHQTDo,16485
 ibm_aigov_facts_client/factsheet/asset_utils_experiments.py,sha256=xCgne8gYkxVtR-LOOFSlcLoAUGuAH3PUwiDj3hxwxnc,7516
-ibm_aigov_facts_client/factsheet/asset_utils_me.py,sha256=ulUUVbtkjGr6bNK_8lhMaAfynnppYN8D7GTJTEg1pZw,55454
-ibm_aigov_facts_client/factsheet/asset_utils_model.py,sha256=Gra-wrX_uNAXcKe_r5dgVcbe_RprNaIh2Lm2k7eOVxc,109357
-ibm_aigov_facts_client/factsheet/asset_utils_runs.py,sha256=hVo62QtWs2Q3ungmfDlncjqfAbcdin26X4nTgeKsxcU,40742
-ibm_aigov_facts_client/factsheet/assets.py,sha256=YaVPgM4qsYcBDFTV80bzpF2k7s19evzG2mh3uzDDuMc,31959
-ibm_aigov_facts_client/factsheet/external_modelfacts_utility.py,sha256=atSrimvs7UfXJgY60syDzUBHxMDn0bfIM9XKCDestJw,23474
+ibm_aigov_facts_client/factsheet/asset_utils_me.py,sha256=MR08RkGYcex7k7UzzmvSuEH5FcllL_bwDsnxR7SC0pQ,81044
+ibm_aigov_facts_client/factsheet/asset_utils_model.py,sha256=RHDz9LQprJ17JFwMTvqXmqqlX9qmQ5TOfnGuN6s6sBU,130668
+ibm_aigov_facts_client/factsheet/asset_utils_runs.py,sha256=vUcBU33EEDFOJnFt_JTElhz6b0F7mmVko2bXo5Ao3h4,40744
+ibm_aigov_facts_client/factsheet/assets.py,sha256=dysR60LmQJ3bWQ0IAYpWBWbuiIgPqwCvQx2EYd1R44c,39307
+ibm_aigov_facts_client/factsheet/external_deployments.py,sha256=SGWdOaK7NxFNdHl69XVsrmBG5M4pO3QCvAnKU2niEIY,21548
+ibm_aigov_facts_client/factsheet/external_modelfacts_utility.py,sha256=EdqAjWZmrKx9yTB0Opc3cl09RswkuT9W1pvLcwJj75o,27706
 ibm_aigov_facts_client/factsheet/factsheet_utility.py,sha256=R983WyX5mFrzlS8sb-M3vu16G6IS_OgMQ2FFdEfvTYY,27316
+ibm_aigov_facts_client/factsheet/html_parser.py,sha256=sUxhuOuMfgx0jN7xbOz1k9GLw3pwXLc8P0ei_c15h3o,250
 ibm_aigov_facts_client/store/__init__.py,sha256=YnDqKtutPdb5_7I7l9Q0vEBpIUp0amsXODyUR6W16qk,716
 ibm_aigov_facts_client/store/abstract_payload_manual.py,sha256=IIU7hUOb1UUYZwGor-MPtzTKcORjI4r-Y2Pz_NVLfhk,956
 ibm_aigov_facts_client/store/abstract_payload_store.py,sha256=qhi8HMVSvinNt4Kb6f-0ggGTVpFFCA5OrPpGXXi0u0I,946
 ibm_aigov_facts_client/store/autolog/__init__.py,sha256=9aOqTJ9oRveYnVud0YuKcb43qpmvKYv8dRKp7WTmUlc,611
 ibm_aigov_facts_client/store/autolog/autolog_utils.py,sha256=K_M6sg5-qYo6ls-FGIXbWdtLCi6B1eTGVKHrJQj8ue0,3419
 ibm_aigov_facts_client/store/autolog/bst_payload_store.py,sha256=Iwo1b-mnCaZrkqsJ-Wpg_c0eWG6o_8XlCPs3Xz0kzD4,4151
 ibm_aigov_facts_client/store/autolog/bst_payload_store_custom.py,sha256=-tXCNV4juL6inVYhrs28J8__EAEvjDi3kq8CzMNx0d8,4396
@@ -41,35 +44,35 @@
 ibm_aigov_facts_client/store/manual/dl_payload_manual.py,sha256=Q81-X6aCbHrcw78nivk4RDzuKwjYnlC7FUwEDXPKWFU,7402
 ibm_aigov_facts_client/store/manual/general_payload_manual.py,sha256=pS5efXez2mCbCnTTe6mZ55qG32gYGlgQKR5fm01JjuA,4965
 ibm_aigov_facts_client/store/manual/manuallog_utils.py,sha256=UF2yaEZHxUnmCI4Omlpx7KwAyX7E0jFyHjfahIMt-Bw,4774
 ibm_aigov_facts_client/store/manual/spark_payload_manual.py,sha256=EgvBmEp2FlS35ES6IFzF-7gUkz9VGGnAQlPihCRQ3_Y,4461
 ibm_aigov_facts_client/supporting_classes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ibm_aigov_facts_client/supporting_classes/cp4d_authenticator.py,sha256=ePi15EBKU5M41AHPIbWSLzdUMwdvVkJtAgTKQUKyu1Q,3483
 ibm_aigov_facts_client/supporting_classes/cp4d_token_manager.py,sha256=PcPN7Om0WKnwfZKE5_MDFDK-jopsnyrv5URlqWWotAU,5359
-ibm_aigov_facts_client/supporting_classes/factsheet_utils.py,sha256=_BQR7zv0-dkgM4umGmq4w9UBNtzo8ekYFqMkuiCd-wI,14856
+ibm_aigov_facts_client/supporting_classes/factsheet_utils.py,sha256=4kE-R19Y6hM4c1u6vDjHxhdW-0cNxMZyzWtuxbciNpY,22329
 ibm_aigov_facts_client/utils/__init__.py,sha256=qbJFIPsq8hj6APw91tjOpWVcgwldVjcdTW1NmoQMZMw,800
-ibm_aigov_facts_client/utils/cell_facts.py,sha256=XjsPv3lSfJRrULPN4gnRSqZp0aJ39u6DcdvTdGvmyXs,4428
+ibm_aigov_facts_client/utils/cell_facts.py,sha256=b7hvMM6SzQSbkim--mwBAQE1oXheegDeQwVeydOGyNQ,4861
 ibm_aigov_facts_client/utils/client_errors.py,sha256=E7FiIpFt15KIeUOwP0NvU8X_ixbIMbWpxwEZJLMJz7s,3159
 ibm_aigov_facts_client/utils/client_utils.py,sha256=f9JI-uC3dLB7MkFAZtzxSN6kiAgvsq3pf-7ZcJruTbA,4858
 ibm_aigov_facts_client/utils/config.py,sha256=d5epaRv5_PsFUveBODbSLFW2xYRngJ-Rn9w42Wjgupk,1598
 ibm_aigov_facts_client/utils/constants.py,sha256=h9K7LTeGYLr8ayigTkKBBieESzdoJUCFtRz1kEhX8fI,3956
 ibm_aigov_facts_client/utils/cp4d_utils.py,sha256=jFijo0IuGzZiBlbrLpBHOyaIxxUDC3Fj0-aqskOxaq0,4548
 ibm_aigov_facts_client/utils/doc_annotations.py,sha256=2-5mfPOg5eHA4uEi31se9L1uWxvqgo-6wzbhUoou4ok,3920
-ibm_aigov_facts_client/utils/enums.py,sha256=9_dA3pl-sRQAGS2Ib6jmbVmYr5HFgrDhFVeORqupdtg,3979
+ibm_aigov_facts_client/utils/enums.py,sha256=7pafT144AOM44HOLTSBHtAJmGRGxAaW8Xqjqz9QQOgE,4442
 ibm_aigov_facts_client/utils/logging_utils.py,sha256=Y4Ddy2LQK7MDHygEIVNHajf9LDqn5piEyPxNdSyZuYw,5255
 ibm_aigov_facts_client/utils/manual_store_utils.py,sha256=ilfDgbW-0WM3z66aQGzjU1CbSqpte1qqHNiApHd610c,9152
 ibm_aigov_facts_client/utils/me_containers_meta.py,sha256=lSAy6SL8_RJ2UzVZjivDGLlFlJSBsMF54mN4f9k2vaY,6318
 ibm_aigov_facts_client/utils/metrics_utils.py,sha256=fGUm-ZmokmuSEVV_eYtclkS8Z_cEh1taAWngIbgk3T8,2095
 ibm_aigov_facts_client/utils/store_utils.py,sha256=WOaEWAF7pKRHzbrMEAks7dCggwOQMI8Q2yQp6hp-Pug,9254
 ibm_aigov_facts_client/utils/support_scope_meta.py,sha256=HBnxPLBZTsqFxp4k0Uww5VTDoStM6d-u9FgXrY4Vm8U,15176
 ibm_aigov_facts_client/utils/utils.py,sha256=N5BheFVbtFMs3-KJBot9r2HOeATLDE2hNp6H-UOgb-0,17106
 ibm_aigov_facts_client/utils/validation.py,sha256=UkvHkyj3MmdSaK0xmas3eYyiJl7FzRlGH5LTIqxtBaM,7131
 ibm_aigov_facts_client/utils/experiments/__init__.py,sha256=9aOqTJ9oRveYnVud0YuKcb43qpmvKYv8dRKp7WTmUlc,611
 ibm_aigov_facts_client/utils/experiments/experiments_utils.py,sha256=aGCKhJlKnhte2LcKk_vZad6lPwbBspODpaYEpEJ5iKg,7945
 ibm_aigov_facts_client/utils/runs/__init__.py,sha256=JeI9cubVqcMYGr5NPU_t6eBG7zR5sgVMWzY9_WlU4_o,612
 ibm_aigov_facts_client/utils/runs/runs_utils.py,sha256=E15Lho0zWJYG88kgfcpxfmz_5d4hWpCld9Cs6hIjqRA,20668
-ibm_aigov_facts_client-1.0.58.dist-info/LICENSE,sha256=DOwG4OVfvD3FzuT8qbYH9my49OTbzzs8ATWU3RVnMuk,10173
-ibm_aigov_facts_client-1.0.58.dist-info/METADATA,sha256=WNozEkOa-XteFjmXUhZESg7elQAEa48rWZ1NK8lk33g,1001
-ibm_aigov_facts_client-1.0.58.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-ibm_aigov_facts_client-1.0.58.dist-info/entry_points.txt,sha256=T241caYNAGy2neCQ-Kij9uAqHgLkvz01XqlbLFwVTyc,94
-ibm_aigov_facts_client-1.0.58.dist-info/top_level.txt,sha256=go0ZFnFSqfg1HbtuiG6joO6X9A0ZHDBRQGN2Fkx5EfQ,23
-ibm_aigov_facts_client-1.0.58.dist-info/RECORD,,
+ibm_aigov_facts_client-1.0.59.dist-info/LICENSE,sha256=DOwG4OVfvD3FzuT8qbYH9my49OTbzzs8ATWU3RVnMuk,10173
+ibm_aigov_facts_client-1.0.59.dist-info/METADATA,sha256=6tkuDj9IbduEiTsZRlGaRzSzmXA0xhFAmjSrUJ67t8g,1001
+ibm_aigov_facts_client-1.0.59.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+ibm_aigov_facts_client-1.0.59.dist-info/entry_points.txt,sha256=T241caYNAGy2neCQ-Kij9uAqHgLkvz01XqlbLFwVTyc,94
+ibm_aigov_facts_client-1.0.59.dist-info/top_level.txt,sha256=go0ZFnFSqfg1HbtuiG6joO6X9A0ZHDBRQGN2Fkx5EfQ,23
+ibm_aigov_facts_client-1.0.59.dist-info/RECORD,,
```

