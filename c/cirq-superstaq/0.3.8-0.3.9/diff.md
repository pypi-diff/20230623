# Comparing `tmp/cirq_superstaq-0.3.8-py3-none-any.whl.zip` & `tmp/cirq_superstaq-0.3.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,23 @@
-Zip file size: 39659 bytes, number of entries: 21
--rw-r--r--  2.0 unx     1563 b- defN 22-Dec-07 02:42 cirq_superstaq/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 22-Dec-07 02:42 cirq_superstaq/_version.py
--rw-r--r--  2.0 unx      243 b- defN 22-Dec-07 02:42 cirq_superstaq/_version_test.py
--rw-r--r--  2.0 unx     7919 b- defN 22-Dec-07 02:42 cirq_superstaq/compiler_output.py
--rw-r--r--  2.0 unx     7496 b- defN 22-Dec-07 02:42 cirq_superstaq/compiler_output_test.py
--rw-r--r--  2.0 unx    25585 b- defN 22-Dec-07 02:42 cirq_superstaq/custom_gates.py
--rw-r--r--  2.0 unx    25037 b- defN 22-Dec-07 02:42 cirq_superstaq/custom_gates_test.py
--rw-r--r--  2.0 unx     7535 b- defN 22-Dec-07 02:42 cirq_superstaq/daily_integration_test.py
--rw-r--r--  2.0 unx     6463 b- defN 22-Dec-07 02:42 cirq_superstaq/job.py
--rw-r--r--  2.0 unx     6734 b- defN 22-Dec-07 02:42 cirq_superstaq/job_test.py
--rw-r--r--  2.0 unx       68 b- defN 22-Dec-07 02:42 cirq_superstaq/py.typed
--rw-r--r--  2.0 unx     3054 b- defN 22-Dec-07 02:42 cirq_superstaq/sampler.py
--rw-r--r--  2.0 unx     1301 b- defN 22-Dec-07 02:42 cirq_superstaq/serialization.py
--rw-r--r--  2.0 unx     1535 b- defN 22-Dec-07 02:42 cirq_superstaq/serialization_test.py
--rw-r--r--  2.0 unx    19694 b- defN 22-Dec-07 02:42 cirq_superstaq/service.py
--rw-r--r--  2.0 unx    16561 b- defN 22-Dec-07 02:42 cirq_superstaq/service_test.py
--rw-r--r--  2.0 unx    11357 b- defN 22-Dec-07 02:42 cirq_superstaq-0.3.8.dist-info/LICENSE
--rw-r--r--  2.0 unx     2271 b- defN 22-Dec-07 02:42 cirq_superstaq-0.3.8.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Dec-07 02:42 cirq_superstaq-0.3.8.dist-info/WHEEL
--rw-r--r--  2.0 unx       15 b- defN 22-Dec-07 02:42 cirq_superstaq-0.3.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1809 b- defN 22-Dec-07 02:42 cirq_superstaq-0.3.8.dist-info/RECORD
-21 files, 146354 bytes uncompressed, 36701 bytes compressed:  74.9%
+Zip file size: 40506 bytes, number of entries: 21
+-rw-r--r--  2.0 unx     1563 b- defN 22-Dec-08 20:02 cirq_superstaq/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 22-Dec-08 20:02 cirq_superstaq/_version.py
+-rw-r--r--  2.0 unx      243 b- defN 22-Dec-08 20:02 cirq_superstaq/_version_test.py
+-rw-r--r--  2.0 unx     8383 b- defN 22-Dec-08 20:02 cirq_superstaq/compiler_output.py
+-rw-r--r--  2.0 unx     8422 b- defN 22-Dec-08 20:02 cirq_superstaq/compiler_output_test.py
+-rw-r--r--  2.0 unx    25883 b- defN 22-Dec-08 20:02 cirq_superstaq/custom_gates.py
+-rw-r--r--  2.0 unx    27032 b- defN 22-Dec-08 20:02 cirq_superstaq/custom_gates_test.py
+-rw-r--r--  2.0 unx     8420 b- defN 22-Dec-08 20:02 cirq_superstaq/daily_integration_test.py
+-rw-r--r--  2.0 unx     6463 b- defN 22-Dec-08 20:02 cirq_superstaq/job.py
+-rw-r--r--  2.0 unx     6734 b- defN 22-Dec-08 20:02 cirq_superstaq/job_test.py
+-rw-r--r--  2.0 unx       68 b- defN 22-Dec-08 20:02 cirq_superstaq/py.typed
+-rw-r--r--  2.0 unx     3054 b- defN 22-Dec-08 20:02 cirq_superstaq/sampler.py
+-rw-r--r--  2.0 unx     1301 b- defN 22-Dec-08 20:02 cirq_superstaq/serialization.py
+-rw-r--r--  2.0 unx     1535 b- defN 22-Dec-08 20:02 cirq_superstaq/serialization_test.py
+-rw-r--r--  2.0 unx    19694 b- defN 22-Dec-08 20:02 cirq_superstaq/service.py
+-rw-r--r--  2.0 unx    16561 b- defN 22-Dec-08 20:02 cirq_superstaq/service_test.py
+-rw-r--r--  2.0 unx    11357 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2271 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       15 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1809 b- defN 22-Dec-08 20:02 cirq_superstaq-0.3.9.dist-info/RECORD
+21 files, 150922 bytes uncompressed, 37548 bytes compressed:  75.1%
```

## zipnote {}

```diff
@@ -42,23 +42,23 @@
 
 Filename: cirq_superstaq/service.py
 Comment: 
 
 Filename: cirq_superstaq/service_test.py
 Comment: 
 
-Filename: cirq_superstaq-0.3.8.dist-info/LICENSE
+Filename: cirq_superstaq-0.3.9.dist-info/LICENSE
 Comment: 
 
-Filename: cirq_superstaq-0.3.8.dist-info/METADATA
+Filename: cirq_superstaq-0.3.9.dist-info/METADATA
 Comment: 
 
-Filename: cirq_superstaq-0.3.8.dist-info/WHEEL
+Filename: cirq_superstaq-0.3.9.dist-info/WHEEL
 Comment: 
 
-Filename: cirq_superstaq-0.3.8.dist-info/top_level.txt
+Filename: cirq_superstaq-0.3.9.dist-info/top_level.txt
 Comment: 
 
-Filename: cirq_superstaq-0.3.8.dist-info/RECORD
+Filename: cirq_superstaq-0.3.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cirq_superstaq/_version.py

```diff
@@ -1 +1 @@
-__version__ = "0.3.8"
+__version__ = "0.3.9"
```

## cirq_superstaq/compiler_output.py

```diff
@@ -1,18 +1,19 @@
 import importlib
+import json
 import warnings
 from typing import Any, Dict, List, Optional, Set, Union
 
 import cirq
 import general_superstaq as gss
 
 import cirq_superstaq as css
 
 try:
-    import qtrl.sequencer
+    import qtrl.sequence_utils.readout
 except ModuleNotFoundError:
     pass
 
 
 def active_qubit_indices(circuit: cirq.AbstractCircuit) -> List[int]:
     """Returns the indices of the non-idle qubits in a quantum circuit."""
 
@@ -118,36 +119,46 @@
             attribute (if True) or a .circuit attribute (False)
     Returns:
         a CompilerOutput object with the compiled circuit(s). If qtrl is available locally,
         the returned object also stores the pulse sequence in the .seq attribute and the
         list(s) of cycles in the .pulse_list(s) attribute.
     """
 
+    compiled_circuits: Union[List[cirq.Circuit], List[List[cirq.Circuit]]]
+    compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
+
     seq = None
     pulse_lists = None
 
     if importlib.util.find_spec(
         "qtrl"
     ):  # pragma: no cover, b/c qtrl is not open source so it is not in cirq-superstaq reqs
-        state = gss.serialization.deserialize(json_dict["state_jp"])
 
-        seq = qtrl.sequencer.Sequence(n_elements=1)
-        seq.__setstate__(state)
-        seq.compile()
+        def _sequencer_from_state(state: Dict[str, Any]) -> "qtrl.sequencer.Sequence":
+            seq = qtrl.sequencer.Sequence(n_elements=1)
+            seq.__setstate__(state)
+            seq.compile()
+            return seq
+
+        pulse_lists = gss.serialization.deserialize(json_dict["pulse_lists_jp"])
+        state = gss.serialization.deserialize(json_dict["state_jp"])
 
         if "readout_jp" in json_dict:
-            state = gss.serialization.deserialize(json_dict["readout_jp"])
-            seq._readout = qtrl.sequencer.Sequence(n_elements=1)
-            seq._readout.__setstate__(state)
-            seq._readout.compile()
+            readout_state = gss.serialization.deserialize(json_dict["readout_jp"])
+            readout_seq = _sequencer_from_state(readout_state)
 
-        pulse_lists = gss.serialization.deserialize(json_dict["pulse_lists_jp"])
+            if "readout_qubits" in json_dict:
+                readout_qubits = json.loads(json_dict["readout_qubits"])
+                readout_seq._readout = qtrl.sequence_utils.readout._ReadoutInfo(
+                    readout_seq, readout_qubits, n_readouts=len(compiled_circuits)
+                )
 
-    compiled_circuits: Union[List[cirq.Circuit], List[List[cirq.Circuit]]]
-    compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
+            state["_readout"] = readout_seq
+
+        seq = _sequencer_from_state(state)
 
     if num_eca_circuits:
         compiled_circuits = [
             compiled_circuits[i : i + num_eca_circuits]
             for i in range(0, len(compiled_circuits), num_eca_circuits)
         ]
```

## cirq_superstaq/compiler_output_test.py

```diff
@@ -130,37 +130,52 @@
     assert pickle.dumps(out.seq) == pickle.dumps(seq)
     assert out.pulse_list == [[]]
     assert not hasattr(out.seq, "_readout")
     assert not hasattr(out, "circuits") and not hasattr(out, "pulse_lists")
 
     # Serialized readout attribute for aqt_zurich_qpu:
     json_dict["readout_jp"] = state_str
+    json_dict["readout_qubits"] = "[4, 5, 6, 7]"
     out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=False)
     assert out.circuit == circuit
     assert out.pulse_list == [[]]
     assert isinstance(out.seq, qtrl.sequencer.Sequence)
+    assert isinstance(out.seq._readout, qtrl.sequencer.Sequence)
+    assert isinstance(out.seq._readout._readout, qtrl.sequence_utils.readout._ReadoutInfo)
+    assert out.seq._readout._readout.sequence is out.seq._readout
+    assert out.seq._readout._readout.qubits == [4, 5, 6, 7]
+    assert out.seq._readout._readout.n_readouts == 1
     assert pickle.dumps(out.seq._readout) == pickle.dumps(out.seq) == pickle.dumps(seq)
+    assert not hasattr(out, "circuits") and not hasattr(out, "pulse_lists")
 
     # Multiple circuits:
     out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit]
     assert pickle.dumps(out.seq) == pickle.dumps(seq)
     assert out.pulse_lists == [[[]]]
     assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
 
     pulse_lists_str = gss.serialization.serialize([[[]], [[]]])
     json_dict = {
         "cirq_circuits": css.serialization.serialize_circuits([circuit, circuit]),
         "state_jp": state_str,
         "pulse_lists_jp": pulse_lists_str,
+        "readout_jp": state_str,
+        "readout_qubits": "[4, 5, 6, 7]",
     }
     out = css.compiler_output.read_json_aqt(json_dict, circuits_is_list=True)
     assert out.circuits == [circuit, circuit]
     assert pickle.dumps(out.seq) == pickle.dumps(seq)
     assert out.pulse_lists == [[[]], [[]]]
+    assert isinstance(out.seq, qtrl.sequencer.Sequence)
+    assert isinstance(out.seq._readout, qtrl.sequencer.Sequence)
+    assert isinstance(out.seq._readout._readout, qtrl.sequence_utils.readout._ReadoutInfo)
+    assert out.seq._readout._readout.sequence is out.seq._readout
+    assert out.seq._readout._readout.qubits == [4, 5, 6, 7]
+    assert out.seq._readout._readout.n_readouts == 2
     assert not hasattr(out, "circuit") and not hasattr(out, "pulse_list")
 
 
 def test_read_json_qscout() -> None:
     q0 = cirq.LineQubit(0)
     circuit = cirq.Circuit(cirq.H(q0), cirq.measure(q0))
```

## cirq_superstaq/custom_gates.py

```diff
@@ -1,10 +1,10 @@
 """Miscellaneous custom gates that we encounter and want to explicitly define."""
 
-from typing import AbstractSet, Any, Callable, Dict, List, Optional, Sequence, Tuple, Union
+from typing import AbstractSet, Any, Dict, Iterator, List, Optional, Sequence, Tuple, Type, Union
 
 import cirq
 import numpy as np
 import numpy.typing as npt
 
 import cirq_superstaq as css
 
@@ -66,15 +66,15 @@
 
     def __str__(self) -> str:
         return f"ZZSwapGate({self.theta})"
 
     def __repr__(self) -> str:
         return f"css.ZZSwapGate({self.theta})"
 
-    def _decompose_(self, qubits: Tuple[cirq.Qid, cirq.Qid]) -> cirq.OP_TREE:
+    def _decompose_(self, qubits: Tuple[cirq.Qid, cirq.Qid]) -> Iterator[cirq.Operation]:
         yield cirq.CX(qubits[0], qubits[1])
         yield cirq.CX(qubits[1], qubits[0])
         yield cirq.Z(qubits[1]) ** (self.theta / np.pi)
         yield cirq.CX(qubits[0], qubits[1])
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         t = args.format_radians(self.theta)
@@ -223,15 +223,17 @@
             raise ValueError("Polarity must be either '+-' or '-+'")
         self.polarity = polarity
         self.sandwich_rx_rads = sandwich_rx_rads
 
     def _num_qubits_(self) -> int:
         return 2
 
-    def _decompose_(self, qubits: Tuple[cirq.LineQubit, cirq.LineQubit]) -> cirq.OP_TREE:
+    def _decompose_(
+        self, qubits: Tuple[cirq.LineQubit, cirq.LineQubit]
+    ) -> Iterator[cirq.Operation]:
         yield css.CR(*qubits) ** 0.25 if self.polarity == "+-" else css.CR(*qubits) ** -0.25
         yield cirq.X(qubits[0])
         if self.sandwich_rx_rads:
             yield cirq.rx(self.sandwich_rx_rads)(qubits[1])
         yield css.CR(*qubits) ** -0.25 if self.polarity == "+-" else css.CR(*qubits) ** 0.25
 
     def _circuit_diagram_info_(
@@ -303,27 +305,30 @@
 
     def _qasm_(self, args: cirq.QasmArgs, qubits: Tuple[cirq.Qid, ...]) -> str:
         indices_str = ",".join([f"{{{i}}}" for i in range(len(qubits))])
         format_str = f"barrier {indices_str};\n"
         return args.format(format_str, *qubits)
 
     def __str__(self) -> str:
-        return f"Barrier({self.num_qubits()})"
+        if all(d == 2 for d in self._qid_shape):
+            return f"Barrier({self.num_qubits()})"
+        return f"Barrier(qid_shape={cirq.qid_shape(self)})"
 
     def __repr__(self) -> str:
-        return f"css.Barrier({self.num_qubits()})"
+        return f"css.{self}"
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> Tuple[str, ...]:
         if args.use_unicode_characters:
             return ("│",) * self.num_qubits()
         return ("|",) * self.num_qubits()
 
 
 def barrier(*qubits: cirq.Qid) -> cirq.Operation:
-    return css.Barrier(len(qubits)).on(*qubits)
+    qid_shape = tuple(q.dimension for q in qubits)
+    return css.Barrier(qid_shape=qid_shape).on(*qubits)
 
 
 @cirq.value_equality(approximate=True)
 class ParallelGates(cirq.Gate, cirq.InterchangeableQubitsGate):
     """A single Gate combining a collection of concurrent Gate(s) acting on different qubits.
 
     WARNING: for cirq versions 0.14.*, equality check will return False after permutations of
@@ -398,18 +403,21 @@
             return False
 
         return all(
             cirq.equal_up_to_global_phase(gate, other_gate, atol=atol)
             for gate, other_gate in zip(self.component_gates, other.component_gates)
         )
 
-    def _num_qubits_(self) -> int:
-        return sum(map(cirq.num_qubits, self.component_gates))
+    def _qid_shape_(self) -> Tuple[int, ...]:
+        qid_shape: Tuple[int, ...] = ()
+        for gate in self.component_gates:
+            qid_shape += cirq.qid_shape(gate)
+        return qid_shape
 
-    def _decompose_(self, qubits: Tuple[cirq.Qid, ...]) -> cirq.OP_TREE:
+    def _decompose_(self, qubits: Tuple[cirq.Qid, ...]) -> Iterator[cirq.Operation]:
         """Decompose into each component gate"""
         for gate in self.component_gates:
             num_qubits = gate.num_qubits()
             yield gate(*qubits[:num_qubits])
             qubits = qubits[num_qubits:]
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
@@ -661,15 +669,15 @@
 # iToffoli gate
 ICCX = IX.controlled(2, [1, 1])
 
 # Open-control iToffoli gate
 AQTICCX = AQTITOFFOLI = IX.controlled(2, [0, 0])
 
 
-def custom_resolver(cirq_type: str) -> Union[Callable[..., cirq.Gate], None]:
+def custom_resolver(cirq_type: str) -> Union[Type[cirq.Gate], None]:
     if cirq_type == "ZZSwapGate":
         return ZZSwapGate
     if cirq_type == "Barrier":
         return Barrier
     if cirq_type == "ZXPowGate":
         return ZXPowGate
     if cirq_type == "AceCR":
```

## cirq_superstaq/custom_gates_test.py

```diff
@@ -262,15 +262,15 @@
     assert repr(gate) == "css.Barrier(3)"
 
     cirq.testing.assert_equivalent_repr(gate, setup_code="import cirq_superstaq as css")
 
     operation = gate.on(*qubits)
     assert cirq.decompose(operation) == [operation]
 
-    # confirm Barrier is as an InterchangeableQubitsGate
+    # confirm Barrier is an InterchangeableQubitsGate
     for permuted_qubits in itertools.permutations(qubits):
         assert operation == gate.on(*permuted_qubits)
 
     circuit = cirq.Circuit(operation)
     expected_qasm = textwrap.dedent(
         """\
         OPENQASM 2.0;
@@ -319,14 +319,48 @@
     assert circuit == cirq.Circuit(operation)
     assert cirq.trace_distance_bound(gate) == 1.0
 
     barrier = css.barrier(*qubits)
     assert barrier == css.Barrier(n).on(*qubits)
 
 
+def test_barrier_on_qids() -> None:
+    qudits = [
+        cirq.LineQubit(0),
+        cirq.LineQid(1, 3),
+        cirq.GridQid(2, 3, dimension=4),
+        cirq.NamedQid("foo", dimension=5),
+    ]
+
+    gate = css.Barrier(qid_shape=(2, 3, 4, 5))
+
+    assert str(gate) == "Barrier(qid_shape=(2, 3, 4, 5))"
+    assert repr(gate) == "css.Barrier(qid_shape=(2, 3, 4, 5))"
+
+    cirq.testing.assert_equivalent_repr(gate, setup_code="import cirq_superstaq as css")
+    assert gate != css.Barrier(4)
+
+    operation = gate.on(*qudits)
+    assert cirq.decompose(operation) == [operation]
+
+    # make sure optimizations don't drop Barriers:
+    circuit = cirq.drop_negligible_operations(cirq.Circuit(operation))
+    assert circuit == cirq.Circuit(operation)
+    assert cirq.trace_distance_bound(operation) == 1.0
+
+    # check css.barrier() function and confirm Barrier is an InterchangeableQubitsGate
+    # (only works if all qudits have the same dimension)
+    qudits = [q.with_dimension(3) for q in qudits]
+    operation = css.barrier(*qudits)
+    for permuted_qubits in itertools.permutations(qudits):
+        qid_shape = tuple(q.dimension for q in permuted_qubits)
+        assert operation == css.Barrier(qid_shape=qid_shape).on(*permuted_qubits)
+        assert operation == css.barrier(*permuted_qubits)
+
+
 def test_parallel_gates() -> None:
     gate = css.ParallelGates(cirq.CZ, cirq.CZ**0.5, cirq.CZ**-0.5)
     qubits = cirq.LineQubit.range(6)
     operation = gate(*qubits)
     circuit = cirq.Circuit(operation)
 
     expected_diagram = textwrap.dedent(
@@ -384,14 +418,32 @@
     with pytest.raises(ValueError, match="tagged operations not permitted"):
         _ = css.parallel_gates_operation(cirq.X(q0).with_tags("foo"))
 
     with pytest.raises(ValueError):  # Overlapping qubits should be caught by cirq
         _ = css.parallel_gates_operation(cirq.CX(q2, q0), cirq.Y(q2))
 
 
+def test_parallel_gates_on_qids() -> None:
+    gate = css.ParallelGates(cirq.X, cirq.MatrixGate(np.eye(9), qid_shape=(3, 3)))
+    qudits = [cirq.LineQubit(2), cirq.LineQid(1, 3), cirq.GridQid(2, 3, dimension=3)]
+    operation = gate(*qudits)
+
+    cirq.testing.assert_equivalent_repr(
+        gate, setup_code="import cirq, cirq_superstaq as css, numpy as np"
+    )
+
+    assert cirq.decompose(operation) == [
+        cirq.X(qudits[0]),
+        cirq.MatrixGate(np.eye(9), qid_shape=(3, 3)).on(qudits[1], qudits[2]),
+    ]
+    cirq.testing.assert_decompose_is_consistent_with_unitary(gate, ignoring_global_phase=False)
+
+    assert operation == css.parallel_gates_operation(*cirq.decompose(operation))
+
+
 def test_parallel_gates_circuit_diagram_fallback() -> None:
     gate = cirq.circuits.qasm_output.QasmUGate(0.1, 0.2, 0.3)
     assert not hasattr(gate, "_circuit_diagram_info_")
 
     cirq.testing.assert_has_diagram(
         cirq.Circuit(css.ParallelGates(gate).on(cirq.LineQubit(1))),
         f"1: ───ParallelGates({gate})───",
```

## cirq_superstaq/daily_integration_test.py

```diff
@@ -204,7 +204,28 @@
     assert isinstance(out.circuit, cirq.Circuit)
 
 
 def test_get_aqt_configs(service: css.Service) -> None:
     res = service.aqt_get_configs()
     assert "pulses" in res
     assert "variables" in res
+
+
+def test_supercheq(service: css.Service) -> None:
+    # fmt: off
+    files = [
+        [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 1, 0], [0, 0, 0, 1, 1],
+        [0, 0, 1, 0, 0], [0, 0, 1, 0, 1], [0, 0, 1, 1, 0], [0, 0, 1, 1, 1],
+        [0, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 1, 0, 1, 0], [0, 1, 0, 1, 1],
+        [0, 1, 1, 0, 0], [0, 1, 1, 0, 1], [0, 1, 1, 1, 0], [0, 1, 1, 1, 1],
+        [1, 0, 0, 0, 0], [1, 0, 0, 0, 1], [1, 0, 0, 1, 0], [1, 0, 0, 1, 1],
+        [1, 0, 1, 0, 0], [1, 0, 1, 0, 1], [1, 0, 1, 1, 0], [1, 0, 1, 1, 1],
+        [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [1, 1, 0, 1, 0], [1, 1, 0, 1, 1],
+        [1, 1, 1, 0, 0], [1, 1, 1, 0, 1], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1],
+    ]
+    # fmt: on
+
+    num_qubits = 3
+    depth = 1
+    circuits, fidelities = service.supercheq(files, num_qubits, depth)
+    assert len(circuits) == 32
+    assert fidelities.shape == (32, 32)
```

## Comparing `cirq_superstaq-0.3.8.dist-info/LICENSE` & `cirq_superstaq-0.3.9.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cirq_superstaq-0.3.8.dist-info/METADATA` & `cirq_superstaq-0.3.9.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: cirq-superstaq
-Version: 0.3.8
+Version: 0.3.9
 Summary: The Cirq module that provides tools and access to SuperstaQ
 Home-page: https://github.com/SupertechLabs/cirq-superstaq
 Author: Super.tech
 Author-email: pranav@super.tech
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.7.0
```

## Comparing `cirq_superstaq-0.3.8.dist-info/RECORD` & `cirq_superstaq-0.3.9.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 cirq_superstaq/__init__.py,sha256=l1RpiCU5oOEL0FYasHcPJ77GQgd_Lb7Uouta5MDi8QE,1563
-cirq_superstaq/_version.py,sha256=7dTW0A5-FkrEuNOotvR8oW59M2lvIwYouVqfJzvXpKk,22
+cirq_superstaq/_version.py,sha256=xmkmdvq15kb61xdtCoa1YARnvHBnUgI-0GWIJYvHNeA,22
 cirq_superstaq/_version_test.py,sha256=FakRHPogGzthAy84Q-pe6jDLmjnyJx00ZkJOajzhahg,243
-cirq_superstaq/compiler_output.py,sha256=k9Pyoscdw5YgILc7bVYnTGaaQVWtQqRfqRmpdv8Rc60,7919
-cirq_superstaq/compiler_output_test.py,sha256=ccSdT2QNAcBM5AFVrLADHAvSRYk7OGUqfqQGSLceauM,7496
-cirq_superstaq/custom_gates.py,sha256=gflbmrRaZ15RCm_awchmvZCWOVKfqqAgQuy5quz7uaE,25585
-cirq_superstaq/custom_gates_test.py,sha256=FUg8CGeOlMzRKa06bAuG6FQ-cMebYrpjSC5Ligb29Xc,25037
-cirq_superstaq/daily_integration_test.py,sha256=D0pul4QtMy45IKvBkRz-0oxhrgyZSgC3jF3dXO8-j8k,7535
+cirq_superstaq/compiler_output.py,sha256=Su1mCs_6u1-ZojR6-EQgQiVqq_-vSvI1cnO9PzYtuEM,8383
+cirq_superstaq/compiler_output_test.py,sha256=W-jbISUZoYpWucpxR5zd3d1_nA2UBT6NMooyaRjCxpc,8422
+cirq_superstaq/custom_gates.py,sha256=L0WSCP-osRoM3e8piWDSf11qCDs7aWOTtZc_tAnEZjQ,25883
+cirq_superstaq/custom_gates_test.py,sha256=M9nXejage8qfsEGzTnatF9flh0sD1ejti4O8tl3Qh08,27032
+cirq_superstaq/daily_integration_test.py,sha256=fVzGKwEikNNyu6RovlBrl0vuI2ZeXyIBIAdRRPIgtaU,8420
 cirq_superstaq/job.py,sha256=zTgAg1kA95-dxynhrKWWmcY04L27_wxcoXK_RvI6Ldk,6463
 cirq_superstaq/job_test.py,sha256=H_2OHI4HF4kMPw9lYlGhBTBYLhL3gRtk43GcBjiRuEk,6734
 cirq_superstaq/py.typed,sha256=2DnKRKK8fmvD_m6TmNUqVJZBNb2xKGaCjcHkkVpRsMc,68
 cirq_superstaq/sampler.py,sha256=QqurJNRTR60m8okDZI98GBjdbAGcxSaJ-wsAIRJyhhc,3054
 cirq_superstaq/serialization.py,sha256=2fYeE7hzqI4ln6LtxwIqOrSQOB5W1DvjI0psV9OLa5s,1301
 cirq_superstaq/serialization_test.py,sha256=X7mul2pyjqhlRnIQ7FknZmj6MjEAeDl9sup_ZDzlVDo,1535
 cirq_superstaq/service.py,sha256=tXHbJO5q2tfiztEkRrjl3SIFF_mIH1-LFOCQcyOYa3c,19694
 cirq_superstaq/service_test.py,sha256=x1Kgm6-iE4uv2DQrwiT0QnQn94Fd2AUpWwXcP07USMo,16561
-cirq_superstaq-0.3.8.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
-cirq_superstaq-0.3.8.dist-info/METADATA,sha256=HsbEHVuRV6qNApMJDkLX9kp0zRkiPk6dbrUyNCXSkSE,2271
-cirq_superstaq-0.3.8.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-cirq_superstaq-0.3.8.dist-info/top_level.txt,sha256=x5zxwcSj8lK-JlK4DsVnr_uEeiPoaZG2wokltTJQrJY,15
-cirq_superstaq-0.3.8.dist-info/RECORD,,
+cirq_superstaq-0.3.9.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
+cirq_superstaq-0.3.9.dist-info/METADATA,sha256=v0uRUpxUBpUD5exXVWqGcg9pVvMLlAhm_YAm0S9vqTM,2271
+cirq_superstaq-0.3.9.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+cirq_superstaq-0.3.9.dist-info/top_level.txt,sha256=x5zxwcSj8lK-JlK4DsVnr_uEeiPoaZG2wokltTJQrJY,15
+cirq_superstaq-0.3.9.dist-info/RECORD,,
```

