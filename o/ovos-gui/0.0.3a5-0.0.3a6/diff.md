# Comparing `tmp/ovos_gui-0.0.3a5-py3-none-any.whl.zip` & `tmp/ovos_gui-0.0.3a6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,30 @@
-Zip file size: 44259 bytes, number of entries: 28
--rw-r--r--  2.0 unx      648 b- defN 23-Jun-13 00:05 ovos_gui/__init__.py
--rw-r--r--  2.0 unx      944 b- defN 23-Jun-13 00:05 ovos_gui/__main__.py
--rw-r--r--  2.0 unx     7323 b- defN 23-Jun-13 00:05 ovos_gui/bus.py
--rw-r--r--  2.0 unx     2839 b- defN 23-Jun-13 00:05 ovos_gui/extensions.py
--rw-r--r--  2.0 unx     6351 b- defN 23-Jun-13 00:05 ovos_gui/homescreen.py
--rw-r--r--  2.0 unx    31083 b- defN 23-Jun-13 00:05 ovos_gui/namespace.py
--rw-r--r--  2.0 unx      983 b- defN 23-Jun-13 00:05 ovos_gui/page.py
--rw-r--r--  2.0 unx     2403 b- defN 23-Jun-13 00:05 ovos_gui/service.py
--rw-r--r--  2.0 unx     6406 b- defN 23-Jun-13 00:05 ovos_gui/tui.py
--rw-r--r--  2.0 unx      114 b- defN 23-Jun-13 00:05 ovos_gui/version.py
--rw-r--r--  2.0 unx    15240 b- defN 23-Jun-13 00:05 ovos_gui/res/snd/clicked.wav
--rw-r--r--  2.0 unx     4176 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/FeatureRequest.qml
--rw-r--r--  2.0 unx      811 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/RequestHandler.qml
--rw-r--r--  2.0 unx     1523 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/SYSTEM_AdditionalSettings.qml
--rw-r--r--  2.0 unx     2804 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/SYSTEM_AnimatedImageFrame.qml
--rw-r--r--  2.0 unx      478 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/SYSTEM_HtmlFrame.qml
--rw-r--r--  2.0 unx     2796 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/SYSTEM_ImageFrame.qml
--rw-r--r--  2.0 unx     1206 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/SYSTEM_TextFrame.qml
--rw-r--r--  2.0 unx     6539 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/SYSTEM_UrlFrame.qml
--rw-r--r--  2.0 unx     1405 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/SwipeArea.qml
--rw-r--r--  2.0 unx     3215 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/WebViewHtmlFrame.qml
--rw-r--r--  2.0 unx     3031 b- defN 23-Jun-13 00:05 ovos_gui/res/ui/WebViewUrlFrame.qml
--rw-r--r--  2.0 unx    11423 b- defN 23-Jun-13 00:05 ovos_gui-0.0.3a5.dist-info/LICENSE.md
--rw-r--r--  2.0 unx      453 b- defN 23-Jun-13 00:05 ovos_gui-0.0.3a5.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-13 00:05 ovos_gui-0.0.3a5.dist-info/WHEEL
--rw-r--r--  2.0 unx      100 b- defN 23-Jun-13 00:05 ovos_gui-0.0.3a5.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        9 b- defN 23-Jun-13 00:05 ovos_gui-0.0.3a5.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2371 b- defN 23-Jun-13 00:05 ovos_gui-0.0.3a5.dist-info/RECORD
-28 files, 116766 bytes uncompressed, 40431 bytes compressed:  65.4%
+Zip file size: 45629 bytes, number of entries: 28
+-rw-r--r--  2.0 unx      648 b- defN 23-Jun-23 19:45 ovos_gui/__init__.py
+-rw-r--r--  2.0 unx      944 b- defN 23-Jun-23 19:45 ovos_gui/__main__.py
+-rw-r--r--  2.0 unx     8008 b- defN 23-Jun-23 19:45 ovos_gui/bus.py
+-rw-r--r--  2.0 unx     2927 b- defN 23-Jun-23 19:45 ovos_gui/extensions.py
+-rw-r--r--  2.0 unx     9870 b- defN 23-Jun-23 19:45 ovos_gui/homescreen.py
+-rw-r--r--  2.0 unx    32552 b- defN 23-Jun-23 19:45 ovos_gui/namespace.py
+-rw-r--r--  2.0 unx      713 b- defN 23-Jun-23 19:45 ovos_gui/page.py
+-rw-r--r--  2.0 unx     2500 b- defN 23-Jun-23 19:45 ovos_gui/service.py
+-rw-r--r--  2.0 unx     6373 b- defN 23-Jun-23 19:45 ovos_gui/tui.py
+-rw-r--r--  2.0 unx      114 b- defN 23-Jun-23 19:45 ovos_gui/version.py
+-rw-r--r--  2.0 unx    15240 b- defN 23-Jun-23 19:45 ovos_gui/res/snd/clicked.wav
+-rw-r--r--  2.0 unx     4176 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/FeatureRequest.qml
+-rw-r--r--  2.0 unx      811 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/RequestHandler.qml
+-rw-r--r--  2.0 unx     1523 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/SYSTEM_AdditionalSettings.qml
+-rw-r--r--  2.0 unx     2804 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/SYSTEM_AnimatedImageFrame.qml
+-rw-r--r--  2.0 unx      478 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/SYSTEM_HtmlFrame.qml
+-rw-r--r--  2.0 unx     2796 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/SYSTEM_ImageFrame.qml
+-rw-r--r--  2.0 unx     1206 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/SYSTEM_TextFrame.qml
+-rw-r--r--  2.0 unx     6539 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/SYSTEM_UrlFrame.qml
+-rw-r--r--  2.0 unx     1405 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/SwipeArea.qml
+-rw-r--r--  2.0 unx     3215 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/WebViewHtmlFrame.qml
+-rw-r--r--  2.0 unx     3031 b- defN 23-Jun-23 19:45 ovos_gui/res/ui/WebViewUrlFrame.qml
+-rw-r--r--  2.0 unx    11423 b- defN 23-Jun-23 19:45 ovos_gui-0.0.3a6.dist-info/LICENSE.md
+-rw-r--r--  2.0 unx      453 b- defN 23-Jun-23 19:45 ovos_gui-0.0.3a6.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-23 19:45 ovos_gui-0.0.3a6.dist-info/WHEEL
+-rw-r--r--  2.0 unx      100 b- defN 23-Jun-23 19:45 ovos_gui-0.0.3a6.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        9 b- defN 23-Jun-23 19:45 ovos_gui-0.0.3a6.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2371 b- defN 23-Jun-23 19:45 ovos_gui-0.0.3a6.dist-info/RECORD
+28 files, 122321 bytes uncompressed, 41801 bytes compressed:  65.8%
```

## zipnote {}

```diff
@@ -60,26 +60,26 @@
 
 Filename: ovos_gui/res/ui/WebViewHtmlFrame.qml
 Comment: 
 
 Filename: ovos_gui/res/ui/WebViewUrlFrame.qml
 Comment: 
 
-Filename: ovos_gui-0.0.3a5.dist-info/LICENSE.md
+Filename: ovos_gui-0.0.3a6.dist-info/LICENSE.md
 Comment: 
 
-Filename: ovos_gui-0.0.3a5.dist-info/METADATA
+Filename: ovos_gui-0.0.3a6.dist-info/METADATA
 Comment: 
 
-Filename: ovos_gui-0.0.3a5.dist-info/WHEEL
+Filename: ovos_gui-0.0.3a6.dist-info/WHEEL
 Comment: 
 
-Filename: ovos_gui-0.0.3a5.dist-info/entry_points.txt
+Filename: ovos_gui-0.0.3a6.dist-info/entry_points.txt
 Comment: 
 
-Filename: ovos_gui-0.0.3a5.dist-info/top_level.txt
+Filename: ovos_gui-0.0.3a6.dist-info/top_level.txt
 Comment: 
 
-Filename: ovos_gui-0.0.3a5.dist-info/RECORD
+Filename: ovos_gui-0.0.3a6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ovos_gui/bus.py

```diff
@@ -73,42 +73,53 @@
     LOG.info('GUI Message bus started!')
     return application
 
 
 def send_message_to_gui(message: dict):
     """
     Sends the supplied message to all connected GUI clients.
+    @param message: dict data to send to GUI clients
     """
     for connection in GUIWebsocketHandler.clients:
         try:
             connection.send(message)
         except Exception as e:
             LOG.exception(repr(e))
 
 
-def determine_if_gui_connected():
-    """Returns True if any clients are connected to the GUI bus."""
+def determine_if_gui_connected() -> bool:
+    """
+    Returns True if any clients are connected to the GUI bus.
+    """
     return len(GUIWebsocketHandler.clients) > 0
 
 
 class GUIWebsocketHandler(WebSocketHandler):
     """Defines the websocket pipeline between the GUI and Mycroft."""
     clients = []
 
     def open(self):
+        """
+        Add a new connection to `clients` and synchronize
+        """
         GUIWebsocketHandler.clients.append(self)
         LOG.info('New Connection opened!')
         self.synchronize()
 
     def on_close(self):
+        """
+        Remove a closed connection from `clients`
+        """
         LOG.info('Closing {}'.format(id(self)))
         GUIWebsocketHandler.clients.remove(self)
 
     def synchronize(self):
-        """ Upload namespaces, pages and data to the last connected. """
+        """
+        Upload namespaces, pages and data to the last connected client.
+        """
         namespace_pos = 0
         enclosure = self.application.enclosure
 
         for namespace in enclosure.active_namespaces:
             LOG.info(f'Sync {namespace.name}')
             # Insert namespace
             self.send({"type": "mycroft.session.list.insert",
@@ -127,33 +138,43 @@
                 self.send({"type": "mycroft.session.set",
                            "namespace": namespace.name,
                            "data": {key: value}
                            })
             namespace_pos += 1
 
     def on_message(self, message: str):
-        LOG.debug(f"Received: {message}")
+        """
+        Handle a message on the GUI websocket. Deserialize the message, map
+        message types to valid equivalents for the core messagebus and emit
+        on the core messagebus.
+        @param message: Serialized Message
+        """
         parsed_message = GUIMessage.deserialize(message)
+        LOG.debug(f"Received: {parsed_message.msg_type}|{parsed_message.data}")
+
         # msg = json.loads(message)
         if parsed_message.msg_type == "mycroft.events.triggered" and \
                 (parsed_message.data.get('event_name') == 'page_gained_focus' or
-                 parsed_message.data.get('event_name') == 'system.gui.user.interaction'):
+                 parsed_message.data.get('event_name') ==
+                 'system.gui.user.interaction'):
             # System event, a page was changed
             event_name = parsed_message.data.get('event_name')
             if event_name == 'page_gained_focus':
                 msg_type = 'gui.page_gained_focus'
             else:
                 msg_type = 'gui.page_interaction'
 
-            msg_data = {'namespace': parsed_message.data['namespace'],
-                        'page_number': parsed_message.data['parameters'].get('number'),
-                        'skill_id': parsed_message.data['parameters'].get('skillId')}
+            msg_data = \
+                {'namespace': parsed_message.data['namespace'],
+                 'page_number': parsed_message.data['parameters'].get('number'),
+                 'skill_id': parsed_message.data['parameters'].get('skillId')}
         elif parsed_message.msg_type == "mycroft.events.triggered":
             # A normal event was triggered
-            msg_type = f"{parsed_message.data['namespace']}.{parsed_message.data['event_name']}"
+            msg_type = f"{parsed_message.data['namespace']}." \
+                       f"{parsed_message.data['event_name']}"
             msg_data = parsed_message.data['parameters']
 
         elif parsed_message.msg_type == 'mycroft.session.set':
             # A value was changed send it back to the skill
             msg_type = f"{parsed_message.data['namespace']}.set"
             msg_data = parsed_message.data['data']
         elif parsed_message.msg_type == 'mycroft.gui.connected':
@@ -168,29 +189,33 @@
             return
 
         message = Message(msg_type, msg_data, parsed_message.context)
         self.application.enclosure.core_bus.emit(message)
         LOG.debug('Forwarded to core bus')
 
     def write_message(self, *arg, **kwarg):
-        """Wraps WebSocketHandler.write_message() with a lock. """
+        """
+        Wraps WebSocketHandler.write_message() with a lock.
+        """
         try:
             asyncio.get_event_loop()
         except RuntimeError:
             asyncio.set_event_loop(asyncio.new_event_loop())
 
         with _write_lock:
             super().write_message(*arg, **kwarg)
 
-    def send(self, data):
-        """Send the given data across the socket as JSON
-
-        Args:
-            data (dict): Data to transmit
+    def send(self, data: dict):
+        """
+        Send the given data across the socket as JSON
+        @param data: Data to send to the GUI
         """
         s = json.dumps(data)
         # LOG.info('Sending {}'.format(s))
         self.write_message(s)
 
     def check_origin(self, origin):
-        """Disable origin check to make js connections work."""
+        """
+        Disable origin check to make js connections work.
+        """
+        # TODO: Should this be implemented or deprecated
         return True
```

## ovos_gui/extensions.py

```diff
@@ -1,37 +1,40 @@
 from ovos_bus_client import Message, MessageBusClient
 from ovos_config.config import Configuration
 from ovos_gui.namespace import NamespaceManager
 from ovos_utils.log import LOG
 from ovos_plugin_manager.gui import OVOSGuiFactory
-from ovos_gui.homescreen import HomescreenManager
 
 
 class ExtensionsManager:
     def __init__(self, name: str, bus: MessageBusClient, gui: NamespaceManager):
-        """ Constructor for the Extension Manager. The Extension Manager is responsible for
-        managing the extensions that define additional GUI behaviours for specific platforms.
-
-        Args:
-            name: Name of the extension manager
-            bus: MessageBus instance
-            gui: GUI instance
+        """
+        Constructor for the Extension Manager. The Extension Manager is
+        responsible for managing the extensions that define additional GUI
+        behaviours for specific platforms.
+        @param name: Name of the extension manager
+        @param bus: MessageBus instance
+        @param gui: GUI instance
         """
 
         self.name = name
         self.bus = bus
         self.gui = gui
         core_config = Configuration()
         enclosure_config = core_config.get("gui") or {}
         self.active_extension = enclosure_config.get("extension", "generic")
         LOG.debug(f"Extensions Manager: Initializing {self.name} "
                   f"with active extension {self.active_extension}")
         self.activate_extension(self.active_extension.lower())
 
     def activate_extension(self, extension_id: str):
+        """
+        Activate the requested extension
+        @param extension_id: GUI Plugin entrypoint to activate
+        """
         mappings = {
             "smartspeaker": "ovos-gui-plugin-shell-companion",
             "bigscreen": "ovos-gui-plugin-bigscreen",
             "mobile": "ovos-gui-plugin-mobile",
             "plasmoid": "ovos-gui-plugin-plasmoid"
         }
         if extension_id.lower() in mappings:
```

## ovos_gui/homescreen.py

```diff
@@ -1,139 +1,219 @@
+from typing import List, Optional
+
 from ovos_bus_client import Message, MessageBusClient
-from ovos_config.config import Configuration, LocalConf
-from ovos_config.locations import USER_CONFIG
-from ovos_utils.log import LOG
+from ovos_bus_client.message import dig_for_message
+from ovos_config.config import Configuration, update_mycroft_config
+
+from ovos_utils.log import LOG, deprecated, log_deprecation
 
 from ovos_gui.namespace import NamespaceManager
 from threading import Thread
 
 
 class HomescreenManager(Thread):
-
     def __init__(self, bus: MessageBusClient, gui: NamespaceManager):
         super().__init__()
         self.bus = bus
         self.gui = gui
-        self.homescreens = []
+        self.homescreens: List[dict] = []
         self.mycroft_ready = False
+        # TODO: If service starts after `mycroft_ready`,
+        #       homescreen is never shown
         self.bus.on('homescreen.manager.add', self.add_homescreen)
         self.bus.on('homescreen.manager.remove', self.remove_homescreen)
         self.bus.on('homescreen.manager.list', self.get_homescreens)
-        self.bus.on("homescreen.manager.get_active", self.get_active_homescreen)
-        self.bus.on("homescreen.manager.set_active", self.set_active_homescreen)
+        self.bus.on("homescreen.manager.get_active",
+                    self.handle_get_active_homescreen)
+        self.bus.on("homescreen.manager.set_active",
+                    self.handle_set_active_homescreen)
         self.bus.on("homescreen.manager.disable_active",
                     self.disable_active_homescreen)
         self.bus.on("mycroft.mark2.register_idle",
                     self.register_old_style_homescreen)
         self.bus.on("homescreen.manager.show_active", self.show_homescreen)
         self.bus.on("mycroft.ready", self.set_mycroft_ready)
 
     def run(self):
-        """Start the Manager after it has been constructed."""
+        """
+        Start the Manager after it has been constructed.
+        """
         self.reload_homescreens_list()
 
-    def add_homescreen(self, homescreen):
-        # if homescreen[id] not in self.homescreens then add it
-        homescreen_id = homescreen.data["id"]
-        homescreen_class = homescreen.data["class"]
-        LOG.info(f"Homescreen Manager: Adding Homescreen {homescreen_id}")
-        # check if the list is empty
-        if len(self.homescreens) == 0:
-            self.homescreens.append(homescreen.data)
+    def add_homescreen(self, message: Message):
+        """
+        Handle `homescreen.manager.add` and add the requested homescreen if it
+        has not yet been added.
+        @param message: Message containing homescreen id/class to add
+        """
+        homescreen_id = message.data["id"]
+        homescreen_class = message.data["class"]
+
+        if any((homescreen['id'] == homescreen_id
+                for homescreen in self.homescreens)):
+            LOG.info(f"Requested homescreen_id already exists: {homescreen_id}")
         else:
-            # check if id is in list of homescreen dicts in self.homescreens
-            for h in self.homescreens:
-                if homescreen_id != h["id"]:
-                    self.homescreens.append(homescreen.data)
+            LOG.info(f"Homescreen Manager: Adding Homescreen {homescreen_id}")
+            self.homescreens.append(message.data)
 
         self.show_homescreen_on_add(homescreen_id, homescreen_class)
 
-    def remove_homescreen(self, homescreen):
-        homescreen_id = homescreen.data["id"]
+    def remove_homescreen(self, message: Message):
+        """
+        Handle `homescreen.manager.remove` and remove the requested homescreen
+        if it exists
+        @param message: Message containing homescreen id to remove
+        """
+        homescreen_id = message.data["id"]
         LOG.info(f"Homescreen Manager: Removing Homescreen {homescreen_id}")
         for h in self.homescreens:
             if homescreen_id == h["id"]:
-                self.homescreens.pop(h)
-
-    def get_homescreens(self):
-        return self.homescreens
+                self.homescreens.remove(h)
 
-    def get_active_homescreen(self):
-        config = Configuration()
-        enclosure_config = config.get("gui") or {}
+    def get_homescreens(self, message: Message):
+        """
+        Handle `homescreen.manager.list` and emit a response with loaded
+        homescreens.
+        :param message: Message requesting homescreens
+        """
+        self.bus.emit(message.response({"homescreens": self.homescreens}))
+
+    def handle_get_active_homescreen(self, message: Message):
+        """
+        Handle `homescreen.manager.get_active` and emit a response with the
+        active homescreen
+        @param message: Message requesting active homescreen
+        """
+        self.bus.emit(message.response(
+            {"homescreen": self.get_active_homescreen()}))
+
+    def handle_set_active_homescreen(self, message: Message):
+        """
+        Handle `homescreen.manager.set_active` requests to change the configured
+        homescreen and update configuration.
+        @param message: Message containing requested homescreen ID
+        """
+        new_homescreen = message.data.get("id")
+        LOG.debug(f"Requested updating homescreen to: {new_homescreen}")
+        self.set_active_homescreen(new_homescreen)
+
+    def get_active_homescreen(self) -> Optional[dict]:
+        """
+        Get the active homescreen according to configuration if it is loaded
+        @return: Loaded homescreen with an ID matching configuration
+        """
+        enclosure_config = Configuration().get("gui") or {}
         active_homescreen = enclosure_config.get("idle_display_skill")
         LOG.debug(f"Homescreen Manager: Active Homescreen {active_homescreen}")
         for h in self.homescreens:
             if h["id"] == active_homescreen:
                 return active_homescreen
 
-    def set_active_homescreen(self, homescreen):
-        homescreen_id = homescreen.data["id"]
-        conf = LocalConf(USER_CONFIG)
-        conf["gui"] = {
-            "idle_display_skill": homescreen_id,
-        }
-        conf.store()
-        self.bus.emit(Message("configuration.patch", {"config": conf}))
+    def set_active_homescreen(self, homescreen_id: str):
+        """
+        Update the configured `idle_display_skill`
+        @param homescreen_id: new `idle_display_skill`
+        """
+        # TODO: Validate requested homescreen_id
+        if Configuration().get("gui",
+                               {}).get("idle_display_skill") != homescreen_id:
+            LOG.info(f"Updating configured idle_display_skill to "
+                     f"{homescreen_id}")
+            new_config = {"gui": {"idle_display_skill": homescreen_id}}
+            update_mycroft_config(new_config, bus=self.bus)
 
     def reload_homescreens_list(self):
+        """
+        Emit a request for homescreens to register via the Messagebus
+        """
         LOG.info("Homescreen Manager: Reloading Homescreen List")
         self.collect_old_style_homescreens()
         self.bus.emit(Message("homescreen.manager.reload.list"))
 
-    def show_homescreen_on_add(self, homescreen_id, homescreen_class):
-        if self.mycroft_ready == True:
-            active_homescreen = self.get_active_homescreen()
-            LOG.debug(f"Requesting activation of {active_homescreen}")
-            if active_homescreen == homescreen_id:
-                if homescreen_class == "IdleDisplaySkill":
-                    LOG.debug(
-                        f"Homescreen Manager: Displaying Homescreen {active_homescreen}")
-                    self.bus.emit(Message("homescreen.manager.activate.display", {
-                        "homescreen_id": active_homescreen}))
-                elif homescreen_class == "MycroftSkill":
-                    LOG.debug(
-                        f"Homescreen Manager: Displaying Homescreen {active_homescreen}")
-                    self.bus.emit(Message("{}.idle".format(homescreen_id)))
-
-    def disable_active_homescreen(self, message):
-        conf = LocalConf(USER_CONFIG)
-        conf["gui"] = {
-            "idle_display_skill": None,
-        }
-        conf.store()
-        self.bus.emit(Message("configuration.patch", {"config": conf}))
-
-    def show_homescreen(self, message=None):
+    def show_homescreen_on_add(self, homescreen_id: str, homescreen_class: str):
+        """
+        Check if a homescreen should be displayed immediately upon addition
+        @param homescreen_id: ID of added homescreen
+        @param homescreen_class: "class" (IdleDisplaySkill, MycroftSkill)
+            of homescreen
+        """
+        if not self.mycroft_ready:
+            LOG.debug("Not ready yet, don't display")
+            return
+        LOG.debug(f"Checking {homescreen_id}")
+        if self.get_active_homescreen() != homescreen_id:
+            # Added homescreen isn't the configured one, do nothing
+            return
+
+        if homescreen_class == "IdleDisplaySkill":
+            LOG.debug(f"Displaying Homescreen {homescreen_id}")
+            self.bus.emit(Message("homescreen.manager.activate.display",
+                                  {"homescreen_id": homescreen_id}))
+        elif homescreen_class == "MycroftSkill":
+            log_deprecation(f"Homescreen skills should register listeners for "
+                            f"`homescreen.manager.activate.display`. "
+                            f"`{homescreen_id}.idle` messages will be removed.",
+                            "0.1.0")
+            LOG.debug(f"Displaying Homescreen {homescreen_id}")
+            self.bus.emit(Message(f"{homescreen_id}.idle"))
+
+    def disable_active_homescreen(self, message: Message):
+        """
+        Handle `homescreen.manager.disable_active` requests by configuring the
+        `idle_display_skill` as None.
+        @param message: Message requesting homescreen disable
+        """
+        # TODO: Is this valid behavior?
+        if Configuration().get("gui", {}).get("idle_display_skill"):
+            LOG.info(f"Disabling idle_display_skill!")
+            new_config = {"gui": {"idle_display_skill": None}}
+            update_mycroft_config(new_config, bus=self.bus)
+
+    def show_homescreen(self, message: Optional[Message] = None):
+        """
+        Handle a request to show the homescreen.
+        @param message: Optional `homescreen.manager.show_active` Message
+        """
         active_homescreen = self.get_active_homescreen()
         LOG.debug(f"Requesting activation of {active_homescreen}")
         for h in self.homescreens:
-            if h["id"] == active_homescreen:
+            if h.get("id") == active_homescreen:
+                LOG.debug(f"matched homescreen skill: {h}")
+                message = message or dig_for_message() or Message("")
                 if h["class"] == "IdleDisplaySkill":
-                    LOG.debug(
-                        f"Homescreen Manager: Displaying Homescreen "
-                        f"{active_homescreen}")
-                    self.bus.emit(Message("homescreen.manager.activate.display", {
-                        "homescreen_id": active_homescreen}))
+                    LOG.debug(f"Displaying Homescreen {active_homescreen}")
+                    self.bus.emit(message.forward(
+                        "homescreen.manager.activate.display",
+                        {"homescreen_id": active_homescreen}))
                 elif h["class"] == "MycroftSkill":
-                    LOG.debug(
-                        f"Homescreen Manager: Displaying Homescreen "
-                        f"{active_homescreen}")
-                    self.bus.emit(Message("{}.idle".format(active_homescreen)))
-
-    def set_mycroft_ready(self, message):
+                    LOG.debug(f"Displaying Homescreen {active_homescreen}")
+                    self.bus.emit(message.forward(f"{active_homescreen}.idle"))
+                else:
+                    LOG.error(f"Requested homescreen has an invalid class: {h}")
+                return
+        LOG.warning(f"Requested {active_homescreen} not found in: "
+                    f"{self.homescreens}")
+
+    def set_mycroft_ready(self, message: Message):
+        """
+        Handle `mycroft.ready` and show the homescreen
+        @param message: `mycroft.ready` Message
+        """
         self.mycroft_ready = True
         self.show_homescreen()
 
     # Add compabitility with older versions of the Resting Screen Class
 
     def collect_old_style_homescreens(self):
         """Trigger collection of older resting screens."""
+        # TODO: Deprecate in 0.1.0
         self.bus.emit(Message("mycroft.mark2.collect_idle"))
 
+    @deprecated("`mycroft.mark2.collect_idle` responses are deprecated",
+                "0.1.0")
     def register_old_style_homescreen(self, message):
         if "name" in message.data and "id" in message.data:
             super_class_name = "MycroftSkill"
             super_class_object = message.data["name"]
             skill_id = message.data["id"]
             _homescreen_entry = {"class": super_class_name,
                                  "name": super_class_object, "id": skill_id}
```

## ovos_gui/namespace.py

```diff
@@ -38,15 +38,15 @@
 The state of the active namespace stack is maintained locally and in the GUI
 code.  Changes to namespaces, and their contents, are communicated to the GUI
 over the GUI message bus.
 """
 
 from threading import Lock, Timer
 from time import sleep
-from typing import List, Union
+from typing import List, Union, Optional
 
 from ovos_config.config import Configuration
 from ovos_utils.log import LOG
 from ovos_bus_client import Message, MessageBusClient
 
 from ovos_gui.bus import (
     create_gui_service,
@@ -57,14 +57,61 @@
 from ovos_gui.page import GuiPage
 
 namespace_lock = Lock()
 
 RESERVED_KEYS = ['__from', '__idle']
 
 
+def _validate_page_message(message: Message) -> bool:
+    """
+    Validates the contents of the message data for page add/remove messages.
+
+    @param message: Message with request to add/remove one or more pages
+        from a namespace.
+    @returns: True if request is valid, else False
+    """
+    valid = (
+            "page" in message.data
+            and "__from" in message.data
+            and isinstance(message.data["page"], list)
+    )
+    if not valid:
+        if message.msg_type == "gui.page.show":
+            action = "shown"
+        else:
+            action = "removed"
+        LOG.error(f"Page will not be {action} due to malformed data in the"
+                  f"{message.msg_type} message")
+    return valid
+
+
+def _get_idle_display_config() -> str:
+    """
+    Retrieves the current value of the idle display skill configuration.
+    @returns: Configured idle_display_skill (skill_id)
+    """
+    config = Configuration()
+    enclosure_config = config.get("gui") or {}
+    idle_display_skill = enclosure_config.get("idle_display_skill")
+    LOG.info(f"Got idle_display_skill from config: {idle_display_skill}")
+    return idle_display_skill
+
+
+def _get_active_gui_extension() -> str:
+    """
+    Retrieves the current value of the gui extension configuration.
+    @returns: Configured gui extension
+    """
+    config = Configuration()
+    enclosure_config = config.get("gui") or {}
+    gui_extension = enclosure_config.get("extension", "generic")
+    LOG.info(f"Got extension from config: {gui_extension}")
+    return gui_extension.lower()
+
+
 class Namespace:
     """A grouping mechanism for related GUI pages and data.
 
     In the majority of cases, a namespace represents a skill.  There is a
     SYSTEM namespace for GUI screens that exist outside of skills.  This class
     defines an API to manage a namespace, its pages and its data.  Actions
     are communicated to the GUI message bus.
@@ -86,38 +133,47 @@
         self.duration = 30
         self.pages: List[GuiPage] = list()
         self.data = dict()
         self.page_number = 0
         self.session_set = False
 
     def add(self):
-        """Adds a namespace to the list of active namespaces."""
+        """
+        Adds this namespace to the list of active namespaces.
+        """
         LOG.info(f"Adding \"{self.name}\" to active GUI namespaces")
         message = dict(
             type="mycroft.session.list.insert",
             namespace="mycroft.system.active_skills",
             position=0,
             data=[dict(skill_id=self.name)]
         )
         send_message_to_gui(message)
 
     def activate(self, position: int):
-        """Activates an namespace already in the list of active namespaces."""
+        """
+        Activate this namespace if its already in the list of active namespaces.
+        @param position: position to move this namespace FROM
+        """
         LOG.info(f"Activating GUI namespace \"{self.name}\"")
         message = {
             "type": "mycroft.session.list.move",
             "namespace": "mycroft.system.active_skills",
             "from": position,
             "to": 0,
             "items_number": 1
         }
         send_message_to_gui(message)
 
     def remove(self, position: int):
-        """Removes a namespace from the list of active namespaces."""
+        """
+        Removes this namespace from the list of active namespaces. Also clears
+        any session data.
+        @param position: position to remove this namespace FROM
+        """
         LOG.info(f"Removing {self.name} from active GUI namespaces")
 
         # unload the data first before removing the namespace
         # use the keys of the data to unload the data
         for key in self.data:
             self.unload_data(key)
 
@@ -129,15 +185,16 @@
         )
         send_message_to_gui(message)
         self.session_set = False
         self.pages = list()
         self.data = dict()
 
     def load_data(self, name: str, value: str):
-        """Adds or changes the value of a namespace data attribute.
+        """
+        Adds or changes the value of a namespace data attribute.
 
         Args:
             name: The name of the attribute
             value: The attribute's value
         """
         message = dict(
             type="mycroft.session.set",
@@ -145,32 +202,37 @@
             data={name: value}
         )
 
         # LOG.info(f"Setting data {message} in GUI namespace {self.name}")
         send_message_to_gui(message)
 
     def unload_data(self, name: str):
-        """ Delete data from the namespace """
+        """
+        Delete data from the namespace
+        @param name: name of property to delete
+        """
         message = dict(
             type="mycroft.session.delete",
             property=name,
             namespace=self.name
         )
         # LOG.info(f"Deleting data {message} from GUI namespace {self.name}")
         send_message_to_gui(message)
 
-    def get_position_of_last_item_in_data(self):
-        """ Get the position of the last item """
+    def get_position_of_last_item_in_data(self) -> int:
+        """
+        Get the position of the last item
+        """
         return len(self.data) - 1
 
     def set_persistence(self, skill_type: str):
-        """Sets the duration of the namespace's time in the active list.
+        """
+        Sets the duration of the namespace's time in the active list.
 
-        Args:
-            skill_type: if skill type is idleDisplaySkill, the namespace will
+        @param skill_type: if skill type is idleDisplaySkill, the namespace will
             always persist.  Otherwise, the namespace will persist based on the
             active page's persistence.
         """
         # check if skill_type is idleDisplaySkill
         if skill_type == "idleDisplaySkill":
             self.persistent = True
             self.duration = 0
@@ -201,17 +263,16 @@
         Maintains a list of active pages within the active namespace.
 
         Skills with multiple pages of data can either show all the screens
         at once, allowing the user to swipe back and forth among them, or
         the pages can be loaded one at a time.  The latter is represented by
         a single list item, the former by multiple list items
 
-        Args:
-            pages: one or more pages to be displayed
-            show_index: index of page to display (default 0)
+        @param pages: list of pages to be displayed
+        @param show_index: index of page to display (default 0)
         """
         if show_index is None:
             LOG.warning(f"Expected int show_index but got `None`. Default to 0")
             show_index = 0
         new_pages = list()
 
         for page in pages:
@@ -224,23 +285,22 @@
 
         self._activate_page(pages[show_index])
 
     def _add_pages(self, new_pages: List[GuiPage]):
         """
         Adds one or more pages to the active page list.
 
-        Args:
-            new_pages: pages to add to the active page list
+        @param new_pages: pages to add to the active page list
         """
         LOG.info(f"Adding pages to GUI namespace {self.name}: {new_pages}")
         LOG.info(f"Current pages: {self.pages}")
         # print the attributes of the new pages
         for page in new_pages:
-            LOG.info(
-                f"Page: {page.url}, {page.name}, {page.persistent}, {page.duration}")
+            LOG.info(f"Page: {page.url}, {page.name}, {page.persistent}, "
+                     f"{page.duration}")
 
         # Find position of new page in self.pages
         position = self.pages.index(new_pages[0])
 
         message = dict(
             type="mycroft.gui.list.insert",
             namespace=self.name,
@@ -249,30 +309,30 @@
         )
         send_message_to_gui(message)
 
     def _activate_page(self, page: GuiPage):
         """
         Returns focus to a page already in the active page list.
 
-        Args:
-            page: the page that will gain focus
+        @param page: the page that will gain focus
         """
         LOG.info(f"Activating page {page.name} in GUI namespace {self.name}")
         LOG.info(f"Current pages from _activate_page: {self.pages}")
+        # TODO: Simplify two loops into one (with unit test)
         # get the index of the page in the self.pages list
         page_index = 0
         for i, p in enumerate(self.pages):
             if p.url == page.url:
                 page_index = i
                 break
 
         self.page_number = page_index
 
-        # set the page active attribute to True and update the self.pages list, mark all other pages as inactive
-
+        # set the page active attribute to True and update the self.pages list,
+        # mark all other pages as inactive
         page.active = True
 
         for p in self.pages:
             if p != page:
                 p.active = False
                 # update the self.pages list with the page active status changes
                 self.pages[self.pages.index(p)] = p
@@ -284,133 +344,103 @@
             namespace=self.name,
             event_name="page_gained_focus",
             data=dict(number=page_index)
         )
         send_message_to_gui(message)
 
     def remove_pages(self, positions: List[int]):
-        """Deletes one or more pages from the active page list.
+        """
+        Deletes one or more pages by index from the active page list.
 
-        Args:
-            positions: page position to remove
+        @param positions: list of int page positions to remove
         """
         LOG.info(f"Removing pages from GUI namespace {self.name}: {positions}")
+        positions.sort(reverse=True)
         for position in positions:
             page = self.pages.pop(position)
             LOG.info(f"Deleting {page} from GUI namespace {self.name}")
             message = dict(
                 type="mycroft.gui.list.remove",
                 namespace=self.name,
                 position=position,
                 items_number=1
             )
             send_message_to_gui(message)
 
-    def page_gained_focus(self, page_number):
-        """Updates the active page in self.pages
-
-        Args:
-            page_number: the page number of the page that will gain focus
+    def page_gained_focus(self, page_number: int):
+        """
+        Updates the active page in `self.pages`.
+        @param page_number: the index of the page that will gain focus
         """
         LOG.info(
             f"Page {page_number} gained focus in GUI namespace {self.name}")
         self._activate_page(self.pages[page_number])
 
     def page_update_interaction(self, page_number: int):
-        """Update the interaction of the page_number"""
+        """
+        Update the interaction of the page_number.
+        @param page_number: the index of the page to update
+        """
 
-        LOG.info(
-            f"Page {page_number} update interaction in GUI namespace {self.name}")
+        LOG.info(f"Page {page_number} update interaction in GUI namespace "
+                 f"{self.name}")
 
         page = self.pages[page_number]
         if not page.persistent and page.duration > 0:
             page.duration = page.duration / 2
 
         # update the self.pages list with the page interaction status changes
         self.pages[page_number] = page
         self.set_persistence(skill_type="genericSkill")
 
-    def get_page_at_position(self, position: int):
-        """Returns the position of the page in the active page list."""
-        return self.pages.index(position)
+    def get_page_at_position(self, position: int) -> GuiPage:
+        """
+        Returns the page at the requested position in the active page list.
+        Requesting a position out of range will raise an IndexError.
+        @param position: index of the page to get
+        """
+        return self.pages[position]
 
-    def get_active_page(self):
+    def get_active_page(self) -> Optional[GuiPage]:
         """
         Returns the currently active page from `self.pages` where the page
-        attribute active is true
+        attribute `active` is true.
+        @returns: Active GuiPage if any, else None
         """
         for page in self.pages:
             if page.active:
                 return page
         return None
 
-    def get_active_page_index(self):
-        # get the active page index in the self.pages list
+    def get_active_page_index(self) -> Optional[int]:
+        """
+        Get the active page index in `self.pages`.
+        @return: index of the active page if any, else None
+        """
         active_page = self.get_active_page()
         if active_page is not None:
             return self.pages.index(active_page)
 
-    def index_in_pages_list(self, index):
-        return (index < len(self.pages))
+    def index_in_pages_list(self, index: int) -> bool:
+        """
+        Check if the active index is in the pages list
+        @param index: index to check
+        @return: True if index is valid in `self.pages
+        """
+        return 0 < index < len(self.pages)
 
     def global_back(self):
-        """Returns to the previous page in the active page list."""
+        """
+        Returns to the previous page in the active page list.
+        """
         if self.page_number > 0:
             self.remove_pages([self.page_number])
             self.page_gained_focus(self.page_number - 1)
 
 
-def _validate_page_message(message: Message):
-    """
-    Validates the contents of the message data for page add/remove messages.
-
-    Args:
-        message: A core message bus message to add/remove one or more pages
-            from a namespace.
-    """
-    valid = (
-            "page" in message.data
-            and "__from" in message.data
-            and isinstance(message.data["page"], list)
-    )
-    if not valid:
-        if message.msg_type == "gui.page.show":
-            action = "shown"
-        else:
-            action = "removed"
-        LOG.error(
-            f"Page will not be {action} due to malformed data in the"
-            f"{message.msg_type} message"
-        )
-
-    return valid
-
-
-def _get_idle_display_config():
-    """
-    Retrieves the current value of the idle display skill configuration.
-    """
-    config = Configuration()
-    enclosure_config = config.get("gui") or {}
-    idle_display_skill = enclosure_config.get("idle_display_skill")
-    LOG.info(f"Got idle_display_skill from config: {idle_display_skill}")
-    return idle_display_skill
-
-
-def _get_active_gui_extension():
-    """
-    Retrieves the current value of the gui extension configuration.
-    """
-    config = Configuration()
-    enclosure_config = config.get("gui") or {}
-    gui_extension = enclosure_config.get("extension", "generic")
-    LOG.info(f"Got extension from config: {gui_extension}")
-    return gui_extension.lower()
-
-
 class NamespaceManager:
     """
     Manages the active namespace stack and the content of namespaces.
 
     Attributes:
         core_bus: client for communicating with the core message bus
         gui_bus: client for communicating with the GUI message bus
@@ -428,99 +458,95 @@
         self.active_namespaces = list()
         self.remove_namespace_timers = dict()
         self.idle_display_skill = _get_idle_display_config()
         self.active_extension = _get_active_gui_extension()
         self._define_message_handlers()
 
     def _define_message_handlers(self):
-        """Assigns methods as handlers for specified message types."""
+        """
+        Defines event handlers for core messagebus.
+        """
         self.core_bus.on("gui.clear.namespace", self.handle_clear_namespace)
         self.core_bus.on("gui.event.send", self.handle_send_event)
         self.core_bus.on("gui.page.delete", self.handle_delete_page)
         self.core_bus.on("gui.page.show", self.handle_show_page)
         self.core_bus.on("gui.status.request", self.handle_status_request)
         self.core_bus.on("gui.value.set", self.handle_set_value)
         self.core_bus.on("mycroft.gui.connected", self.handle_client_connected)
         self.core_bus.on("gui.page_interaction", self.handle_page_interaction)
         self.core_bus.on("gui.page_gained_focus",
                          self.handle_page_gained_focus)
 
     def handle_clear_namespace(self, message: Message):
-        """Handles a request to remove a namespace.
-
-        Args:
-            message: the message requesting namespace removal
+        """
+        Handles a request to remove a namespace.
+        @param message: the message requesting namespace removal
         """
         try:
             namespace_name = message.data['__from']
         except KeyError:
             LOG.error(
                 "Request to delete namespace failed: no namespace specified"
             )
         else:
             with namespace_lock:
                 self._remove_namespace(namespace_name)
 
     @staticmethod
     def handle_send_event(message: Message):
-        """Handles a request to send a message to the GUI message bus.
-
-        Args:
-            message: the message requesting a message to be sent to the GUI
+        """
+        Handles a request to send a message to the GUI message bus.
+        @param message: the message requesting a message to be sent to the GUI
                 message bus.
         """
         try:
             message = dict(
                 type='mycroft.events.triggered',
                 namespace=message.data.get('__from'),
                 event_name=message.data.get('event_name'),
                 data=message.data.get('params')
             )
             send_message_to_gui(message)
         except Exception:
             LOG.exception('Could not send event trigger')
 
     def handle_delete_page(self, message: Message):
-        """Handles request to remove one or more pages from a namespace.
-
-        Args:
-            message: the message requesting page removal
+        """
+        Handles request to remove one or more pages from a namespace.
+        @param message: the message requesting page removal
         """
         message_is_valid = _validate_page_message(message)
         if message_is_valid:
             namespace_name = message.data["__from"]
             pages_to_remove = message.data["page"]
             with namespace_lock:
                 self._remove_pages(namespace_name, pages_to_remove)
 
     def _remove_pages(self, namespace_name: str, pages_to_remove: List[str]):
-        """Removes one or more pages from a namespace.
-
-        Pages are removed from the bottom of the stack.
-
-        Args:
-            namespace_name: the affected namespace
-            pages_to_remove: names of pages to delete
+        """
+        Removes one or more pages from a namespace. Pages are removed from the
+        bottom of the stack.
+        @param namespace_name: the affected namespace
+        @param pages_to_remove: names of pages to delete
         """
         namespace = self.loaded_namespaces.get(namespace_name)
         if namespace is not None and namespace in self.active_namespaces:
             page_positions = []
             for index, page in enumerate(pages_to_remove):
                 # if page matches namespace.pages.url:
                 if page == namespace.pages[index].url:
                     page_positions.append(index)
 
             page_positions.sort(reverse=True)
             namespace.remove_pages(page_positions)
 
     def handle_show_page(self, message: Message):
-        """Handles a request to show one or more pages on the screen.
-
-        Args:
-            message: the message containing the page show request
+        """
+        Handles a request to show one or more pages on the screen.
+        @param message: the message containing the page show request
         """
         message_is_valid = _validate_page_message(message)
         if message_is_valid:
             namespace_name = message.data["__from"]
             pages_to_show = message.data["page"]
             persistence = message.data["__idle"]
             show_index = message.data.get("index", None)
@@ -548,18 +574,18 @@
 
             with namespace_lock:
                 self._activate_namespace(namespace_name)
                 self._load_pages(pages_to_load, show_index)
                 self._update_namespace_persistence(persistence)
 
     def _activate_namespace(self, namespace_name: str):
-        """Instructs the GUI to load a namespace and its associated data.
+        """
+        Instructs the GUI to load a namespace and its associated data.
 
-        Args:
-            namespace_name: the name of the namespace to load
+        @param namespace_name: the name of the namespace to load
         """
         namespace = self._ensure_namespace_exists(namespace_name)
         LOG.info(f"Activating namespace: {namespace_name}")
 
         if namespace in self.active_namespaces:
             namespace_position = self.active_namespaces.index(namespace)
             namespace.activate(namespace_position)
@@ -571,200 +597,194 @@
             self.active_namespaces.insert(0, namespace)
         for key, value in namespace.data.items():
             namespace.load_data(key, value)
 
         self._emit_namespace_displayed_event()
 
     def _ensure_namespace_exists(self, namespace_name: str) -> Namespace:
-        """Retrieves the requested namespace, creating one if it doesn't exist.
-
-        Args:
-            namespace_name: the name of the namespace being retrieved
-
-        Returns:
-            the requested namespace
+        """
+        Retrieves the requested namespace, creating one if it doesn't exist.
+        @param namespace_name: the name of the namespace being retrieved
+        @returns: requested namespace
         """
         # TODO: - Update sync to match.
         namespace = self.loaded_namespaces.get(namespace_name)
         if namespace is None:
             namespace = Namespace(namespace_name)
             self.loaded_namespaces[namespace_name] = namespace
 
         return namespace
 
-    def _load_pages(self, pages_to_show: List[GuiPage], show_index: None):
-        """Loads the requested pages in the namespace.
-
-        Args:
-            pages_to_show: the pages requested to be loaded
+    def _load_pages(self, pages_to_show: List[GuiPage], show_index: int):
+        """
+        Loads the requested pages in the namespace.
+        @param pages_to_show: list of pages to be loaded
+        @param show_index: index to load pages at
         """
         active_namespace = self.active_namespaces[0]
         active_namespace.load_pages(pages_to_show, show_index)
 
     def _update_namespace_persistence(self, persistence: Union[bool, int]):
-        """Sets the persistence of the namespace being activated.
-
+        """
+        Sets the persistence of the namespace being activated.
         A namespace's persistence is the same as the persistence of the
         most recent pages added to a namespace.  For example, a multi-page
         namespace could show the first set of pages with a persistence of
         True (show until removed) and the last page with a persistence of
         15 seconds.  This would ensure that the namespace isn't removed while
         the skill is showing the pages.
-
-        Args:active_extension
-            persistence: length of time the namespace should be displayed
+        @param persistence: length of time the namespace should be displayed
         """
         LOG.debug(f"Setting namespace persistence to {persistence}")
         for position, namespace in enumerate(self.active_namespaces):
             if position:
                 if not namespace.persistent:
                     self._remove_namespace(namespace.name)
             else:
                 if namespace.name == self.idle_display_skill:
                     namespace.set_persistence(skill_type="idleDisplaySkill")
                 else:
                     namespace.set_persistence(skill_type="genericSkill")
 
-                    # check if there is a scheduled remove_namespace_timer and cancel it
-                    if namespace.persistent:
-                        if namespace.name in self.remove_namespace_timers:
-                            self.remove_namespace_timers[namespace.name].cancel(
-                            )
-                            self._del_namespace_in_remove_timers(
-                                namespace.name)
+                    # check if there is a scheduled remove_namespace_timer
+                    # and cancel it
+                    if namespace.persistent and namespace.name in \
+                            self.remove_namespace_timers:
+                        self.remove_namespace_timers[namespace.name].cancel()
+                        self._del_namespace_in_remove_timers(namespace.name)
 
                 if not namespace.persistent:
                     LOG.info("It is being scheduled here")
                     self._schedule_namespace_removal(namespace)
 
     def _schedule_namespace_removal(self, namespace: Namespace):
-        """Uses a timer thread to remove the namespace.
-
-        Args:
-            namespace: the namespace to be removed
+        """
+        Uses a timer thread to remove the namespace.
+        @param namespace: the namespace to be removed
         """
         # Before removing check if there isn't already a timer for this namespace
         if namespace.name in self.remove_namespace_timers:
             return
 
         remove_namespace_timer = Timer(
             namespace.duration,
             self._remove_namespace_via_timer,
             args=(namespace.name,)
         )
-        LOG.debug(
-            f"Scheduled removal of namespace {namespace.name} in duration {namespace.duration}")
+        LOG.debug(f"Scheduled removal of namespace {namespace.name} in "
+                  f"duration {namespace.duration}")
         remove_namespace_timer.start()
         self.remove_namespace_timers[namespace.name] = remove_namespace_timer
 
     def _remove_namespace_via_timer(self, namespace_name: str):
-        """Removes a namespace and the corresponding timer instance."""
+        """
+        Removes a namespace and the corresponding timer instance.
+        @param namespace_name: name of namespace to remove
+        """
         self._remove_namespace(namespace_name)
         self._del_namespace_in_remove_timers(namespace_name)
 
     def _remove_namespace(self, namespace_name: str):
         """
         Removes a namespace from the active namespace stack.
-
-        Args:
-            namespace_name: namespace to remove
+        @param namespace_name: name of namespace to remove
         """
         LOG.debug(f"Removing namespace {namespace_name}")
 
         # Remove all timers associated with the namespace
         if namespace_name in self.remove_namespace_timers:
             self.remove_namespace_timers[namespace_name].cancel()
             self._del_namespace_in_remove_timers(namespace_name)
 
         namespace = self.loaded_namespaces.get(namespace_name)
         if namespace is not None and namespace in self.active_namespaces:
-            self.core_bus.emit(Message("gui.namespace.removed", data={
-                "skill_id": namespace.name}))
+            self.core_bus.emit(Message("gui.namespace.removed",
+                                       data={"skill_id": namespace.name}))
             if self.active_extension == "Bigscreen":
+                # TODO: Define callback or event instead of arbitrary sleep
                 # wait for window management in bigscreen extension to finish
                 sleep(1)
             namespace_position = self.active_namespaces.index(namespace)
             namespace.remove(namespace_position)
             self.active_namespaces.remove(namespace)
 
         self._emit_namespace_displayed_event()
 
     def _emit_namespace_displayed_event(self):
+        """
+        Emit a `gui.namespace.displayed` Message to notify core of changes.
+        """
         if self.active_namespaces:
             displaying_namespace = self.active_namespaces[0]
             message_data = dict(skill_id=displaying_namespace.name)
             self.core_bus.emit(
                 Message("gui.namespace.displayed", data=message_data)
             )
 
     def handle_status_request(self, message: Message):
-        """Handles a GUI status request by replying with the connection status.
-
-        Args:
-            message: the request for status of the GUI
+        """
+        Handles a GUI status request by replying with the connection status.
+        @param message: the request for status of the GUI
         """
         gui_connected = determine_if_gui_connected()
         reply = message.reply(
             "gui.status.request.response", dict(connected=gui_connected)
         )
         self.core_bus.emit(reply)
 
     def handle_set_value(self, message: Message):
-        """Handles a request to set the value of namespace data attributes.
-
-        Args:
-            message: the request to set attribute values
+        """
+        Handles a request to set the value of namespace data attributes.
+        @param message: the request to set attribute values
         """
         try:
             namespace_name = message.data['__from']
         except KeyError:
             LOG.error(
                 "Request to set gui attribute value failed: no "
                 "namespace specified"
             )
         else:
             with namespace_lock:
                 self._update_namespace_data(namespace_name, message.data)
 
     def _update_namespace_data(self, namespace_name: str, data: dict):
-        """Updates the values of namespace data attributes, unless unchanged.
-
-        Args:
-            namespace_name: the name of the namespace to update
-            data: the name and new value of one or more data attributes
+        """
+        Updates the values of namespace data attributes, unless unchanged.
+        @param namespace_name: the name of the namespace to update
+        @param data: the name and new value of one or more data attributes
         """
         namespace = self._ensure_namespace_exists(namespace_name)
         for key, value in data.items():
             if key not in RESERVED_KEYS and namespace.data.get(key) != value:
                 LOG.debug(
                     f"Setting {key} to {value} in namespace {namespace.name}")
                 namespace.data[key] = value
                 if namespace in self.active_namespaces:
                     namespace.load_data(key, value)
 
     def handle_client_connected(self, message: Message):
-        """Handles an event from the GUI indicating it is connected to the bus.
-
-        Args:
-            message: the event sent by the GUI
+        """
+        Handles an event from the GUI indicating it is connected to the bus.
+        @param message: the event sent by the GUI
         """
         # GUI has announced presence
         # Announce connection, the GUI should connect on it soon
         gui_id = message.data.get("gui_id")
         LOG.info(f"GUI with ID {gui_id} connected to core message bus")
         websocket_config = get_gui_websocket_config()
         port = websocket_config["base_port"]
-        message = Message("mycroft.gui.port", dict(port=port, gui_id=gui_id))
+        message = message.forward("mycroft.gui.port",
+                                  dict(port=port, gui_id=gui_id))
         self.core_bus.emit(message)
 
     def handle_page_interaction(self, message: Message):
-        """Handles an event from the GUI indicating the page has been interacted with.
-
-        Args:
-            message: the event sent by the GUI
+        """
+        Handles an event from the GUI indicating a page has been interacted with.
+        @param message: the event sent by the GUI
         """
         # GUI has interacted with a page
         # Update and increase the namespace duration and reset the remove timer
         namespace_name = message.data.get("skill_id")
         LOG.debug(f"GUI interacted with page in namespace {namespace_name}")
         if namespace_name == self.idle_display_skill:
             return
@@ -773,42 +793,40 @@
             if not namespace.persistent:
                 if self.remove_namespace_timers[namespace.name]:
                     self.remove_namespace_timers[namespace.name].cancel()
                     self._del_namespace_in_remove_timers(namespace.name)
                     self._schedule_namespace_removal(namespace)
 
     def handle_page_gained_focus(self, message: Message):
-        """Handles focus events from the GUI indicating the page has gained focus.
-
-        Args:
-            message: the event sent by the GUI
+        """
+        Handles focus events from the GUI indicating the page has gained focus.
+        @param message: the event sent by the GUI
         """
         namespace_name = message.data.get("skill_id")
         namespace_page_number = message.data.get("page_number")
         LOG.debug(f"Page in namespace {namespace_name} gained focus")
         namespace = self.loaded_namespaces.get(namespace_name)
 
         # first check if the namespace is already active
         if namespace in self.active_namespaces:
-            # if the namespace is already active, check if the page number has changed
+            # if the namespace is already active,
+            # check if the page number has changed
             if namespace_page_number != namespace.page_number:
                 namespace.page_gained_focus(namespace_page_number)
 
-    def handle_namespace_global_back(self, message: None):
-        """Handles global back events from the GUI.
-
-        Args:
-            message: the event sent by the GUI
+    def handle_namespace_global_back(self, message: Optional[Message]):
+        """
+        Handles global back events from the GUI.
+        @param message: the event sent by the GUI
         """
         namespace_name = self.active_namespaces[0].name
         namespace = self.loaded_namespaces.get(namespace_name)
         if namespace in self.active_namespaces:
             namespace.global_back()
 
-    def _del_namespace_in_remove_timers(self, namespace_name):
-        """ Delete namespace from remove_namespace_timers dict.
-
-        Args:
-            namespace: namespace to be deleted
+    def _del_namespace_in_remove_timers(self, namespace_name: str):
+        """
+        Delete namespace from remove_namespace_timers dict.
+        @param namespace_name: name of namespace to be deleted
         """
         if namespace_name in self.remove_namespace_timers:
             del self.remove_namespace_timers[namespace_name]
```

## ovos_gui/page.py

```diff
@@ -1,26 +1,18 @@
 from ovos_utils.log import LOG
 
 
 class GuiPage:
-    """ A representation of a GUI Page
-
-    A GuiPage represents a single GUI Display within a given namespace. A Page
-    has a name, a position and can have either Persistence or Duration during
-    which it will exist
-
-    Attributes:
-         name: the name of the page that is shown in a given namespace, assigned
-         by the skill author
-         persistent: indicated weather or not the page itself should persists for a
-         period of time or unit the it is removed manually
-         duration: the duration of the page in the namespace, assigned by the skill
-         author if the page is not persistent
-         active: indicates whether the page is currently active in the namespace
-    """
-
     def __init__(self, url: str, name: str, persistent: bool, duration: int):
+        """
+        A GuiPage represents a single GUI Display within a given namespace.
+        A Page can either be `persistent` or be removed after some `duration`.
+        @param url: URI (local or network path) of the GUI Page
+        @param name: Name of the page as shown in its namespace
+        @param persistent: If True, page is displayed indefinitely
+        @param duration: Number of seconds to display the page for
+        """
         self.url = url
         self.name = name
         self.persistent = persistent
         self.duration = duration
         self.active = False
```

## ovos_gui/service.py

```diff
@@ -23,47 +23,56 @@
 
 
 def on_stopping():
     LOG.info('Gui Service is shutting down...')
 
 
 class GUIService:
-    def __init__(self, alive_hook=on_alive, started_hook=on_started, ready_hook=on_ready,
-                 error_hook=on_error, stopping_hook=on_stopping):
+    def __init__(self, alive_hook=on_alive, started_hook=on_started,
+                 ready_hook=on_ready, error_hook=on_error,
+                 stopping_hook=on_stopping):
         self.bus = MessageBusClient()
         self.extension_manager = None
         self.gui = NamespaceManager(self.bus)
         callbacks = StatusCallbackMap(on_started=started_hook,
                                       on_alive=alive_hook,
                                       on_ready=ready_hook,
                                       on_error=error_hook,
                                       on_stopping=stopping_hook)
         self.status = ProcessStatus('gui_service', callback_map=callbacks)
         self.status.bind(self.bus)
 
     def _init_bus_client(self):
-        """Start the bus client daemon and wait for connection."""
+        """
+        Start the bus client daemon and wait for connection.
+        """
         # Wait for connection
         Configuration.set_config_update_handlers(self.bus)
         if not self.bus.connected_event.is_set():
             self.bus.run_in_thread()
         self.bus.connected_event.wait()
         LOG.info('Connected to messagebus')
 
     def run(self):
-        """Start the GUI after it has been constructed."""
+        """
+        Start the GUI after it has been constructed.
+        """
         # Allow exceptions to be raised to the GUI Service
         # if they may cause the Service to fail.
         self.status.set_alive()
         self._init_bus_client()
         self.extension_manager = ExtensionsManager("EXTENSION_SERVICE",
                                                    self.bus, self.gui)
         self.status.set_ready()
         LOG.info(f"GUI Service Ready")
 
-    def is_alive(self):
-        """Respond to is_alive status request."""
+    def is_alive(self) -> bool:
+        """
+        Respond to is_alive status request.
+        """
         return self.status.state >= ProcessState.ALIVE
 
     def stop(self):
-        """Perform any GUI shutdown processes."""
+        """
+        Perform any GUI shutdown processes.
+        """
         self.status.set_stopping()
```

## ovos_gui/tui.py

```diff
@@ -1,15 +1,14 @@
-from os import getpid
-from os.path import basename
 import json
+
+from os.path import basename
 from time import sleep
 from pprint import pformat
-
 from ovos_utils.log import LOG
-from ovos_bus_client import GUIMessage, GUIWebsocketClient
+from ovos_bus_client import GUIWebsocketClient
 
 
 def get_websocket(host="0.0.0.0", port=18181, route='/', ssl=False, threaded=True):
     """
     Returns a connection to a websocket
     """
     client = GUIWebsocketClient(host, port, route, ssl)
@@ -169,8 +168,8 @@
 
 def main():
     gui = GUIDebugger()
     gui.run()
 
 
 if __name__ == "__main__":
-    main()
+    main()
```

## ovos_gui/version.py

```diff
@@ -1,6 +1,6 @@
 # START_VERSION_BLOCK
 VERSION_MAJOR = 0
 VERSION_MINOR = 0
 VERSION_BUILD = 3
-VERSION_ALPHA = 5
+VERSION_ALPHA = 6
 # END_VERSION_BLOCK
```

## Comparing `ovos_gui-0.0.3a5.dist-info/LICENSE.md` & `ovos_gui-0.0.3a6.dist-info/LICENSE.md`

 * *Files identical despite different names*

