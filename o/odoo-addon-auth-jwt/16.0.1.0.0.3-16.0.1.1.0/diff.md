# Comparing `tmp/odoo_addon_auth_jwt-16.0.1.0.0.3-py3-none-any.whl.zip` & `tmp/odoo_addon_auth_jwt-16.0.1.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 34652 bytes, number of entries: 22
--rw-r--r--  2.0 unx     5703 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/README.rst
--rw-r--r--  2.0 unx       21 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/__init__.py
--rw-r--r--  2.0 unx      576 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/__manifest__.py
--rw-r--r--  2.0 unx     1048 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/exceptions.py
--rw-r--r--  2.0 unx     8158 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/i18n/auth_jwt.pot
--rw-r--r--  2.0 unx       55 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/models/__init__.py
--rw-r--r--  2.0 unx     8509 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/models/auth_jwt_validator.py
--rw-r--r--  2.0 unx     3948 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/models/ir_http.py
--rw-r--r--  2.0 unx       47 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/readme/CONTRIBUTORS.rst
--rw-r--r--  2.0 unx       33 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/readme/DESCRIPTION.rst
--rw-r--r--  2.0 unx       60 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/readme/INSTALL.rst
--rw-r--r--  2.0 unx     2821 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/readme/USAGE.rst
--rw-r--r--  2.0 unx      185 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/security/ir.model.access.csv
--rw-r--r--  2.0 unx     9455 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/static/description/icon.png
--rw-r--r--  2.0 unx    16331 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/static/description/index.html
--rw-r--r--  2.0 unx       28 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/tests/__init__.py
--rw-r--r--  2.0 unx    17851 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/tests/test_auth_jwt.py
--rw-r--r--  2.0 unx     4124 b- defN 23-Jun-07 11:20 odoo/addons/auth_jwt/views/auth_jwt_validator_views.xml
--rw-r--r--  2.0 unx     6301 b- defN 23-Jun-07 11:20 odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-07 11:20 odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 23-Jun-07 11:20 odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2130 b- defN 23-Jun-07 11:20 odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/RECORD
-22 files, 87481 bytes uncompressed, 31064 bytes compressed:  64.5%
+Zip file size: 37163 bytes, number of entries: 22
+-rw-r--r--  2.0 unx     6285 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/README.rst
+-rw-r--r--  2.0 unx       21 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/__init__.py
+-rw-r--r--  2.0 unx      576 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/__manifest__.py
+-rw-r--r--  2.0 unx     1176 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/exceptions.py
+-rw-r--r--  2.0 unx    10320 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/i18n/auth_jwt.pot
+-rw-r--r--  2.0 unx       55 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/models/__init__.py
+-rw-r--r--  2.0 unx    11461 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/models/auth_jwt_validator.py
+-rw-r--r--  2.0 unx     5472 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/models/ir_http.py
+-rw-r--r--  2.0 unx       47 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/readme/CONTRIBUTORS.rst
+-rw-r--r--  2.0 unx       33 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/readme/DESCRIPTION.rst
+-rw-r--r--  2.0 unx       60 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/readme/INSTALL.rst
+-rw-r--r--  2.0 unx     3403 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/readme/USAGE.rst
+-rw-r--r--  2.0 unx      185 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/security/ir.model.access.csv
+-rw-r--r--  2.0 unx     9455 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/static/description/icon.png
+-rw-r--r--  2.0 unx    16979 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/static/description/index.html
+-rw-r--r--  2.0 unx       28 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/tests/__init__.py
+-rw-r--r--  2.0 unx    18015 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/tests/test_auth_jwt.py
+-rw-r--r--  2.0 unx     5054 b- defN 23-Jun-23 15:12 odoo/addons/auth_jwt/views/auth_jwt_validator_views.xml
+-rw-r--r--  2.0 unx     6881 b- defN 23-Jun-23 15:12 odoo_addon_auth_jwt-16.0.1.1.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-23 15:12 odoo_addon_auth_jwt-16.0.1.1.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-Jun-23 15:12 odoo_addon_auth_jwt-16.0.1.1.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2124 b- defN 23-Jun-23 15:12 odoo_addon_auth_jwt-16.0.1.1.0.dist-info/RECORD
+22 files, 97727 bytes uncompressed, 33591 bytes compressed:  65.6%
```

## zipnote {}

```diff
@@ -48,20 +48,20 @@
 
 Filename: odoo/addons/auth_jwt/tests/test_auth_jwt.py
 Comment: 
 
 Filename: odoo/addons/auth_jwt/views/auth_jwt_validator_views.xml
 Comment: 
 
-Filename: odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/METADATA
+Filename: odoo_addon_auth_jwt-16.0.1.1.0.dist-info/METADATA
 Comment: 
 
-Filename: odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/WHEEL
+Filename: odoo_addon_auth_jwt-16.0.1.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/top_level.txt
+Filename: odoo_addon_auth_jwt-16.0.1.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/RECORD
+Filename: odoo_addon_auth_jwt-16.0.1.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## odoo/addons/auth_jwt/README.rst

```diff
@@ -62,15 +62,16 @@
 * ``issuer``: used to validate the ``iss`` claim.
 * Signature type (secret or public key), algorithm, secret and JWK URI
   are used to validate the token signature.
 
 In addition, the ``exp`` claim is validated to reject expired tokens.
 
 If the ``Authorization`` HTTP header is missing, malformed, or contains
-an invalid token, the request is rejected with a 401 (Unauthorized) code.
+an invalid token, the request is rejected with a 401 (Unauthorized) code,
+unless the cookie mode is enabled (see below).
 
 If the token is valid, the request executes with the configured user id. By
 default the user id selection strategy is ``static`` (i.e. the same for all
 requests) and the selected user is configured on the JWT validator. Additional
 strategies can be provided by overriding the ``_get_uid()`` method and
 extending the ``user_id_strategy`` selection field.
 
@@ -92,14 +93,22 @@
 method when the Authorization header is not set. If it is set, the regular JWT
 authentication is performed as described above. This method is useful for public
 endpoints that need to work for anonymous users, but can be enhanced when an
 authenticated user is know. A typical use case is a "add to cart" endpoint that can work
 for anonymous users, but can be enhanced by binding the cart to a known customer when
 the authenticated user is known.
 
+You can enable a cookie mode on JWT validators. In this case, the JWT payload obtained
+from the ``Authorization`` header is returned as a Http-Only cookie. This mode is
+sometimes simpler for front-end applications which do not then need to store and protect
+the JWT token across requests and can simply rely on the cookie management mechanisms of
+browsers. When both the ``Authorization`` header and a cookie are provided, the cookie
+is ignored in order to let clients authenticate with a different user by providing a new
+JWT token.
+
 Bug Tracker
 ===========
 
 Bugs are tracked on `GitHub Issues <https://github.com/OCA/server-auth/issues>`_.
 In case of trouble, please check there if your issue has already been reported.
 If you spotted it first, help us smashing it by providing a detailed and welcomed
 `feedback <https://github.com/OCA/server-auth/issues/new?body=module:%20auth_jwt%0Aversion:%2016.0%0A%0A**Steps%20to%20reproduce**%0A-%20...%0A%0A**Current%20behavior**%0A%0A**Expected%20behavior**>`_.
```

## odoo/addons/auth_jwt/__manifest__.py

```diff
@@ -1,15 +1,15 @@
 # Copyright 2021 ACSONE SA/NV
 # License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).
 
 {
     "name": "Auth JWT",
     "summary": """
         JWT bearer token authentication.""",
-    "version": "16.0.1.0.0",
+    "version": "16.0.1.1.0",
     "license": "LGPL-3",
     "author": "ACSONE SA/NV,Odoo Community Association (OCA)",
     "maintainers": ["sbidoul"],
     "website": "https://github.com/OCA/server-auth",
     "depends": [],
     "external_dependencies": {"python": ["pyjwt", "cryptography"]},
     "data": ["security/ir.model.access.csv", "views/auth_jwt_validator_views.xml"],
```

## odoo/addons/auth_jwt/exceptions.py

```diff
@@ -4,14 +4,18 @@
 from werkzeug.exceptions import InternalServerError, Unauthorized
 
 
 class UnauthorizedMissingAuthorizationHeader(Unauthorized):
     pass
 
 
+class UnauthorizedMissingCookie(Unauthorized):
+    pass
+
+
 class UnauthorizedMalformedAuthorizationHeader(Unauthorized):
     pass
 
 
 class UnauthorizedSessionMismatch(Unauthorized):
     pass
 
@@ -28,19 +32,23 @@
     pass
 
 
 class UnauthorizedPartnerNotFound(Unauthorized):
     pass
 
 
-class CompositeJwtError(Unauthorized):
+class UnauthorizedCompositeJwtError(Unauthorized):
     """Indicate that multiple errors occurred during JWT chain validation."""
 
     def __init__(self, errors):
         self.errors = errors
         super().__init__(
             "Multiple errors occurred during JWT chain validation:\n"
             + "\n".join(
                 "{}: {}".format(validator_name, error)
                 for validator_name, error in self.errors.items()
             )
         )
+
+
+class ConfigurationError(InternalServerError):
+    pass
```

## odoo/addons/auth_jwt/i18n/auth_jwt.pot

```diff
@@ -10,14 +10,23 @@
 "Language-Team: \n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: \n"
 "Plural-Forms: \n"
 
 #. module: auth_jwt
+#. odoo-python
+#: code:addons/auth_jwt/models/auth_jwt_validator.py:0
+#, python-format
+msgid ""
+"A cookie name must be provided on JWT validator %s because it has cookie "
+"mode enabled."
+msgstr ""
+
+#. module: auth_jwt
 #: model_terms:ir.ui.view,arch_db:auth_jwt.view_auth_jwt_validator_form
 msgid "Algorithm"
 msgstr ""
 
 #. module: auth_jwt
 #: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__audience
 msgid "Audience"
@@ -25,14 +34,52 @@
 
 #. module: auth_jwt
 #: model:ir.model.fields,help:auth_jwt.field_auth_jwt_validator__audience
 msgid "Comma separated list of audiences, to validate aud."
 msgstr ""
 
 #. module: auth_jwt
+#: model:ir.model.fields,help:auth_jwt.field_auth_jwt_validator__cookie_enabled
+msgid ""
+"Convert the JWT token into an HttpOnly Secure cookie. When both an "
+"Authorization header and the cookie are present in the request, the cookie "
+"is ignored."
+msgstr ""
+
+#. module: auth_jwt
+#: model_terms:ir.ui.view,arch_db:auth_jwt.view_auth_jwt_validator_form
+msgid "Cookie"
+msgstr ""
+
+#. module: auth_jwt
+#: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__cookie_enabled
+msgid "Cookie Enabled"
+msgstr ""
+
+#. module: auth_jwt
+#: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__cookie_max_age
+msgid "Cookie Max Age"
+msgstr ""
+
+#. module: auth_jwt
+#: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__cookie_name
+msgid "Cookie Name"
+msgstr ""
+
+#. module: auth_jwt
+#: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__cookie_path
+msgid "Cookie Path"
+msgstr ""
+
+#. module: auth_jwt
+#: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__cookie_secure
+msgid "Cookie Secure"
+msgstr ""
+
+#. module: auth_jwt
 #: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__create_uid
 msgid "Created by"
 msgstr ""
 
 #. module: auth_jwt
 #: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__create_date
 msgid "Created on"
@@ -65,14 +112,19 @@
 
 #. module: auth_jwt
 #: model:ir.model.fields.selection,name:auth_jwt.selection__auth_jwt_validator__partner_id_strategy__email
 msgid "From email claim"
 msgstr ""
 
 #. module: auth_jwt
+#: model_terms:ir.ui.view,arch_db:auth_jwt.view_auth_jwt_validator_form
+msgid "General"
+msgstr ""
+
+#. module: auth_jwt
 #: model:ir.model.fields.selection,name:auth_jwt.selection__auth_jwt_validator__secret_algorithm__hs256
 msgid "HS256 - HMAC using SHA-256 hash algorithm"
 msgstr ""
 
 #. module: auth_jwt
 #: model:ir.model.fields.selection,name:auth_jwt.selection__auth_jwt_validator__secret_algorithm__hs384
 msgid "HS384 - HMAC using SHA-384 hash algorithm"
@@ -158,14 +210,19 @@
 
 #. module: auth_jwt
 #: model:ir.model.fields,help:auth_jwt.field_auth_jwt_validator__next_validator_id
 msgid "Next validator to try if this one fails"
 msgstr ""
 
 #. module: auth_jwt
+#: model:ir.model.fields,help:auth_jwt.field_auth_jwt_validator__cookie_max_age
+msgid "Number of seconds until the cookie expires (Max-Age)."
+msgstr ""
+
+#. module: auth_jwt
 #: model:ir.model.fields.selection,name:auth_jwt.selection__auth_jwt_validator__public_key_algorithm__ps256
 msgid "PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256"
 msgstr ""
 
 #. module: auth_jwt
 #: model:ir.model.fields.selection,name:auth_jwt.selection__auth_jwt_validator__public_key_algorithm__ps384
 msgid "PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384"
@@ -173,14 +230,19 @@
 
 #. module: auth_jwt
 #: model:ir.model.fields.selection,name:auth_jwt.selection__auth_jwt_validator__public_key_algorithm__ps512
 msgid "PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512"
 msgstr ""
 
 #. module: auth_jwt
+#: model_terms:ir.ui.view,arch_db:auth_jwt.view_auth_jwt_validator_form
+msgid "Partner"
+msgstr ""
+
+#. module: auth_jwt
 #: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__partner_id_required
 msgid "Partner Id Required"
 msgstr ""
 
 #. module: auth_jwt
 #: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__partner_id_strategy
 msgid "Partner Id Strategy"
@@ -228,14 +290,19 @@
 
 #. module: auth_jwt
 #: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__secret_key
 msgid "Secret Key"
 msgstr ""
 
 #. module: auth_jwt
+#: model:ir.model.fields,help:auth_jwt.field_auth_jwt_validator__cookie_secure
+msgid "Set to false only for development without https."
+msgstr ""
+
+#. module: auth_jwt
 #: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__signature_type
 msgid "Signature Type"
 msgstr ""
 
 #. module: auth_jwt
 #: model:ir.model.fields.selection,name:auth_jwt.selection__auth_jwt_validator__user_id_strategy__static
 msgid "Static"
@@ -248,14 +315,24 @@
 
 #. module: auth_jwt
 #: model:ir.model.fields,help:auth_jwt.field_auth_jwt_validator__issuer
 msgid "To validate iss."
 msgstr ""
 
 #. module: auth_jwt
+#: model_terms:ir.ui.view,arch_db:auth_jwt.view_auth_jwt_validator_form
+msgid "Token validation"
+msgstr ""
+
+#. module: auth_jwt
+#: model_terms:ir.ui.view,arch_db:auth_jwt.view_auth_jwt_validator_form
+msgid "User"
+msgstr ""
+
+#. module: auth_jwt
 #: model:ir.model.fields,field_description:auth_jwt.field_auth_jwt_validator__user_id_strategy
 msgid "User Id Strategy"
 msgstr ""
 
 #. module: auth_jwt
 #. odoo-python
 #: code:addons/auth_jwt/models/auth_jwt_validator.py:0
```

## odoo/addons/auth_jwt/models/auth_jwt_validator.py

```diff
@@ -1,29 +1,37 @@
 # Copyright 2021 ACSONE SA/NV
 # License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).
 
+import datetime
 import logging
+import re
+from calendar import timegm
 from functools import partial
 
 import jwt  # pylint: disable=missing-manifest-dependency
 from jwt import PyJWKClient
 from werkzeug.exceptions import InternalServerError
 
 from odoo import _, api, fields, models, tools
 from odoo.exceptions import ValidationError
 
 from ..exceptions import (
     AmbiguousJwtValidator,
+    ConfigurationError,
     JwtValidatorNotFound,
     UnauthorizedInvalidToken,
+    UnauthorizedMalformedAuthorizationHeader,
+    UnauthorizedMissingAuthorizationHeader,
     UnauthorizedPartnerNotFound,
 )
 
 _logger = logging.getLogger(__name__)
 
+AUTHORIZATION_RE = re.compile(r"^Bearer ([^ ]+)$")
+
 
 class AuthJwtValidator(models.Model):
     _name = "auth.jwt.validator"
     _description = "JWT Validator Configuration"
 
     name = fields.Char(required=True)
     signature_type = fields.Selection(
@@ -69,14 +77,31 @@
 
     next_validator_id = fields.Many2one(
         "auth.jwt.validator",
         domain="[('id', '!=', id)]",
         help="Next validator to try if this one fails",
     )
 
+    cookie_enabled = fields.Boolean(
+        help=(
+            "Convert the JWT token into an HttpOnly Secure cookie. "
+            "When both an Authorization header and the cookie are present "
+            "in the request, the cookie is ignored."
+        )
+    )
+    cookie_name = fields.Char(default="authorization")
+    cookie_path = fields.Char(default="/")
+    cookie_max_age = fields.Integer(
+        default=86400 * 365,
+        help="Number of seconds until the cookie expires (Max-Age).",
+    )
+    cookie_secure = fields.Boolean(
+        default=True, help="Set to false only for development without https."
+    )
+
     _sql_constraints = [
         ("name_uniq", "unique(name)", "JWT validator names must be unique !"),
     ]
 
     @api.constrains("name")
     def _check_name(self):
         for rec in self:
@@ -97,14 +122,26 @@
                 if rec == validator:
                     raise ValidationError(
                         _("Validators mustn't make a closed chain: {}.").format(
                             " -> ".join(chain)
                         )
                     )
 
+    @api.constrains("cookie_enabled", "cookie_name")
+    def _check_cookie_name(self):
+        for rec in self:
+            if rec.cookie_enabled and not rec.cookie_name:
+                raise ValidationError(
+                    _(
+                        "A cookie name must be provided on JWT validator %s "
+                        "because it has cookie mode enabled."
+                    )
+                    % (rec.name,)
+                )
+
     @api.model
     def _get_validator_by_name_domain(self, validator_name):
         if validator_name:
             return [("name", "=", validator_name)]
         return []
 
     @api.model
@@ -122,17 +159,35 @@
         return validator
 
     @tools.ormcache("self.public_key_jwk_uri", "kid")
     def _get_key(self, kid):
         jwks_client = PyJWKClient(self.public_key_jwk_uri, cache_keys=False)
         return jwks_client.get_signing_key(kid).key
 
-    def _decode(self, token):
+    def _encode(self, payload, secret, expire):
+        """Encode and sign a JWT payload so it can be decoded and validated with
+        _decode().
+
+        The aud and iss claims are set to this validator's values.
+        The exp claim is set according to the expire parameter.
+        """
+        payload = dict(
+            payload,
+            exp=timegm(datetime.datetime.utcnow().utctimetuple()) + expire,
+            aud=self.audience,
+            iss=self.issuer,
+        )
+        return jwt.encode(payload, key=secret, algorithm="HS256")
+
+    def _decode(self, token, secret=None):
         """Validate and decode a JWT token, return the payload."""
-        if self.signature_type == "secret":
+        if secret:
+            key = secret
+            algorithm = "HS256"
+        elif self.signature_type == "secret":
             key = self.secret_key
             algorithm = self.secret_algorithm
         else:
             try:
                 header = jwt.get_unverified_header(token)
             except Exception as e:
                 _logger.info("Invalid token: %s", e)
@@ -231,7 +286,31 @@
         res = super().write(vals)
         self._register_auth_method()
         return res
 
     def unlink(self):
         self._unregister_auth_method()
         return super().unlink()
+
+    def _get_jwt_cookie_secret(self):
+        secret = self.env["ir.config_parameter"].sudo().get_param("database.secret")
+        if not secret:
+            _logger.error("database.secret system parameter is not set.")
+            raise ConfigurationError()
+        return secret
+
+    @api.model
+    def _parse_bearer_authorization(self, authorization):
+        """Parse a Bearer token authorization header and return the token.
+
+        Raises UnauthorizedMissingAuthorizationHeader if authorization is falsy.
+        Raises UnauthorizedMalformedAuthorizationHeader if invalid.
+        """
+        if not authorization:
+            _logger.info("Missing Authorization header.")
+            raise UnauthorizedMissingAuthorizationHeader()
+        # https://tools.ietf.org/html/rfc6750#section-2.1
+        mo = AUTHORIZATION_RE.match(authorization)
+        if not mo:
+            _logger.info("Malformed Authorization header.")
+            raise UnauthorizedMalformedAuthorizationHeader()
+        return mo.group(1)
```

## odoo/addons/auth_jwt/models/ir_http.py

```diff
@@ -1,29 +1,27 @@
 # Copyright 2021 ACSONE SA/NV
 # License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).
 
 import logging
-import re
 
 from odoo import SUPERUSER_ID, api, models
 from odoo.http import request
 
 from ..exceptions import (
-    CompositeJwtError,
-    UnauthorizedMalformedAuthorizationHeader,
+    ConfigurationError,
+    Unauthorized,
+    UnauthorizedCompositeJwtError,
     UnauthorizedMissingAuthorizationHeader,
+    UnauthorizedMissingCookie,
     UnauthorizedSessionMismatch,
 )
 
 _logger = logging.getLogger(__name__)
 
 
-AUTHORIZATION_RE = re.compile(r"^Bearer ([^ ]+)$")
-
-
 class IrHttpJwt(models.AbstractModel):
 
     _inherit = "ir.http"
 
     @classmethod
     def _authenticate(cls, endpoint):
         """Protect the _authenticate method.
@@ -51,58 +49,96 @@
                 _logger.error(
                     "A route with auth='jwt' should not have a request.uid here."
                 )
                 raise UnauthorizedSessionMismatch()
         return super()._authenticate(endpoint)
 
     @classmethod
+    def _get_jwt_payload(cls, validator):
+        """Obtain and validate the JWT payload from the request authorization header or
+        cookie."""
+        try:
+            token = cls._get_bearer_token()
+            assert token
+            return validator._decode(token)
+        except UnauthorizedMissingAuthorizationHeader:
+            if not validator.cookie_enabled:
+                raise
+            token = cls._get_cookie_token(validator.cookie_name)
+            assert token
+            return validator._decode(token, secret=validator._get_jwt_cookie_secret())
+
+    @classmethod
     def _auth_method_jwt(cls, validator_name=None):
         assert not request.uid
         assert not request.session.uid
-        token = cls._get_bearer_token()
-        assert token
         # # Use request cursor to allow partner creation strategy in validator
         env = api.Environment(request.cr, SUPERUSER_ID, {})
         validator = env["auth.jwt.validator"]._get_validator_by_name(validator_name)
         assert len(validator) == 1
 
         payload = None
         exceptions = {}
         while validator:
             try:
-                payload = validator._decode(token)
+                payload = cls._get_jwt_payload(validator)
                 break
-            except Exception as e:
+            except Unauthorized as e:
                 exceptions[validator.name] = e
                 validator = validator.next_validator_id
 
         if not payload:
             if len(exceptions) == 1:
                 raise list(exceptions.values())[0]
-            raise CompositeJwtError(exceptions)
+            raise UnauthorizedCompositeJwtError(exceptions)
+
+        if validator.cookie_enabled:
+            if not validator.cookie_name:
+                _logger.info("Cookie name not set for validator %s", validator.name)
+                raise ConfigurationError()
+            request.future_response.set_cookie(
+                key=validator.cookie_name,
+                value=validator._encode(
+                    payload,
+                    secret=validator._get_jwt_cookie_secret(),
+                    expire=validator.cookie_max_age,
+                ),
+                max_age=validator.cookie_max_age,
+                path=validator.cookie_path or "/",
+                secure=validator.cookie_secure,
+                httponly=True,
+            )
 
         uid = validator._get_and_check_uid(payload)
         assert uid
         partner_id = validator._get_and_check_partner_id(payload)
         request.update_env(user=uid)
         request.jwt_payload = payload
         request.jwt_partner_id = partner_id
 
     @classmethod
     def _auth_method_public_or_jwt(cls, validator_name=None):
         if "HTTP_AUTHORIZATION" not in request.httprequest.environ:
-            return cls._auth_method_public()
+            env = api.Environment(request.cr, SUPERUSER_ID, {})
+            validator = env["auth.jwt.validator"]._get_validator_by_name(validator_name)
+            assert len(validator) == 1
+            if not validator.cookie_enabled or not request.httprequest.cookies.get(
+                validator.cookie_name
+            ):
+                return cls._auth_method_public()
         return cls._auth_method_jwt(validator_name)
 
     @classmethod
     def _get_bearer_token(cls):
         # https://tools.ietf.org/html/rfc2617#section-3.2.2
         authorization = request.httprequest.environ.get("HTTP_AUTHORIZATION")
-        if not authorization:
-            _logger.info("Missing Authorization header.")
-            raise UnauthorizedMissingAuthorizationHeader()
-        # https://tools.ietf.org/html/rfc6750#section-2.1
-        mo = AUTHORIZATION_RE.match(authorization)
-        if not mo:
-            _logger.info("Malformed Authorization header.")
-            raise UnauthorizedMalformedAuthorizationHeader()
-        return mo.group(1)
+        return request.env["auth.jwt.validator"]._parse_bearer_authorization(
+            authorization
+        )
+
+    @classmethod
+    def _get_cookie_token(cls, cookie_name):
+        token = request.httprequest.cookies.get(cookie_name)
+        if not token:
+            _logger.info("Missing cookie %s.", cookie_name)
+            raise UnauthorizedMissingCookie()
+        return token
```

## odoo/addons/auth_jwt/readme/USAGE.rst

```diff
@@ -20,15 +20,16 @@
 * ``issuer``: used to validate the ``iss`` claim.
 * Signature type (secret or public key), algorithm, secret and JWK URI
   are used to validate the token signature.
 
 In addition, the ``exp`` claim is validated to reject expired tokens.
 
 If the ``Authorization`` HTTP header is missing, malformed, or contains
-an invalid token, the request is rejected with a 401 (Unauthorized) code.
+an invalid token, the request is rejected with a 401 (Unauthorized) code,
+unless the cookie mode is enabled (see below).
 
 If the token is valid, the request executes with the configured user id. By
 default the user id selection strategy is ``static`` (i.e. the same for all
 requests) and the selected user is configured on the JWT validator. Additional
 strategies can be provided by overriding the ``_get_uid()`` method and
 extending the ``user_id_strategy`` selection field.
 
@@ -49,7 +50,15 @@
 The ``public_auth_jwt`` method delegates authentication to the standard Odoo ``public``
 method when the Authorization header is not set. If it is set, the regular JWT
 authentication is performed as described above. This method is useful for public
 endpoints that need to work for anonymous users, but can be enhanced when an
 authenticated user is know. A typical use case is a "add to cart" endpoint that can work
 for anonymous users, but can be enhanced by binding the cart to a known customer when
 the authenticated user is known.
+
+You can enable a cookie mode on JWT validators. In this case, the JWT payload obtained
+from the ``Authorization`` header is returned as a Http-Only cookie. This mode is
+sometimes simpler for front-end applications which do not then need to store and protect
+the JWT token across requests and can simply rely on the cookie management mechanisms of
+browsers. When both the ``Authorization`` header and a cookie are provided, the cookie
+is ignored in order to let clients authenticate with a different user by providing a new
+JWT token.
```

## odoo/addons/auth_jwt/static/description/index.html

### odoo/addons/auth_jwt/static/description/index.html

```diff
@@ -493,15 +493,16 @@
           <tt class="docutils literal">exp</tt>
           claim is validated to reject expired tokens.
         </p>
         <p>
           If the
           <tt class="docutils literal">Authorization</tt>
           HTTP header is missing, malformed, or contains
-an invalid token, the request is rejected with a 401 (Unauthorized) code.
+an invalid token, the request is rejected with a 401 (Unauthorized) code,
+unless the cookie mode is enabled (see below).
         </p>
         <p>
           If the token is valid, the request executes with the configured user id. By
 default the user id selection strategy is
           <tt class="docutils literal">static</tt>
           (i.e. the same for all
 requests) and the selected user is configured on the JWT validator. Additional
@@ -555,14 +556,27 @@
           method when the Authorization header is not set. If it is set, the regular JWT
 authentication is performed as described above. This method is useful for public
 endpoints that need to work for anonymous users, but can be enhanced when an
 authenticated user is know. A typical use case is a “add to cart” endpoint that can work
 for anonymous users, but can be enhanced by binding the cart to a known customer when
 the authenticated user is known.
         </p>
+        <p>
+          You can enable a cookie mode on JWT validators. In this case, the JWT payload obtained
+from the
+          <tt class="docutils literal">Authorization</tt>
+          header is returned as a Http-Only cookie. This mode is
+sometimes simpler for front-end applications which do not then need to store and protect
+the JWT token across requests and can simply rely on the cookie management mechanisms of
+browsers. When both the
+          <tt class="docutils literal">Authorization</tt>
+          header and a cookie are provided, the cookie
+is ignored in order to let clients authenticate with a different user by providing a new
+JWT token.
+        </p>
       </div>
       <div class="section" id="bug-tracker">
         <h1>
           <a class="toc-backref" href="#id3">Bug Tracker</a>
         </h1>
         <p>
           Bugs are tracked on
```

## odoo/addons/auth_jwt/tests/test_auth_jwt.py

```diff
@@ -11,16 +11,16 @@
 from odoo.exceptions import ValidationError
 from odoo.tests.common import TransactionCase
 from odoo.tools import mute_logger
 from odoo.tools.misc import DotDict
 
 from ..exceptions import (
     AmbiguousJwtValidator,
-    CompositeJwtError,
     JwtValidatorNotFound,
+    UnauthorizedCompositeJwtError,
     UnauthorizedInvalidToken,
     UnauthorizedMalformedAuthorizationHeader,
     UnauthorizedMissingAuthorizationHeader,
     UnauthorizedPartnerNotFound,
 )
 
 
@@ -86,30 +86,32 @@
                 static_user_id=static_user_id,
                 partner_id_strategy="email",
                 partner_id_required=partner_id_required,
             )
         )
 
     def test_missing_authorization_header(self):
+        self._create_validator("validator")
         with self._mock_request(authorization=None):
             with self.assertRaises(UnauthorizedMissingAuthorizationHeader):
-                self.env["ir.http"]._auth_method_jwt()
+                self.env["ir.http"]._auth_method_jwt(validator_name="validator")
 
     def test_malformed_authorization_header(self):
+        self._create_validator("validator")
         for authorization in (
             "a",
             "Bearer",
             "Bearer ",
             "Bearer x y",
             "Bearer token ",
             "bearer token",
         ):
             with self._mock_request(authorization=authorization):
                 with self.assertRaises(UnauthorizedMalformedAuthorizationHeader):
-                    self.env["ir.http"]._auth_method_jwt()
+                    self.env["ir.http"]._auth_method_jwt(validator_name="validator")
 
     def test_auth_method_valid_token(self):
         self._create_validator("validator")
         authorization = "Bearer " + self._create_token()
         with self._mock_request(authorization=authorization):
             self.env["ir.http"]._auth_method_jwt_validator()
 
@@ -190,15 +192,15 @@
         validator3.next_validator_id = validator4
         validator4.next_validator_id = validator5
         validator5.next_validator_id = validator6
         validator6.next_validator_id = validator7
 
         authorization = "Bearer " + self._create_token()
         with self._mock_request(authorization=authorization):
-            with self.assertRaises(CompositeJwtError) as composite_error:
+            with self.assertRaises(UnauthorizedCompositeJwtError) as composite_error:
                 self.env["ir.http"]._auth_method_jwt_validator()
             self.assertEqual(
                 str(composite_error.exception),
                 "401 Unauthorized: Multiple errors occurred during JWT chain validation:\n"
                 "validator: 401 Unauthorized: "
                 "The server could not verify that you are authorized to "
                 "access the URL requested. You either supplied the wrong "
```

## odoo/addons/auth_jwt/views/auth_jwt_validator_views.xml

### odoo/addons/auth_jwt/views/auth_jwt_validator_views.xml

```diff
@@ -3,35 +3,41 @@
   <record id="view_auth_jwt_validator_form" model="ir.ui.view">
     <field name="name">auth.jwt.validator.form</field>
     <field name="model">auth.jwt.validator</field>
     <field name="arch" type="xml">
       <form string="arch">
         <sheet>
           <group col="4">
-            <group colspan="2">
+            <group colspan="2" string="General">
               <field name="name"/>
-              <field name="audience"/>
               <field name="next_validator_id"/>
             </group>
-            <group colspan="2">
+            <group colspan="2" string="Token validation">
+              <field name="audience"/>
               <field name="issuer"/>
               <field name="signature_type"/>
               <field name="secret_key" string="Key" attrs="{'invisible': [('signature_type', '!=', 'secret')],                                     'required': [('signature_type', '=', 'secret')]}"/>
               <field name="secret_algorithm" string="Algorithm" attrs="{'invisible': [('signature_type', '!=', 'secret')],                                     'required': [('signature_type', '=', 'secret')]}"/>
               <field name="public_key_jwk_uri" string="JWK URI" attrs="{'invisible': [('signature_type', '!=', 'public_key')],                                     'required': [('signature_type', '=', 'public_key')]}" widget="url"/>
               <field name="public_key_algorithm" string="Algorithm" attrs="{'invisible': [('signature_type', '!=', 'public_key')],                                     'required': [('signature_type', '=', 'public_key')]}"/>
             </group>
-            <group colspan="2">
+            <group colspan="2" string="User">
               <field name="user_id_strategy"/>
               <field name="static_user_id" attrs="{'invisible': [('user_id_strategy', '!=', 'static')],                                         'required': [('user_id_strategy', '=', 'static')]}"/>
             </group>
-            <group colspan="2">
+            <group colspan="2" string="Partner">
               <field name="partner_id_strategy"/>
               <field name="partner_id_required"/>
             </group>
+            <group colspan="2" string="Cookie">
+              <field name="cookie_enabled"/>
+              <field name="cookie_name" attrs="{'required': [('cookie_enabled', '=', True)],                                         'invisible': [('cookie_enabled', '=', False)]}"/>
+              <field name="cookie_path" attrs="{'invisible': [('cookie_enabled', '=', False)]}"/>
+              <field name="cookie_max_age" attrs="{'invisible': [('cookie_enabled', '=', False)]}"/>
+            </group>
           </group>
         </sheet>
       </form>
     </field>
   </record>
   <record id="view_auth_jwt_validator_tree" model="ir.ui.view">
     <field name="name">auth.jwt.validator.tree</field>
```

## Comparing `odoo_addon_auth_jwt-16.0.1.0.0.3.dist-info/METADATA` & `odoo_addon_auth_jwt-16.0.1.1.0.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: odoo-addon-auth-jwt
-Version: 16.0.1.0.0.3
+Version: 16.0.1.1.0
 Summary: JWT bearer token authentication.
 Home-page: https://github.com/OCA/server-auth
 Author: ACSONE SA/NV,Odoo Community Association (OCA)
 Author-email: support@odoo-community.org
 License: LGPL-3
 Platform: UNKNOWN
 Classifier: Programming Language :: Python
@@ -80,15 +80,16 @@
 * ``issuer``: used to validate the ``iss`` claim.
 * Signature type (secret or public key), algorithm, secret and JWK URI
   are used to validate the token signature.
 
 In addition, the ``exp`` claim is validated to reject expired tokens.
 
 If the ``Authorization`` HTTP header is missing, malformed, or contains
-an invalid token, the request is rejected with a 401 (Unauthorized) code.
+an invalid token, the request is rejected with a 401 (Unauthorized) code,
+unless the cookie mode is enabled (see below).
 
 If the token is valid, the request executes with the configured user id. By
 default the user id selection strategy is ``static`` (i.e. the same for all
 requests) and the selected user is configured on the JWT validator. Additional
 strategies can be provided by overriding the ``_get_uid()`` method and
 extending the ``user_id_strategy`` selection field.
 
@@ -110,14 +111,22 @@
 method when the Authorization header is not set. If it is set, the regular JWT
 authentication is performed as described above. This method is useful for public
 endpoints that need to work for anonymous users, but can be enhanced when an
 authenticated user is know. A typical use case is a "add to cart" endpoint that can work
 for anonymous users, but can be enhanced by binding the cart to a known customer when
 the authenticated user is known.
 
+You can enable a cookie mode on JWT validators. In this case, the JWT payload obtained
+from the ``Authorization`` header is returned as a Http-Only cookie. This mode is
+sometimes simpler for front-end applications which do not then need to store and protect
+the JWT token across requests and can simply rely on the cookie management mechanisms of
+browsers. When both the ``Authorization`` header and a cookie are provided, the cookie
+is ignored in order to let clients authenticate with a different user by providing a new
+JWT token.
+
 Bug Tracker
 ===========
 
 Bugs are tracked on `GitHub Issues <https://github.com/OCA/server-auth/issues>`_.
 In case of trouble, please check there if your issue has already been reported.
 If you spotted it first, help us smashing it by providing a detailed and welcomed
 `feedback <https://github.com/OCA/server-auth/issues/new?body=module:%20auth_jwt%0Aversion:%2016.0%0A%0A**Steps%20to%20reproduce**%0A-%20...%0A%0A**Current%20behavior**%0A%0A**Expected%20behavior**>`_.
```

